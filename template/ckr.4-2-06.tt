@comment
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
ishiura-gcc@ksc.kwansei.ac.jp

This file was written by Yuki Uchiyama. (ishiura-gcc@ksc.kwansei.ac.jp)
@comment_

@include
license.inc
@include_

@def $HEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "def.h"
@def_

@def $FHEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "fdef.h"
@def_

@def $macro0()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
#define NoMistake 00
@def_

@def $macro1()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
float           OK_f = 1.0;
float           NO_f = 0.0;
#define NoMistake 00
@def_

@def $macro2()
$LICENSE()
$FHEAD()
short           statusFlag = NoMistake;
float           dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and legal 
 */
{
	levelOneNodeOne(dummy(1.0));
	levelOneNodeTwo(dummy(2.0));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	levelTwoNodeOne(dummy(3.0));
	levelTwoNodeTwo(dummy(4.0));
}

levelOneNodeTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	levelTwoNodeThree(dummy(5.0));
	levelTwoNodeFour(dummy(6.0));
}

levelTwoNodeOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	levelThreeLeafOne(dummy(7.0));
	levelThreeLeafTwo(dummy(8.0));
}

levelTwoNodeTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	levelThreeLeafThree(dummy(9.0));
	levelThreeLeafFour(dummy(10.0));
}

levelTwoNodeThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	levelThreeLeafFive(dummy(11.0));
	levelThreeLeafSix(dummy(12.0));
}

levelTwoNodeFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	levelThreeLeafSeven(dummy(13.0));
	levelThreeLeafEight(dummy(14.0));
}

levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
dummy(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro3()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float	dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	float           i = 0.0;

	i = levelOneNodeOne(dummy(1.0));
	i = levelOneNodeTwo(dummy(2.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(dummy(3.0));
	i = levelTwoNodeTwo(dummy(4.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelOneNodeTwo(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(dummy(5.0));
	i = levelTwoNodeFour(dummy(6.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeOne(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(dummy(7.0));
	i = levelThreeLeafTwo(dummy(8.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeTwo(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(dummy(9.0));
	i = levelThreeLeafFour(dummy(10.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeThree(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(dummy(11.0));
	i = levelThreeLeafSix(dummy(12.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeFour(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13.0));
	i = levelThreeLeafEight(dummy(14.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
dummy(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro4()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float	dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, Float function declaration 
 */
{
	float           i = 0.0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(dummy(1.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelOneNodeTwo(dummy(2.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(dummy(3.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeTwo(dummy(4.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelOneNodeTwo(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(dummy(5.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeFour(dummy(6.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeOne(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(dummy(7.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafTwo(dummy(8.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeTwo(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(dummy(9.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafFour(dummy(10.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeThree(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(dummy(11.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafSix(dummy(12.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeFour(argument)
	float           argument;
{
	float           i = 0.0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafEight(dummy(14.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
	return (argument);
}

float 
dummy(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro5()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float	twelve();

main()
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning a
 * float 
 */
{
	float           i, divide4(), dummy1();

	i = dummy1(divide4, twelve());
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	i = (*func) (twelve());
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float           Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	i = (*func) (twelve());
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float           Float;
{
	return (Float / 2.0);
}

float 
twelve()
{
	return (12.0);
}
@def_
@def $macro6()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           object = 1.0;
float	mirror();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	float           levelOneNodeOne();
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(mirror(object));
	arg_b = object;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(argument)
	float           argument;
{
	float           object = argument + 2.0;
	float           levelTwoNodeOne();
	float           arg_a, arg_b;

	arg_a = levelTwoNodeOne(mirror(object));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeOne(argument)
	float           argument;
{
	float           object = argument + 4.0;
	float           levelThreeLeafOne();
	float           arg_a, arg_b;

	arg_a = levelThreeLeafOne(mirror(object));
	arg_b = 7.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return (argument);
}

float 
mirror(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro7()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float	twelve();

main()
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a float 
 */
{
	float           divide4(), dummy1();
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, twelve());
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	if ( !(TGEN_FLT_EQ((i = (*func) (twelve())), 3.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float           Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	if ( !(TGEN_FLT_EQ((i = (*func) (twelve())), 6.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float           Float;
{
	return (Float / 2.0);
}

float 
twelve()
{
	return (12.0);
}
@def_
@def $macro8()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           un();

main()
/*
 * test class: function as argument instance  : recursive call, no return value, legal 
 */
{
	recursiveFunction(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(un());
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}
@def_
@def $macro9()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;
float           un();

main()
/*
 * test class: function as argument instance  : recursive call, no return value, illegal 
 */
{
	result = recursiveFunction(un());
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		result = recursiveFunction(un());
	return;
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}
@def_
@def $macro10()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float	un();

main()
/*
 * test class: function as argument instance  : recursive call, return value, legal, Float function declaration 
 */
{
	float           i = 0.0;
	float           recursiveFunction();

	i = recursiveFunction(un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(argument)
	float           argument;
{
	float           i;
	float           recursiveFunction();

	if (--counter) {
		i = recursiveFunction(un());
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return (++argument);
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}
@def_
@def $macro11()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float	un();

main()
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning a float 
 */
{
	float           i, increment(), dummy();

	i = dummy(increment, un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, argument)
	float           (*function) (), argument;
{
	float           i, dummy();
	if (--counter) {
		i = dummy(function, un());
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
un()
{
	float           un = 1.0;
	return (un);
}
@def_
@def $macro12()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           un();

main()
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	float           recursiveFunction();
	float           arg_a, arg_b;

	arg_a = recursiveFunction(un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(argument)
	float           argument;
{
	float           recursiveFunction();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(un());
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (++argument);
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}
@def_
@def $macro13()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           un();

main()
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning a
 * float 
 */
{
	float           increment(), dummy();
	float           arg_a, arg_b;

	arg_a = dummy(increment, un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, argument)
	float           (*function) (), argument;
{
	float           dummy();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, un());
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}
@def_
@def $macro14()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, no return value, legal 
 */
{
	float           un();

	castor(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	float           argument;
{
	float           deux();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		pollux(deux());
}

pollux(argument)
	float           argument;
{
	float           un();

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	if (--counter)
		castor(un());
}

float 
un()
{
	float           un = 1.0;
	return (un);
}

float 
deux()
{
	float           deux = 2.0;
	return (deux);
}
@def_
@def $macro15()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;

main()
/*
 * test class: function as argument instance  : gemini, no return value, illegal 
 */
{
	float           un();

	result = castor(un());
	if ( !(TGEN_FLT_EQ(result, 0.0)) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	float           argument;
{
	float           deux();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		result = pollux(deux());
}

pollux(argument)
	float           argument;
{
	float           un();

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	if (--counter)
		result = castor(un());
}

float 
un()
{
	float           un = 1.0;
	return (un);
}

float 
deux()
{
	float           deux = 2.0;
	return (deux);
}
@def_
@def $macro16()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return a float 
 */
{
	float           i = 0.0, castor(), rebound();

	i = castor(rebound(1.0));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(argument)
	float           argument;
{
	float           i, pollux(), rebound();

	if (--counter) {
		i = pollux(rebound(4.0));
		if ( !(TGEN_FLT_EQ(i, 5.0)) )
			statusFlag++;
	}
	return (++argument);
}

float 
pollux(argument)
	float           argument;
{
	float           i, rebound(), castor();

	if (--counter) {
		i = castor(rebound(1.0));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return (++argument);
}

float 
rebound(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro17()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning a float 
 */
{
	float           i, increment(), un();
	float           castor();

	i = castor(increment, un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, argument)
	float           (*function) (), argument;
{
	float           i, neuf(), pollux();
	if (--counter) {
		i = pollux(function, neuf());
		if ( !(TGEN_FLT_EQ(i, 10.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
pollux(function, argument)
	float           (*function) (), argument;
{
	float           i, trois(), castor();
	if (--counter) {
		i = castor(function, trois());
		if ( !(TGEN_FLT_EQ(i, 4.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
un()
{
	return (Un);
}

float 
trois()
{
	return (Trois);
}

float 
neuf()
{
	return (Neuf);
}
@def_
@def $macro18()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a float 
 */
{
	float           castor(), numero();
	float           arg_a, arg_b;

	arg_a = castor(numero((float) Un));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(argument)
	float           argument;
{
	float           pollux(), numero();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(numero((float) Quatre));
		arg_b = 5.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (++argument);
}

float 
pollux(argument)
	float           argument;
{
	float           castor(), numero();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(numero((float) Un));
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (++argument);
}

float 
numero(questCa)
	float           questCa;
{
	return (questCa);
}
@def_
@def $macro19()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning a float 
 */
{
	float           increment(), un(), castor();
	float           arg_a, arg_b;

	arg_a = castor(increment, un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, argument)
	float           (*function) (), argument;
{
	float           neuf(), pollux();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(function, neuf());
		arg_b = 10.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
pollux(function, argument)
	float           (*function) (), argument;
{
	float           trois(), castor();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(function, trois());
		arg_b = 4.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
un()
{
	static float    un = 1.0;
	return (un);
}

float 
trois()
{
	static float    trois = 3.0;
	return (trois);
}

float 
neuf()
{
	static float    neuf = 9.0;
	return (neuf);
}
@def_
@def $macro20()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument, variable order not determined instance  : recursive call, no return value, legal 
 */
{
	float           i = 0.0, a, b, c, indeterminacy();

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(indeterminacy(a, b, c));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	float           i = 0.0, a, b, c, indeterminacy();

	if ( !(TGEN_FLT_EQ(argument, -3.0)) )
		statusFlag++;
	if (--counter) {
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(indeterminacy(a, b, c));
	}
}

float 
indeterminacy(uno, dos, tres)
	float           uno, dos, tres;
{
	return (uno + dos + tres);
}
@def_
@def $macro21()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and legal 
 */
{
	float           uno();
	float           dos();
	float           tres();
	levelOneNodeOne(uno(dos(tres(1.0))));
	levelOneNodeTwo(uno(dos(tres(2.0))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	levelTwoNodeOne(uno(dos(tres(3.0))));
	levelTwoNodeTwo(uno(dos(tres(4.0))));
}

levelOneNodeTwo(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	levelTwoNodeThree(uno(dos(tres(5.0))));
	levelTwoNodeFour(uno(dos(tres(6.0))));
}

levelTwoNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	levelThreeLeafOne(uno(dos(tres(7.0))));
	levelThreeLeafTwo(uno(dos(tres(8.0))));
}

levelTwoNodeTwo(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	levelThreeLeafThree(uno(dos(tres(9.0))));
	levelThreeLeafFour(uno(dos(tres(10.0))));
}

levelTwoNodeThree(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	levelThreeLeafFive(uno(dos(tres(11.0))));
	levelThreeLeafSix(uno(dos(tres(12.0))));
}

levelTwoNodeFour(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	levelThreeLeafSeven(uno(dos(tres(13.0))));
	levelThreeLeafEight(uno(dos(tres(14.0))));
}

levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro22()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           uno();
float           dos();
float           tres();

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	float           i = 0.0;

	i = levelOneNodeOne(uno(dos(tres(1.0))));
	i = levelOneNodeTwo(uno(dos(tres(2.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float           argument;
{

	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3.0))));
	i = levelTwoNodeTwo(uno(dos(tres(4.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelOneNodeTwo(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5.0))));
	i = levelTwoNodeFour(uno(dos(tres(6.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeOne(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7.0))));
	i = levelThreeLeafTwo(uno(dos(tres(8.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeTwo(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9.0))));
	i = levelThreeLeafFour(uno(dos(tres(10.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeThree(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11.0))));
	i = levelThreeLeafSix(uno(dos(tres(12.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelTwoNodeFour(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13.0))));
	i = levelThreeLeafEight(uno(dos(tres(14.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro23()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, Float function
 * declaration 
 */
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(uno(dos(tres(1.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelOneNodeTwo(uno(dos(tres(2.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeTwo(uno(dos(tres(4.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelOneNodeTwo(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeFour(uno(dos(tres(6.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafTwo(uno(dos(tres(8.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeTwo(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafFour(uno(dos(tres(10.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeThree(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafSix(uno(dos(tres(12.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeFour(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           i = 0.0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafEight(uno(dos(tres(14.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafTwo(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafThree(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafFour(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafFive(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafSix(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafSeven(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafEight(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
	return (argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro24()
$LICENSE()
$FHEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;
float           half();
float           twoTimes();

main()
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning a float 
 */
{
	float           twentyFour();

	float           i, divide4(), dummy1();

	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	i = (*func) (half(twoTimes(i)));
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float           Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), Float;
{
	float           i = Float;

	i = (*func) (twoTimes(half(i)));
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float           Float;
{
	return (Float / 2.0);
}

float 
twentyFour()
{
	return (TwoDozen);
}

float 
twoTimes(argument)
	float           argument;
{
	return (2.0 * argument);
}

float 
half(argument)
	float           argument;
{
	return (argument / 2.0);
}
@def_
@def $macro25()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           object = 1.0;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, Float
 * function declaration 
 */
{
	float           uno();
	float           dos();
	float           tres();
	float           levelOneNodeOne();
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(uno(dos(tres(object))));
	arg_b = object;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           object = argument + 2.0;
	float           levelTwoNodeOne();
	float           arg_a, arg_b;

	arg_a = levelTwoNodeOne(uno(dos(tres(object))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (argument);
}

float 
levelTwoNodeOne(argument)
	float           argument;
{
	float           uno();
	float           dos();
	float           tres();
	float           object = argument + 4.0;
	float           levelThreeLeafOne();
	float           arg_a, arg_b;

	arg_a = levelThreeLeafOne(uno(dos(tres(object))));
	arg_b = 7.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (argument);
}

float 
levelThreeLeafOne(argument)
	float           argument;
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return (argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro26()
$LICENSE()
$FHEAD()

#define TwoDouzen 24.0
short           statusFlag = NoMistake;
float           half();
float           twoTimes();

main()
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a float 
 */
{
	float           divide4(), dummy1();
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, half(twoTimes(half(TwoDouzen))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), Float;
{
	float           i;
	float           arg_a, arg_b;

	arg_a = (i = (*func) (twoTimes(half(Float))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float           Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), Float;
{
	float           i;
	float           arg_a, arg_b;

	arg_a = (i = (*func) (twoTimes(half(Float))));
	arg_b = 6.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float           Float;
{
	return (Float / 2.0);
}

float 
twoTimes(argument)
	float           argument;
{
	return (2.0 * argument);
}

float 
half(argument)
	float           argument;
{
	return (argument / 2.0);
}
@def_
@def $macro27()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, no return value, legal 
 */
{
	float           dos(), tres(), uno();
	recursiveFunction(uno(dos(tres(Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	float           dos(), tres(), uno();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(uno(dos(tres(Un))));
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro28()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, no return value, illegal 
 */
{
	float           uno(), dos(), tres();
	float           i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 1.0)) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	float           uno(), dos(), tres();
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 1.0)) )
			i++;
	}
	return;
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro29()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, Float function declaration 
 */
{
	float           uno(), dos(), tres();
	float           i, recursiveFunction();

	i = recursiveFunction(uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(argument)
	float           argument;
{
	float           uno(), dos(), tres();
	float           i, recursiveFunction();

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro30()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning a float 
 */
{
	float           uno(), dos(), tres();
	float           i, increment(), dummy();

	i = dummy(increment, uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, argument)
	float           (*function) (), argument;
{
	float           uno(), dos(), tres();
	float           i, dummy();
	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro31()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	float           uno(), dos(), tres();
	float           recursiveFunction();
	float           arg_a, arg_b;

	arg_a = recursiveFunction(uno(dos(tres(Un))));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(argument)
	float           argument;
{
	float           uno(), dos(), tres();
	float           recursiveFunction();

	if (--counter)
		if ( !(TGEN_FLT_EQ(recursiveFunction(uno(dos(tres(Un)))), 2.0)) )
			statusFlag++;
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro32()
$LICENSE()
$FHEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning a float 
 */
{
	float           increment(), uno(), dos(), tres(), dummy();
	float           arg_a, arg_b;

	arg_a = dummy(increment, uno(dos(tres((float) Un))));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, argument)
	float           (*function) (), argument;
{
	float           uno(), dos(), tres(), dummy();

	if (--counter)
		if ( !(TGEN_FLT_EQ(dummy(function, uno(dos(tres((float) Un)))), 2.0)) )
			statusFlag++;
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro33()
$LICENSE()
$FHEAD()

#define Un   1
#define Deux 2
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, no return value, legal 
 */
{
	float           uno(), dos(), tres();

	castor(uno(dos(tres((float) Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	float           argument;
{
	float           uno(), dos(), tres();

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		pollux(uno(dos(tres((float) Deux))));
}

pollux(argument)
	float           argument;
{
	float           uno(), dos(), tres();

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	if (--counter)
		castor(uno(dos(tres((float) Un))));
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro34()
$LICENSE()
$FHEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;
float           uno(), dos(), tres();

main()
/*
 * test class: nested function as argument instance  : gemini, no return value, illegal 
 */
{
	float           i;

	i = castor(uno(dos(tres())));
	if ( !(TGEN_FLT_EQ(i, 1.0)) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, Un)) )
		statusFlag++;
	if (--counter) {
		i = pollux(uno(dos(tres())));
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			i++;
	}
}

pollux(argument)
	float           argument;
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, Un)) )
		statusFlag++;
	if (--counter) {
		i = castor(uno(dos(tres())));
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			i++;
	}
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres()
{
	return (Un);
}
@def_
@def $macro35()
$LICENSE()
$FHEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return a float 
 */
{
	float           i, castor(), uno(), dos(), tres();

	i = castor(uno(dos(tres((float) Un))));
	if ( !(TGEN_FLT_EQ(i, Deux)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(argument)
	float           argument;
{
	float           i, pollux(), uno(), dos(), tres();

	if (--counter) {
		i = pollux(uno(dos(tres((float) Quatre))));
		if ( !(TGEN_FLT_EQ(i, Cinq)) )
			statusFlag++;
	}
	return (++argument);
}

float 
pollux(argument)
	float           argument;
{
	float           i, uno(), dos(), tres();

	if (--counter) {
		i = castor(uno(dos(tres((float) Un))));
		if ( !(TGEN_FLT_EQ(i, Deux)) )
			statusFlag++;
	}
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro36()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning a float 
 */
{
	float           i, increment(), uno(), dos(), tres(), castor();

	i = castor(increment, uno(dos(tres((float) Un))));
	if ( !(TGEN_FLT_EQ(i, Un + 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, argument)
	float           (*function) (), argument;
{
	float           i, uno(), dos(), tres(), pollux();

	if (--counter) {
		i = pollux(function, uno(dos(tres((float) Neuf))));
		if ( !(TGEN_FLT_EQ(i, Neuf + 1.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
pollux(function, argument)
	float           (*function) (), argument;
{
	float           i, uno(), dos(), tres(), castor();

	if (--counter) {
		i = castor(function, uno(dos(tres((float) Trois))));
		if ( !(TGEN_FLT_EQ(i, Trois + 1.0)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro37()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a
 * float 
 */
{
	float           castor(), uno(), dos(), tres();
	float           arg_a, arg_b;

	arg_a = castor(uno(dos(tres((float) Un))));
	arg_b = Deux;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(argument)
	float           argument;
{
	float           pollux(), uno(), dos(), tres();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(uno(dos(tres((float) Quatre))));
		arg_b = Cinq;
		if ( !(TGEN_FLT_EQ(arg_a, arg_a)) )
			statusFlag++;
	}
	return (++argument);
}

float 
pollux(argument)
	float           argument;
{
	float           uno(), dos(), tres(), castor();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(uno(dos(tres((float) Un))));
		arg_b = Deux;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro38()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning a
 * float 
 */
{
	float           increment();
	float           uno(), dos(), tres(), castor();


	if ( !(TGEN_FLT_EQ(castor(increment, uno(dos(tres((float) Un)))), Deux)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, argument)
	float           (*function) (), argument;
{
	float           uno(), dos(), tres(), pollux();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(function, uno(dos(tres((float) Neuf))));
		arg_b = Dix;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
pollux(function, argument)
	float           (*function) (), argument;
{
	float           uno(), dos(), tres(), castor();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(function, uno(dos(tres((float) Trois))));
		arg_b = Quatre;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function(argument));
}

float 
increment(argument)
	float           argument;
{
	return (++argument);
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(argument)
	float           argument;
{
	return (argument);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro39()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument, random order instance  : recursive call, no return value, legal 
 */
{
	float           i = 0.0, a, b, c, uno(), dos(), tres();

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	float           argument;
{
	float           i = 0.0, a, b, c, uno(), dos(), tres();

	if ( !(TGEN_FLT_EQ(argument, -3.0)) )
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	}
}

float 
uno(argument)
	float           argument;
{
	return (argument);
}

float 
dos(uno, dos, tres)
	float           uno, dos, tres;
{
	return (uno + dos + tres);
}

float 
tres(argument)
	float           argument;
{
	return (argument);
}
@def_
@def $macro40()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, no return value and
 * legal 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;

	levelOneNodeOne((unsigned) (i - 2 * j - k));
	levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	unsigned        variable;
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

levelOneNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable + 2;
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

levelTwoNodeOne(variable)
	unsigned        variable;
{
	unsigned        i = variable * 2;
	if (variable != 3L)
		statusFlag++;
	levelThreeeafOne((i += 8) / 2);
	levelThreeeafTwo(variable + (i - 8) / variable + 3);
}

levelTwoNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable;
	if (variable != 4L)
		statusFlag++;
	levelThreeeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeeafFour(2 * (variable + 3) - i + 1);
}

levelTwoNodeThree(variable)
	unsigned        variable;
{
	unsigned        i = variable--;
	if (variable != 4L)
		statusFlag++;
	levelThreeeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

levelTwoNodeFour(variable)
	unsigned        variable;
{
	unsigned        i = variable / 2 - 1;
	if (variable != 6L)
		statusFlag++;
	levelThreeeafSeven(variable + i * (variable - i) - 1);
	levelThreeeafEight(i * (2 * variable - i) - variable);
}

levelThreeeafOne(variable)
	unsigned        variable;
{
	if (variable != 7L)
		statusFlag++;
}

levelThreeeafTwo(variable)
	unsigned        variable;
{
	if (variable != 8L)
		statusFlag++;
}

levelThreeeafThree(variable)
	unsigned        variable;
{
	if (variable != 9L)
		statusFlag++;
}

levelThreeeafFour(variable)
	unsigned        variable;
{
	if (variable != 10L)
		statusFlag++;
}

levelThreeeafFive(variable)
	unsigned        variable;
{
	if (variable != 11L)
		statusFlag++;
}

levelThreeeafSix(variable)
	unsigned        variable;
{
	if (variable != 12L)
		statusFlag++;
}

levelThreeeafSeven(variable)
	unsigned        variable;
{
	if (variable != 13L)
		statusFlag++;
}

levelThreeeafEight(variable)
	unsigned        variable;
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro41()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, no return value and
 * illegal 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;

	result = levelOneNodeOne((unsigned) (i - 2 * j - k));
	result = levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	unsigned        variable;
{
	if (variable != 1L)
		statusFlag++;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

levelOneNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable + 2;

	if (variable != 2L)
		statusFlag++;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

levelTwoNodeOne(variable)
	unsigned        variable;
{
	unsigned        i = variable * 2;

	if (variable != 3L)
		statusFlag++;
	result = levelThreeeafOne((i += 8) / 2);
	result = levelThreeeafTwo(variable + (i - 8) / variable + 3);
}

levelTwoNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	result = levelThreeeafFour(2 * (variable + 3) - i + 1);
}

levelTwoNodeThree(variable)
	unsigned        variable;
{
	unsigned        i = variable--;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeeafFive((i + variable-- + 3) / 2 + 5);
	result = levelThreeeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

levelTwoNodeFour(variable)
	unsigned        variable;
{
	unsigned        i = variable / 2 - 1;

	if (variable != 6L)
		statusFlag++;
	result = levelThreeeafSeven(variable + i * (variable - i) - 1);
	result = levelThreeeafEight(i * (2 * variable - i) - variable);
}

levelThreeeafOne(variable)
	unsigned        variable;
{
	if (variable != 7L)
		statusFlag++;
	return;
}

levelThreeeafTwo(variable)
	unsigned        variable;
{
	if (variable != 8L)
		statusFlag++;
	return;
}

levelThreeeafThree(variable)
	unsigned        variable;
{
	if (variable != 9L)
		statusFlag++;
	return;
}

levelThreeeafFour(variable)
	unsigned        variable;
{
	if (variable != 10L)
		statusFlag++;
	return;
}

levelThreeeafFive(variable)
	unsigned        variable;
{
	if (variable != 11L)
		statusFlag++;
	return;
}

levelThreeeafSix(variable)
	unsigned        variable;
{
	if (variable != 12L)
		statusFlag++;
	return;
}

levelThreeeafSeven(variable)
	unsigned        variable;
{
	if (variable != 13L)
		statusFlag++;
	return;
}

levelThreeeafEight(variable)
	unsigned        variable;
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro42()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, Long function declaration 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;
	long            result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne((unsigned) (i - 2 * j - k));
	if (result != 1L)
		statusFlag++;
	result = levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	unsigned        variable;
{
	long            result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3L)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4L)
		statusFlag++;
	return (variable);
}

long 
levelOneNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable + 2;
	long            result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeOne(variable)
	unsigned        variable;
{
	unsigned        i = variable * 2;
	long            result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable;
	long            result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeThree(variable)
	unsigned        variable;
{
	unsigned        i = variable--;
	long            result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12L)
		statusFlag++;
	return (i);
}

long 
levelTwoNodeFour(variable)
	unsigned        variable;
{
	unsigned        i = variable / 2 - 1;
	long            result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14L)
		statusFlag++;
	return (variable);
}

long 
levelThreeLeafOne(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafTwo(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafThree(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafFour(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafFive(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafSix(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafSeven(variable)
	unsigned        variable;
{
	return (variable);
}

long 
levelThreeLeafEight(variable)
	unsigned        variable;
{
	return (variable);
}
@def_
@def $macro43()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

long            result;
short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, no return value, illegal 
 */
{
	unsigned        i = 0;
	long            counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	unsigned        variable;
	long            counter;
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
}
@def_
@def $macro44()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            recursiveFunction();

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, Long function
 * declaration 
 */
{
	unsigned        i = 0;
	long            result = 0;
	long            counter = TimeLimit;
	long            recursiveFunction();

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable, counter)
	unsigned        variable;
	long            counter;
{
	long            result = 0;
	long            storage = variable + 1;
	long            recursiveFunction();

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro45()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	unsigned        recursiveFunction();
	long            i = -1;
	long            counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

unsigned 
recursiveFunction(variable, counter)
	long            variable, counter;
{
	long            storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1L)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro46()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * pointer to function returning a long 
 */
{
	long            increment(), dummy();
	char            i = 2, j = 1;

	if (dummy(increment, (unsigned) (j + i * j >= 10 || i - j > 0)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) ();
unsigned        variable;
{
	unsigned        storage = variable;
	long            dummy();

	if (--counter)
		if (dummy(function, (unsigned) ((++variable - 1 == 0) + 1)) != 2L)
			statusFlag++;
	return (function(storage));
}

long 
increment(variable)
	unsigned        variable;
{
	return (++variable);
}
@def_
@def $macro47()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, no return value, illegal 
 */
{
	unsigned        i = 1, j = 2;
	long            counter = TimeLimit;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	unsigned        variable;
	long            counter;
{
	unsigned        i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		result = pollux((i & i == i) + (j == i), counter);
}

pollux(variable, counter)
	unsigned        variable;
	long            counter;
{
	unsigned        i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		result = castor((i & i == i & i) + (j != i), counter);
}
@def_
@def $macro48()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	long            counter = TimeLimit;
	long            result = 0, castor();

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable, counter)
	char            variable;
	long            counter;
{
	unsigned        i = 1, j = 2;
	long            result = 0, pollux();

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1L)
			statusFlag++;
	}
	return (variable);
}

long 
pollux(variable, counter)
	unsigned        variable;
	long            counter;
{
	char            i = 1, j = 2;
	long            result = 0, castor();

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2L)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro49()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	unsigned        i = 0;
	long            increment(), castor();

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) ();
unsigned        variable;
{
	long            ii = 0, pollux();

	if (--counter) {
		ii = pollux(function, (unsigned) (variable + 2 * (ii + 2) * (variable + 1)));
		if (ii != 10L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) ();
unsigned        variable;
{
	long            iii = 0, castor();

	if (--counter) {
		iii = castor(function, (unsigned) (variable - 2 * (iii + 2) * (11 - variable)));
		if (iii != 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	unsigned        variable;
{
	return (++variable);
}
@def_
@def $macro50()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	long            i = 0;
	long            castor();

	if (castor(++i && ++i ? --i : i + 2) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long            variable;
{
	long            pollux();
	if (--counter) {
		if (pollux(2 * variable + 2L / variable) != 5L)
			statusFlag++;
	}
	return (++variable);
}

long 
pollux(variable)
	long            variable;
{
	long            castor();
	if (--counter) {
		if (castor(2 * variable - 7) != 2L)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro51()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, no return value and
 * legal 
 */
{
	static long     i = 0, j = -1, k = 1;

	levelOneNodeOne(i - 2 * j + (-k));
	levelOneNodeTwo((i + j) * j + k);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long            variable;
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

levelOneNodeTwo(variable)
	long            variable;
{
	long            i = variable + 2;
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

levelTwoNodeOne(variable)
	long            variable;
{
	long            i = variable * 2;
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i += 8) / 2);
	levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

levelTwoNodeTwo(variable)
	long            variable;
{
	long            i = variable;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

levelTwoNodeThree(variable)
	long            variable;
{
	long            i = variable--;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

levelTwoNodeFour(variable)
	long            variable;
{
	long            i = variable / 2 - 1;
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable + i * (variable - i) - 1);
	levelThreeLeafEight(i * (2 * variable - i) - variable);
}

levelThreeLeafOne(variable)
	long            variable;
{
	if (variable != 7L)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	long            variable;
{
	if (variable != 8L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long            variable;
{
	if (variable != 9L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long            variable;
{
	if (variable != 10L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long            variable;
{
	if (variable != 11L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long            variable;
{
	if (variable != 12L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long            variable;
{
	if (variable != 13L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long            variable;
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro52()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, no return value and
 * illegal 
 */
{
	static long     i = 0, j = -1, k = 1;

	result = levelOneNodeOne(i - 2 * j + (-k));
	result = levelOneNodeTwo((i + j) * j + k);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long            variable;
{
	if (variable != 1L)
		statusFlag++;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

levelOneNodeTwo(variable)
	long            variable;
{
	long            i = variable + 2;

	if (variable != 2L)
		statusFlag++;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

levelTwoNodeOne(variable)
	long            variable;
{
	long            i = variable * 2;

	if (variable != 3L)
		statusFlag++;
	result = levelThreeLeafOne((i += 8) / 2);
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

levelTwoNodeTwo(variable)
	long            variable;
{
	long            i = variable;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

levelTwoNodeThree(variable)
	long            variable;
{
	long            i = variable--;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

levelTwoNodeFour(variable)
	long            variable;
{
	long            i = variable / 2 - 1;

	if (variable != 6L)
		statusFlag++;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
}

levelThreeLeafOne(variable)
	long            variable;
{
	if (variable != 7L)
		statusFlag++;
	return;
}

levelThreeLeafTwo(variable)
	long            variable;
{
	if (variable != 8L)
		statusFlag++;
	return;
}

levelThreeLeafThree(variable)
	long            variable;
{
	if (variable != 9L)
		statusFlag++;
	return;
}

levelThreeLeafFour(variable)
	long            variable;
{
	if (variable != 10L)
		statusFlag++;
	return;
}

levelThreeLeafFive(variable)
	long            variable;
{
	if (variable != 11L)
		statusFlag++;
	return;
}

levelThreeLeafSix(variable)
	long            variable;
{
	if (variable != 12L)
		statusFlag++;
	return;
}

levelThreeLeafSeven(variable)
	long            variable;
{
	if (variable != 13L)
		statusFlag++;
	return;
}

levelThreeLeafEight(variable)
	long            variable;
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro53()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, Long function declaration 
 */
{
	static long     i = 0, j = -1, k = 1;
	long            result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1L)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long            variable;
{
	long            result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3L)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4L)
		statusFlag++;
	return (variable);
}

long 
levelOneNodeTwo(variable)
	long            variable;
{
	long            i = variable + 2;
	long            result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeOne(variable)
	long            variable;
{
	long            i = variable * 2;
	long            result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeTwo(variable)
	long            variable;
{
	long            i = variable;
	long            result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeThree(variable)
	long            variable;
{
	long            i = variable--;
	long            result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12L)
		statusFlag++;
	return (i);
}

long 
levelTwoNodeFour(variable)
	long            variable;
{
	long            i = variable / 2 - 1;
	long            result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14L)
		statusFlag++;
	return (variable);
}

long 
levelThreeLeafOne(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafTwo(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafThree(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafFour(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafFive(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafSix(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafSeven(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafEight(variable)
	long            variable;
{
	return (variable);
}
@def_
@def $macro54()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value, legal
 * pointer to function returning a long 
 */
{
	static long     i = 3;
	long            divide4(), result = 0, dummy1();

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) ();
long            Long;
{
	long            i = Long--;

	i = (*func) ((-1 + ++i + ++Long) / 2);
	if (i != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) ();
long            Long;
{
	long            i = Long++;

	i = (*func) ((-1 - --i - --Long) / -2);
	if (i != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}
@def_
@def $macro55()
$LICENSE()
$HEAD()

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	static long     i = 1;
	long            levelOneNodeOne();
	long            counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32L)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long            variable;
{
	long            levelTwoNodeOne();

	return (2 * levelTwoNodeOne(2 * variable));
}

long 
levelTwoNodeOne(variable)
	long            variable;
{
	long            levelThreeLeafOne();

	return (2 * levelThreeLeafOne(2 * variable));
}

long 
levelThreeLeafOne(variable)
	long            variable;
{
	return (2 * variable);
}
@def_
@def $macro56()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, in conditional
 * expression, pointer to function returning a long 
 */
{
	static long     i = 2;
	long            divide4(), dummy1();

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) ();
long            Long;
{
	long            i = Long % 3;

	return ((*func) ((Long + i) * (2 + i) / (2 - i)));
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) ();
long            Long;
{
	long            i = Long + 1;

	return ((*func) ((i + ++Long) / 2 - 1));
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}
@def_
@def $macro57()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, no return value, legal 
 */
{
	static long     i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	long            variable, counter;
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro58()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

long            result;
short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, no return value, illegal 
 */
{
	static long     i = 0;
	long            counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	long            variable, counter;
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
}
@def_
@def $macro59()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            recursiveFunction();

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, Long function
 * declaration 
 */
{
	long            i = 0;
	long            result = 0;
	long            counter = TimeLimit;
	long            recursiveFunction();

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable, counter)
	long            variable, counter;
{
	long            result = 0;
	long            storage = variable + 1;
	long            recursiveFunction();

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro60()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, pointer to
 * function returning a long 
 */
{
	static long     i = 0;
	long            increment();
	long            counter = TimeLimit;
	long            dummy();

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable, counter)
	long            (*function) ();
long            variable, counter;
{
	long            result = 0;
	long            storage = variable, dummy();

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2L)
			statusFlag++;
	}
	return (function(storage));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro61()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	long            recursiveFunction();
	static long     i = -1;
	long            counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable, counter)
	long            variable, counter;
{
	long            storage = variable;
	long            recursiveFunction();

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1L)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro62()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * pointer to function returning a long 
 */
{
	long            increment(), dummy();
	static long     i = 2, j = 1;

	if (dummy(increment, (long) (j + i * j >= 10 || i - j > 0)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) ();
long            variable;
{
	long            storage = variable, dummy();

	if (--counter)
		if (dummy(function, (long) ((++variable - 1 == 0) + 1)) != 2L)
			statusFlag++;
	return (function(storage));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro63()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, no return value, legal 
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux((i & i == i) + (j == i), counter);
	}
}

pollux(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor((i & i == i & i) + (j != i), counter);
	}
}
@def_
@def $macro64()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            result;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, no return value, illegal 
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		result = pollux((i & i == i) + (j == i), counter);
}

pollux(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		result = castor((i & i == i & i) + (j != i), counter);
}
@def_
@def $macro65()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;
	long            result = 0, castor();

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;
	long            result = 0, pollux();

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1L)
			statusFlag++;
	}
	return (variable);
}

long 
pollux(variable, counter)
	long            variable, counter;
{
	static long     i = 1, j = 2;
	long            result = 0, castor();

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2L)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro66()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	static long     i = 0;
	long            increment();
	long            castor();

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) ();
long            variable;
{
	long            ii = 0;
	long            pollux();

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) ();
long            variable;
{
	long            iii = 0;
	long            castor();

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro67()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	static long     i = 0;
	long            castor();

	if (castor(++i && ++i ? --i : i + 2) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long            variable;
{
	long            pollux();
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5L)
			statusFlag++;
	}
	return (++variable);
}

long 
pollux(variable)
	long            variable;
{
	long            castor();
	if (--counter) {
		if (castor(2 * variable - 7) != 2L)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro68()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	static long     i = 1;
	long            increment();
	long            castor();

	if (castor(increment, (long) ((i << 1 | i) == i + 2)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) ();
long            variable;
{
	long            pollux();
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) ();
long            variable;
{
	long            castor();
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro69()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, no return value and legal 
 */
{
	levelOneNodeOne((i >> l | j) & k >> l & i);
	levelOneNodeTwo((j >> l | i & k) & l);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long            variable;
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne(i & j & k | l);
	levelTwoNodeTwo(~(j | l) & i >> l);
}

levelOneNodeTwo(variable)
	long            variable;
{
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i >> l | j) ^ l << l);
	levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
}

levelTwoNodeOne(variable)
	long            variable;
{
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i | l) & (k | l));
	levelThreeLeafTwo((i ^ k) & j);
}

levelTwoNodeTwo(variable)
	long            variable;
{
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((k >> l | i << l) & j);
	levelThreeLeafFour(~i & (j | l));
}

levelTwoNodeThree(variable)
	long            variable;
{
	if (variable != 5L)
		statusFlag++;
	levelThreeLeafFive(k >> l | j);
	levelThreeLeafSix((k >> l & (i | l)) << l);
}

levelTwoNodeFour(variable)
	long            variable;
{
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven((i | j) & k);
	levelThreeLeafEight((i ^ k) >> l);
}

levelThreeLeafOne(variable)
	long            variable;
{
	if (variable != 7L)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	long            variable;
{
	if (variable != 8L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long            variable;
{
	if (variable != 9L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long            variable;
{
	if (variable != 10L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long            variable;
{
	if (variable != 11L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long            variable;
{
	if (variable != 12L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long            variable;
{
	if (variable != 13L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long            variable;
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro70()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;
long            result;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, no return value and illegal 
 */
{
	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long            variable;
{
	if (variable != 1L)
		statusFlag++;
	result = levelTwoNodeOne(i & j & k | l);
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	return;
}

levelOneNodeTwo(variable)
	long            variable;
{
	if (variable != 2L)
		statusFlag++;
	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	return;
}

levelTwoNodeOne(variable)
	long            variable;
{
	if (variable != 3L)
		statusFlag++;
	result = levelThreeLeafOne((i | l) & (k | l));
	result = levelThreeLeafTwo((i ^ k) & j);
	return;
}

levelTwoNodeTwo(variable)
	long            variable;
{
	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafThree((k >> l | i << l) & j);
	result = levelThreeLeafFour(~i & (j | l));
	return;
}

levelTwoNodeThree(variable)
	long            variable;
{
	if (variable != 5L)
		statusFlag++;
	result = levelThreeLeafFive(k >> l | j);
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	return;
}

levelTwoNodeFour(variable)
	long            variable;
{
	if (variable != 6L)
		statusFlag++;
	result = levelThreeLeafSeven((i | j) & k);
	result = levelThreeLeafEight((i ^ k) >> l);
	return;
}

levelThreeLeafOne(variable)
	long            variable;
{
	if (variable != 7L)
		statusFlag++;
	return;
}

levelThreeLeafTwo(variable)
	long            variable;
{
	if (variable != 8L)
		statusFlag++;
	return;
}

levelThreeLeafThree(variable)
	long            variable;
{
	if (variable != 9L)
		statusFlag++;
	return;
}

levelThreeLeafFour(variable)
	long            variable;
{
	if (variable != 10L)
		statusFlag++;
	return;
}

levelThreeLeafFive(variable)
	long            variable;
{
	if (variable != 11L)
		statusFlag++;
	return;
}

levelThreeLeafSix(variable)
	long            variable;
{
	if (variable != 12L)
		statusFlag++;
	return;
}

levelThreeLeafSeven(variable)
	long            variable;
{
	if (variable != 13L)
		statusFlag++;
	return;
}

levelThreeLeafEight(variable)
	long            variable;
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro71()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, no function declaration 
 */
{
	long            result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1L)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long            variable;
{
	long            result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3L)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4L)
		statusFlag++;
	return (variable);
}

long 
levelOneNodeTwo(variable)
	long            variable;
{
	long            result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeOne(variable)
	long            variable;
{
	long            result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeTwo(variable)
	long            variable;
{
	long            result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeThree(variable)
	long            variable;
{
	long            result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12L)
		statusFlag++;
	return (variable);
}

long 
levelTwoNodeFour(variable)
	long            variable;
{
	long            result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14L)
		statusFlag++;
	return (variable);
}

long 
levelThreeLeafOne(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafTwo(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafThree(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafFour(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafFive(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafSix(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafSeven(variable)
	long            variable;
{
	return (variable);
}

long 
levelThreeLeafEight(variable)
	long            variable;
{
	return (variable);
}
@def_
@def $macro72()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : linear tree structure, return value, legal pointer to function returning a
 * long 
 */
{
	long            divide4(), result = 0, dummy1();

	result = dummy1(divide4, (k >> l & (i | l)) << l);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	long            result = 0;

	result = (*func) (Long & k);
	if (result != 3L)
		statusFlag++;
	return (result);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	long            result = 0;

	result = (*func) (Long << l >> l);
	if (result != 6L)
		statusFlag++;
	return (result);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}
@def_
@def $macro73()
$LICENSE()
$HEAD()

long            i = 025, j = 011, k = 055;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	long            levelOneNodeOne();
	long            counter = 0;

	while (levelOneNodeOne(i & j & k) != 32L)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long            variable;
{
	long            levelTwoNodeOne();

	return (levelTwoNodeOne(variable << 1) << 1);
}

long 
levelTwoNodeOne(variable)
	long            variable;
{
	long            levelThreeLeafOne();

	return (levelThreeLeafOne(variable << 1) << 1);
}

long 
levelThreeLeafOne(variable)
	long            variable;
{
	return (variable << 1);
}
@def_
@def $macro74()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            divide4(), dummy1();

	if (dummy1(divide4, (k >> l & (i | l)) << l) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	return ((*func) (Long & k));
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	return ((*func) (Long << l >> l));
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}
@def_
@def $macro75()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, no return value, legal 
 */
{
	long            counter = TimeLimit;

	recursiveFunction(i & j & k, counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	long            variable, counter;
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(++variable << l >> l, --counter);
}
@def_
@def $macro76()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;
long            result;

main()
/*
 * test class: bit-wise expression instance  : recursive call, no return value, illegal 
 */
{
	long            counter = TimeLimit;

	result = recursiveFunction(i & j & k, counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	long            variable, counter;
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		result = recursiveFunction(++variable << l >> l, --counter);
	return;
}
@def_
@def $macro77()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return a long 
 */
{
	long            result = 0;
	long            counter = TimeLimit;
	long            recursiveFunction();

	result = recursiveFunction(i & j & k, counter);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable, counter)
	long            variable, counter;
{
	long            result = 0;
	long            storage = variable + 1;
	long            recursiveFunction();

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro78()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            result = 0;
	long            increment();
	long            counter = TimeLimit, dummy();

	result = dummy(increment, i & j & k, counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable, counter)
	long            (*function) (), variable, counter;
{
	long            result = 0;
	long            storage = variable, dummy();

	if (--counter) {
		result = dummy(function, variable << l >> l, counter);
		if (result != 2L)
			statusFlag++;
	}
	return (function(storage));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro79()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, Long function declaration 
 */
{
	long            recursiveFunction();
	long            counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2L != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable, counter)
	long            variable, counter;
{
	long            storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1L)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro80()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, pointer to function returning a
 * long 
 */
{
	long            increment(), dummy();

	if (dummy(increment, i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), variable;
{
	long            storage = variable, dummy();

	if (--counter)
		if (dummy(function, variable << l >> l) != 2L)
			statusFlag++;
	return (function(storage));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro81()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, no return value, legal 
 */
{
	long            counter = TimeLimit;

	castor((i & j & k) << 1, counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	long            variable, counter;
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux(l >> 1, counter);
	}
}

pollux(variable, counter)
	long            variable, counter;
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor(~(i & j & k) & l, counter);
	}
}
@def_
@def $macro82()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;
long            result;

main()
/*
 * test class: bit-wise expression instance  : gemini, no return value, illegal 
 */
{
	long            counter = TimeLimit;

	result = castor((i & j & k) << 1, counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	long            variable, counter;
{
	if (variable != 2L)
		statusFlag++;
	if (--counter)
		result = pollux(l >> 1, counter);
}

pollux(variable, counter)
	long            variable, counter;
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		result = castor(~(i & j & k) & l, counter);
}
@def_
@def $macro83()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	long            counter = TimeLimit;
	long            result = 0, castor();

	result = castor(~(i & j & k) & l, counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable, counter)
	long            variable, counter;
{
	long            result = 0, pollux();

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1L)
			statusFlag++;
	}
	return (variable);
}

long 
pollux(variable, counter)
	long            variable, counter;
{
	long            result = 0;
	long            castor();

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2L)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro84()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            increment();
	long            castor();

	i = castor(increment, i & j & k);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), variable;
{
	long            result = 0;
	long            pollux();

	if (--counter) {
		result = pollux(function, j << l >> l);
		if (result != 10L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), variable;
{
	long            result = 0;
	long            castor();

	if (--counter) {
		result = castor(function, i & j & k);
		if (result != 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro85()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	long            castor();

	if (castor(i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long            variable;
{
	long            pollux();

	if (--counter) {
		if (pollux(i & j << l & k) != 5L)
			statusFlag++;
	}
	return (++variable);
}

long 
pollux(variable)
	long            variable;
{
	long            castor();
	if (--counter) {
		if (castor(i & j & k) != 2L)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro86()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{
	long            increment();
	long            castor();

	if (castor(increment, i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), variable;
{
	long            pollux();
	if (--counter) {
		if (pollux(function, k >> l) != 12L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), variable;
{
	long            castor();
	if (--counter) {
		if (castor(function, i & j & k) != 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro87()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and legal 
 */
{

	levelOneNodeOne(dummy(1L));
	levelOneNodeTwo(dummy(2L));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long            argument;
{
	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(dummy(3L));
	levelTwoNodeTwo(dummy(4L));
}

levelOneNodeTwo(argument)
	long            argument;
{
	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(dummy(5L));
	levelTwoNodeFour(dummy(6L));
}

levelTwoNodeOne(argument)
	long            argument;
{
	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(dummy(7L));
	levelThreeLeafTwo(dummy(8L));
}

levelTwoNodeTwo(argument)
	long            argument;
{
	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(dummy(9L));
	levelThreeLeafFour(dummy(10L));
}

levelTwoNodeThree(argument)
	long            argument;
{
	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(dummy(11L));
	levelThreeLeafSix(dummy(12L));
}

levelTwoNodeFour(argument)
	long            argument;
{
	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(dummy(13L));
	levelThreeLeafEight(dummy(14L));
}

levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
}

levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
}

levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
}

levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
}

levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
}

levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
}

levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
}

levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
}

long 
dummy(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro88()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	long            i = 0;

	i = levelOneNodeOne(dummy(1L));
	i = levelOneNodeTwo(dummy(2L));
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long            argument;
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3L));
	i = levelTwoNodeTwo(dummy(4L));
	if (i == 0L)
		i++;
}

levelOneNodeTwo(argument)
	long            argument;
{
	long            i;

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5L));
	i = levelTwoNodeFour(dummy(6L));
	if (i == 0L)
		i++;
}

levelTwoNodeOne(argument)
	long            argument;
{
	long            i;

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7L));
	i = levelThreeLeafTwo(dummy(8L));
	if (i == 0L)
		i++;
}

levelTwoNodeTwo(argument)
	long            argument;
{
	long            i;

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9L));
	i = levelThreeLeafFour(dummy(10L));
	if (i == 0L)
		i++;
}

levelTwoNodeThree(argument)
	long            argument;
{
	long            i;

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11L));
	i = levelThreeLeafSix(dummy(12L));
	if (i == 0L)
		i++;
}

levelTwoNodeFour(argument)
	long            argument;
{
	long            i;

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13L));
	i = levelThreeLeafEight(dummy(14L));
	if (i == 0L)
		i++;
}

levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
}

levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
}

levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
}

levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
}

levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
}

levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
}

levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
}

levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
}

long 
dummy(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro89()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long      dummy();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, Long function declaration 
 */
{
	long            i = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(dummy(1L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2L));
	if (i == 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(argument)
	long            argument;
{
	long            i = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelOneNodeTwo(argument)
	long            argument;
{
	long            i = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeOne(argument)
	long            argument;
{
	long            i = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeTwo(argument)
	long            argument;
{
	long            i = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeThree(argument)
	long            argument;
{
	long            i = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeFour(argument)
	long            argument;
{
	long            i = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14L));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
	return (argument);
}

long 
dummy(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro90()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long         twelve();

main()
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning a
 * long 
 */
{
	long            i, divide4(), dummy1();

	i = dummy1(divide4, twelve());
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	long            i = Long;

	i = (*func) (twelve());
	if (i != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	long            i = Long;

	i = (*func) (twelve());
	if (i != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}

long 
twelve()
{
	return (12);
}
@def_
@def $macro91()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            object = 1;
long            mirror();

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	long            levelOneNodeOne();

	if (levelOneNodeOne(mirror(object)) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(argument)
	long            argument;
{
	long            object = argument + 2;
	long            levelTwoNodeOne();

	if (levelTwoNodeOne(mirror(object)) != 3L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeOne(argument)
	long            argument;
{
	long            object = argument + 4;
	long            levelThreeLeafOne();

	if (levelThreeLeafOne(mirror(object)) != 7L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
	return (argument);
}

long 
mirror(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro92()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            twelve();

main()
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            divide4(), dummy1();

	if (dummy1(divide4, twelve()) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	long            i = Long;

	if ((i = (*func) (twelve())) != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	long            i = Long;

	if ((i = (*func) (twelve())) != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}

long 
twelve()
{
	return (12);
}
@def_
@def $macro93()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            un();
int recursiveFunction();


main()
/*
 * test class: function as argument instance  : recursive call, no return value, legal 
 */
{
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	if (argument != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(un());
}

long 
un()
{
	static long     un = 1;
	return (un);
}
@def_
@def $macro94()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            result;
long            un();

main()
/*
 * test class: function as argument instance  : recursive call, no return value, illegal 
 */
{
	result = recursiveFunction(un());
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		result = recursiveFunction(un());
	return;
}

long 
un()
{
	static long     un = 1;
	return (un);
}
@def_
@def $macro95()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long un();

main()
/*
 * test class: function as argument instance  : recursive call, return value, legal, Long function declaration 
 */
{
	long            i = 0;
	long            recursiveFunction();

	i = recursiveFunction(un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(argument)
	long            argument;
{
	long            i;
	long            recursiveFunction();

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2L)
			statusFlag++;
	}
	return (++argument);
}

long 
un()
{
	static long     un = 1;
	return (un);
}
@def_
@def $macro96()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long un();

main()
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            i, increment(), dummy();

	i = dummy(increment, un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, argument)
	long            (*function) (), argument;
{
	long            i, dummy();
	if (--counter) {
		i = dummy(function, un());
		if (i != 2L)
			statusFlag++;
	}
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
un()
{
	long            un = 1;
	return (un);
}
@def_
@def $macro97()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long un();

main()
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{
	long            recursiveFunction();

	if (!(recursiveFunction(un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(argument)
	long            argument;
{
	long            recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(un()) == 2L))
			statusFlag++;
	return (++argument);
}

long 
un()
{
	static long     un = 1;
	return (un);
}
@def_
@def $macro98()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long un();

main()
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning a
 * long 
 */
{
	long            increment(), dummy();

	if (!(dummy(increment, un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, argument)
	long            (*function) (), argument;
{
	long            dummy();
	if (--counter)
		if (!(dummy(function, un()) == 2L))
			statusFlag++;
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
un()
{
	static long     un = 1;
	return (un);
}
@def_
@def $macro99()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, no return value, legal 
 */
{
	long            un();

	castor(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	long            argument;
{
	long            deux();

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		pollux(deux());
}

pollux(argument)
	long            argument;
{
	long            un();

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		castor(un());
}

long 
un()
{
	long            un = 1;
	return (un);
}

long 
deux()
{
	long            deux = 2;
	return (deux);
}
@def_
@def $macro100()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            result;

main()
/*
 * test class: function as argument instance  : gemini, no return value, illegal 
 */
{
	long            un();

	result = castor(un());
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	long            argument;
{
	long            deux();

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		result = pollux(deux());
}

pollux(argument)
	long            argument;
{
	long            un();

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		result = castor(un());
}

long 
un()
{
	long            un = 1;
	return (un);
}

long 
deux()
{
	long            deux = 2;
	return (deux);
}
@def_
@def $macro101()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            i = 0, castor(), rebound();

	i = castor(rebound(1L));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(argument)
	long            argument;
{
	long            i, pollux(), rebound();

	if (--counter) {
		i = pollux(rebound(4L));
		if (i != 5L)
			statusFlag++;
	}
	return (++argument);
}

long 
pollux(argument)
	long            argument;
{
	long            i, rebound(), castor();

	if (--counter) {
		i = castor(rebound(1L));
		if (i != 2L)
			statusFlag++;
	}
	return (++argument);
}

long 
rebound(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro102()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i, increment(), un();
	long            castor();

	i = castor(increment, un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, argument)
	long            (*function) (), argument;
{
	long            i, neuf(), pollux();
	if (--counter) {
		i = pollux(function, neuf());
		if (i != 10L)
			statusFlag++;
	}
	return (function(argument));
}

long 
pollux(function, argument)
	long            (*function) (), argument;
{
	long            i, trois(), castor();
	if (--counter) {
		i = castor(function, trois());
		if (i != 4L)
			statusFlag++;
	}
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
un()
{
	return (Un);
}

long 
trois()
{
	return (Trois);
}

long 
neuf()
{
	return (Neuf);
}
@def_
@def $macro103()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	long            castor(), numero();

	if (!(castor(numero((long) Un)) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(argument)
	long            argument;
{
	long            pollux(), numero();

	if (--counter)
		if (!(pollux(numero((long) Quatre)) == 5L))
			statusFlag++;
	return (++argument);
}

long 
pollux(argument)
	long            argument;
{
	long            castor(), numero();

	if (--counter)
		if (!(castor(numero((long) Un)) == 2L))
			statusFlag++;
	return (++argument);
}

long 
numero(questCa)
	long            questCa;
{
	return (questCa);
}
@def_
@def $macro104()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{
	long            increment(), un(), castor();

	if (!(castor(increment, un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, argument)
	long            (*function) (), argument;
{
	long            neuf(), pollux();

	if (--counter)
		if (!(pollux(function, neuf()) == 10L))
			statusFlag++;
	return (function(argument));
}

long 
pollux(function, argument)
	long            (*function) (), argument;
{
	long            trois(), castor();

	if (--counter)
		if (!(castor(function, trois()) == 4L))
			statusFlag++;
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
un()
{
	static long     un = 1;
	return (un);
}

long 
trois()
{
	static long     trois = 3;
	return (trois);
}

long 
neuf()
{
	static long     neuf = 9;
	return (neuf);
}
@def_
@def $macro105()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: function as argument, variable order not determined instance  : recursive call, no return value, legal 
 */
{
	long            i = 0, a, b, c, indeterminacy();

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(indeterminacy(a, b, c));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	long            i = 0, a, b, c, indeterminacy();

	if (argument != -3L)
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(indeterminacy(a, b, c));
	}
}

long 
indeterminacy(uno, dos, tres)
	long            uno, dos, tres;
{
	return (uno + dos + tres);
}
@def_
@def $macro106()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and legal 
 */
{
	long            uno();
	long            dos();
	long            tres();
	levelOneNodeOne(uno(dos(tres(1L))));
	levelOneNodeTwo(uno(dos(tres(2L))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(uno(dos(tres(3L))));
	levelTwoNodeTwo(uno(dos(tres(4L))));
}

levelOneNodeTwo(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(uno(dos(tres(5L))));
	levelTwoNodeFour(uno(dos(tres(6L))));
}

levelTwoNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(uno(dos(tres(7L))));
	levelThreeLeafTwo(uno(dos(tres(8L))));
}

levelTwoNodeTwo(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(uno(dos(tres(9L))));
	levelThreeLeafFour(uno(dos(tres(10L))));
}

levelTwoNodeThree(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(uno(dos(tres(11L))));
	levelThreeLeafSix(uno(dos(tres(12L))));
}

levelTwoNodeFour(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(uno(dos(tres(13L))));
	levelThreeLeafEight(uno(dos(tres(14L))));
}

levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
}

levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
}

levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
}

levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
}

levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
}

levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
}

levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
}

levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro107()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            uno();
long            dos();
long            tres();

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	long            i = 0;

	i = levelOneNodeOne(uno(dos(tres(1L))));
	i = levelOneNodeTwo(uno(dos(tres(2L))));
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i;

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3L))));
	i = levelTwoNodeTwo(uno(dos(tres(4L))));
	if (i == 0L)
		i++;
}

levelOneNodeTwo(argument)
	long            argument;
{
	long            i;

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5L))));
	i = levelTwoNodeFour(uno(dos(tres(6L))));
	if (i == 0L)
		i++;
}

levelTwoNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i;

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7L))));
	i = levelThreeLeafTwo(uno(dos(tres(8L))));
	if (i == 0L)
		i++;
}

levelTwoNodeTwo(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i;

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9L))));
	i = levelThreeLeafFour(uno(dos(tres(10L))));
	if (i == 0L)
		i++;
}

levelTwoNodeThree(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i;

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11L))));
	i = levelThreeLeafSix(uno(dos(tres(12L))));
	if (i == 0L)
		i++;
}

levelTwoNodeFour(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i;

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13L))));
	i = levelThreeLeafEight(uno(dos(tres(14L))));
	if (i == 0L)
		i++;
}

levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
}

levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
}

levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
}

levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
}

levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
}

levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
}

levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
}

levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro108()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, Long function
 * declaration 
 */
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(uno(dos(tres(1L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2L))));
	if (i == 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelOneNodeTwo(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeTwo(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeThree(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeFour(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            i = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14L))));
	if (i == 0L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafTwo(argument)
	long            argument;
{
	if (argument != 8L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafThree(argument)
	long            argument;
{
	if (argument != 9L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafFour(argument)
	long            argument;
{
	if (argument != 10L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafFive(argument)
	long            argument;
{
	if (argument != 11L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafSix(argument)
	long            argument;
{
	if (argument != 12L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafSeven(argument)
	long            argument;
{
	if (argument != 13L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafEight(argument)
	long            argument;
{
	if (argument != 14L)
		statusFlag++;
	return (argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro109()
$LICENSE()
$HEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;
long            half();
long            twoTimes();

main()
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning a long 
 */
{
	long            twentyFour();

	long            i, divide4(), dummy1();

	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	long            half();
	long            twoTimes();
	long            i = Long;

	i = (*func) (half(twoTimes(i)));
	if (i != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	long            i = Long;

	i = (*func) (twoTimes(half(i)));
	if (i != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}

long 
twentyFour()
{
	return (TwoDozen);
}

long 
twoTimes(argument)
	long            argument;
{
	return (2 * argument);
}

long 
half(argument)
	long            argument;
{
	return (argument / 2);
}
@def_
@def $macro110()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            object = 1;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	long            uno();
	long            dos();
	long            tres();
	long            levelOneNodeOne();

	if (levelOneNodeOne(uno(dos(tres(object)))) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            object = argument + 2;
	long            levelTwoNodeOne();

	if (levelTwoNodeOne(uno(dos(tres(object)))) != 3L)
		statusFlag++;
	return (argument);
}

long 
levelTwoNodeOne(argument)
	long            argument;
{
	long            uno();
	long            dos();
	long            tres();
	long            object = argument + 4;
	long            levelThreeLeafOne();

	if (levelThreeLeafOne(uno(dos(tres(object)))) != 7L)
		statusFlag++;
	return (argument);
}

long 
levelThreeLeafOne(argument)
	long            argument;
{
	if (argument != 7L)
		statusFlag++;
	return (argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro111()
$LICENSE()
$HEAD()

#define TwoDouzen 24L
short           statusFlag = NoMistake;
long            half();
long            twoTimes();

main()
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            divide4();
	long            divide4(), dummy1();

	if (dummy1(divide4, half(twoTimes(half(TwoDouzen)))) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), Long;
{
	long            half();
	long            twoTimes();
	long            i;

	if ((i = (*func) (twoTimes(half(Long)))) != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long            Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), Long;
{
	long            i;

	if ((i = (*func) (twoTimes(half(Long)))) != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long            Long;
{
	return (Long / 2);
}

long 
twoTimes(argument)
	long            argument;
{
	return (2 * argument);
}

long 
half(argument)
	long            argument;
{
	return (argument / 2);
}
@def_
@def $macro112()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, no return value, legal 
 */
{
	long            dos(), tres(), uno();
	recursiveFunction(uno(dos(tres(Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	long            dos(), tres(), uno();

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(uno(dos(tres(Un))));
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro113()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, no return value, illegal 
 */
{
	long            uno(), dos(), tres();
	long            i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 1L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	long            uno(), dos(), tres();
	long            i;

	if (argument != 1L)
		statusFlag++;
	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 1L)
			i++;
	}
	return;
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro114()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, Long function declaration 
 */
{
	long            uno(), dos(), tres();
	long            i, recursiveFunction();

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(argument)
	long            argument;
{
	long            uno(), dos(), tres();
	long            i, recursiveFunction();

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2L)
			statusFlag++;
	}
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro115()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            uno(), dos(), tres();
	long            i, increment(), dummy();

	i = dummy(increment, uno(dos(tres(Un))));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, argument)
	long            (*function) (), argument;
{
	long            uno(), dos(), tres();
	long            i, dummy();
	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if (i != 2L)
			statusFlag++;
	}
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro116()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{
	long            uno(), dos(), tres();
	long            recursiveFunction();

	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(argument)
	long            argument;
{
	long            uno(), dos(), tres();
	long            recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2L))
			statusFlag++;
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro117()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            increment(), uno(), dos(), tres(), dummy();

	if (!(dummy(increment, uno(dos(tres((long) Un)))) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, argument)
	long            (*function) (), argument;
{
	long            uno(), dos(), tres(), dummy();

	if (--counter)
		if (!(dummy(function, uno(dos(tres((long) Un)))) == 2L))
			statusFlag++;
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro118()
$LICENSE()
$HEAD()

#define Un   1
#define Deux 2
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, no return value, legal 
 */
{
	long            uno(), dos(), tres();

	castor(uno(dos(tres((long) Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	long            argument;
{
	long            uno(), dos(), tres();

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		pollux(uno(dos(tres((long) Deux))));
}

pollux(argument)
	long            argument;
{
	long            uno(), dos(), tres();

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		castor(uno(dos(tres((long) Un))));
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro119()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
long            counter = 10;
long            i, uno(), dos(), tres();

main()
/*
 * test class: nested function as argument instance  : gemini, no return value, illegal 
 */
{
	i = castor(uno(dos(tres())));
	if (i != 1L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	long            argument;
{
	if (argument != Un)
		statusFlag++;
	if (--counter) {
		i = pollux(uno(dos(tres())));
		if (i != 0L)
			i++;
	}
}

pollux(argument)
	long            argument;
{
	long            i;

	if (argument != Un)
		statusFlag++;
	if (--counter) {
		i = castor(uno(dos(tres())));
		if (i != 0L)
			i++;
	}
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres()
{
	return (Un);
}
@def_
@def $macro120()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            i, castor(), uno(), dos(), tres();

	i = castor(uno(dos(tres((long) Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(argument)
	long            argument;
{
	long            i, pollux(), uno(), dos(), tres();

	if (--counter) {
		i = pollux(uno(dos(tres((long) Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return (++argument);
}

long 
pollux(argument)
	long            argument;
{
	long            i, uno(), dos(), tres();

	if (--counter) {
		i = castor(uno(dos(tres((long) Un))));
		if (i != Deux)
			statusFlag++;
	}
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro121()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i, increment(), uno(), dos(), tres(), castor();

	i = castor(increment, uno(dos(tres((long) Un))));
	if (i != Un + 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, argument)
	long            (*function) (), argument;
{
	long            i, uno(), dos(), tres(), pollux();

	if (--counter) {
		i = pollux(function, uno(dos(tres((long) Neuf))));
		if (i != Neuf + 1L)
			statusFlag++;
	}
	return (function(argument));
}

long 
pollux(function, argument)
	long            (*function) (), argument;
{
	long            i, uno(), dos(), tres(), castor();

	if (--counter) {
		i = castor(function, uno(dos(tres((long) Trois))));
		if (i != Trois + 1L)
			statusFlag++;
	}
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro122()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	long            castor(), uno(), dos(), tres();

	if (!(castor(uno(dos(tres((long) Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(argument)
	long            argument;
{
	long            pollux(), uno(), dos(), tres();

	if (--counter)
		if (!(pollux(uno(dos(tres((long) Quatre)))) == Cinq))
			statusFlag++;
	return (++argument);
}

long 
pollux(argument)
	long            argument;
{
	long            uno(), dos(), tres(), castor();

	if (--counter)
		if (!(castor(uno(dos(tres((long) Un)))) == Deux))
			statusFlag++;
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro123()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning a
 * long 
 */
{
	long            increment();
	long            uno(), dos(), tres(), castor();


	if (!(castor(increment, uno(dos(tres((long) Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, argument)
	long            (*function) (), argument;
{
	long            uno(), dos(), tres(), pollux();

	if (--counter)
		if (!(pollux(function, uno(dos(tres((long) Neuf)))) == Dix))
			statusFlag++;
	return (function(argument));
}

long 
pollux(function, argument)
	long            (*function) (), argument;
{
	long            uno(), dos(), tres(), castor();

	if (--counter)
		if (!(castor(function, uno(dos(tres((long) Trois)))) == Quatre))
			statusFlag++;
	return (function(argument));
}

long 
increment(argument)
	long            argument;
{
	return (++argument);
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(argument)
	long            argument;
{
	return (argument);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro124()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: nested function as argument, random order instance  : recursive call, no return value, legal 
 */
{
	long            i = 0, a, b, c, uno(), dos(), tres();

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	long            argument;
{
	long            i = 0, a, b, c, uno(), dos(), tres();

	if (argument != -3L)
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	}
}

long 
uno(argument)
	long            argument;
{
	return (argument);
}

long 
dos(uno, dos, tres)
	long            uno, dos, tres;
{
	return (uno + dos + tres);
}

long 
tres(argument)
	long            argument;
{
	return (argument);
}
@def_
@def $macro125()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	unsigned        i = 0;
	short           j = -1;
	unsigned        k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j - k);
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	unsigned        variable;
{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return (variable);
}

levelOneNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return (variable);
}

levelTwoNodeOne(variable)
	unsigned        variable;
{
	unsigned        i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return (variable);
}

levelTwoNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return (variable);
}

levelTwoNodeThree(variable)
	unsigned        variable;
{
	unsigned        i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return (i);
}

levelTwoNodeFour(variable)
	unsigned        variable;
{
	unsigned        i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return (variable);
}

levelThreeLeafOne(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafTwo(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafThree(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafFour(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafFive(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafSix(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafSeven(variable)
	unsigned        variable;
{
	return (variable);
}

levelThreeLeafEight(variable)
	unsigned        variable;
{
	return (variable);
}
@def_
@def $macro126()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	unsigned        i = 0;
	short           j = -1;
	unsigned        k = 1;
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(i - 2 * j - k);
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	unsigned        variable;
{
	short           result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return (variable);
}

short 
levelOneNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable + 2;
	short           result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeOne(variable)
	unsigned        variable;
{
	unsigned        i = variable * 2;
	short           result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeTwo(variable)
	unsigned        variable;
{
	unsigned        i = variable;
	short           result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeThree(variable)
	unsigned        variable;
{
	unsigned        i = variable--;
	short           result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return (i);
}

short 
levelTwoNodeFour(variable)
	unsigned        variable;
{
	unsigned        i = variable / 2 - 1;
	short           result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return (variable);
}

short 
levelThreeLeafOne(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafTwo(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafThree(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafFour(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafFive(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafSix(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafSeven(variable)
	unsigned        variable;
{
	return (variable);
}

short 
levelThreeLeafEight(variable)
	unsigned        variable;
{
	return (variable);
}
@def_
@def $macro127()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	unsigned        i = 0, j = 1;
	static char    *numbers = "01234567890123456789";

	s = levelOne(j, &(numbers[j * (i + 1) * (i + 2) * (i + 3) + 4 * j]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable, numbers)
	unsigned        variable;
	char           *numbers;
{
	char           *s, *levelTwo();
	unsigned        j = variable + 1;

	s = levelTwo(j, numbers - j * j * j - 2);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return (s);
}

char           *
levelTwo(variable, numbers)
	unsigned        variable;
	char           *numbers;
{
	char           *s, *levelThree();
	unsigned        k = variable + 1;

	s = levelThree(k, numbers + k * k + variable - 1);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return (s);
}

char           *
levelThree(variable, numbers)
	unsigned        variable;
	char           *numbers;
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return (s);
}
@def_
@def $macro128()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	unsigned        i = 3;
	unsigned        divide4();
	short           result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	unsigned        (*func) (), integer;
{
	unsigned        i = integer--;

	i = (*func) ((-1 + ++i + ++integer) / 2);
	if (i != 3)
		statusFlag++;
	return (i);
}

unsigned 
divide4(integer)
	unsigned        integer;
{
	unsigned        divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	unsigned        (*func) (), integer;
{
	unsigned        i = integer++;

	i = (*func) ((1 + --i + --integer) / 2);
	if (i != 6)
		statusFlag++;
	return (i);
}

unsigned 
divide2(integer)
	unsigned        integer;
{
	return (integer / 2);
}
@def_
@def $macro129()
$LICENSE()
$HEAD()

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	unsigned        i = 1;
	char            levelOneNodeOne();
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return (0);
}

char 
levelOneNodeOne(variable)
	unsigned        variable;
{
	char            levelTwoNodeOne();

	return (2 * levelTwoNodeOne(2 * variable));
}

char 
levelTwoNodeOne(variable)
	unsigned        variable;
{
	char            levelThreeLeafOne();

	return (2 * levelThreeLeafOne(2 * variable));
}

char 
levelThreeLeafOne(variable)
	unsigned        variable;
{
	return (2 * variable);
}
@def_
@def $macro130()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	char            i = 2, j = i;
	char           *skip();

	if (compare(skip(2 * i), &(protean[i * i]), 5)
	    == compare(skip(4 * j), &(protean[j * j * j]), 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char            skipper;
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro131()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	char            i = 2, divide4();

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	char            (*func) (), integer;
{
	short           i = integer % 3;

	return ((*func) ((integer + i) * (2 + i) / (2 - i)));
}

char 
divide4(integer)
	char            integer;
{
	unsigned        divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	unsigned        (*func) ();
char            integer;
{
	short           i = integer + 1;

	return ((*func) ((i + ++integer) / 2 - 1));
}

unsigned 
divide2(integer)
	char            integer;
{
	return (integer / 2);
}
@def_
@def $macro132()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, no return value, legal 
 */
{
	char            i = 0;
	short           counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	char            variable;
	short           counter;
{
	if (variable + counter != 11)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro133()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, no function
 * declaration 
 */
{
	char            i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	char            variable;
	short           counter;
{
	short           result = 0;
	char            storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro134()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           recursiveFunction();

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, integer function
 * declaration 
 */
{
	unsigned        i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable, counter)
	unsigned        variable;
	short           counter;
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro135()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	char            i = 4;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(i + i / i * i - 6, &(numbers[i * i - i - i / 2]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable, numbers, counter)
	char            variable;
	char           *numbers;
	short           counter;
{
	char           *s;
	unsigned        storage = (unsigned) variable;

	if (--counter) {
		s = recursiveFunction((char) ((storage + ++variable + 1) / 2 - 1),
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + storage);
}
@def_
@def $macro136()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	char            i = 0;
	unsigned        increment();
	short           counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable, counter)
	unsigned        (*function) ();
char            variable;
short           counter;
{
	short           result = 0;
	char            storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2)
			statusFlag++;
	}
	return (function(storage));
}

unsigned 
increment(variable)
	char            variable;
{
	return (++variable);
}
@def_
@def $macro137()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	char            i = 1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 + i) / 2, counter) - i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	char            variable;
	short           counter;
{
	char            storage = variable;

	if (--counter)
		if (recursiveFunction((short) (storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro138()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	char           *recursiveFunction();
	char            i = 1, j = 3;

	if (*recursiveFunction((i == j + 1) * i + j) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	char            variable;
{
	char            storage = variable;

	if (--counter)
		if (*recursiveFunction(++variable * 3 - storage * storage) != '3')
			statusFlag++;
	return (numbers + storage);
}
@def_
@def $macro139()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	short           increment();
	char            i = 2, j = 1;

	if (dummy(increment, (unsigned) (j + i * j >= 10 || i - j > 0)) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) ();
unsigned        variable;
{
	unsigned        storage = variable;

	if (--counter)
		if (dummy(function, (unsigned) ((++variable - 1 == 0) + 1)) != 2)
			statusFlag++;
	return (function(storage));
}

short 
increment(variable)
	unsigned        variable;
{
	return (++variable);
}
@def_
@def $macro140()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, no return value, legal 
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	char            variable;
	short           counter;
{
	char            i = 1, j = 2;

	if (variable != 2)
		statusFlag++;
	if (--counter) {
		pollux((i & i == i) + (j == i), counter);
	}
}

pollux(variable, counter)
	char            variable;
	short           counter;
{
	char            i = 1, j = 2;

	if (variable != 1)
		statusFlag++;
	if (--counter) {
		castor((i & i == i & i) + (j != i), counter);
	}
}
@def_
@def $macro141()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	char            variable;
	short           counter;
{
	unsigned        i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

pollux(variable, counter)
	unsigned        variable;
	short           counter;
{
	char            i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro142()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0, castor();

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable, counter)
	char            variable;
	short           counter;
{
	unsigned        i = 1, j = 2;
	short           result = 0, pollux();

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

short 
pollux(variable, counter)
	unsigned        variable;
	short           counter;
{
	char            i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro143()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s, *castor();
	unsigned short  i = 1, j = 2, k = 3;

	s = castor((unsigned short) (++i == j && ++j == k) * 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	unsigned short  variable;
{
	char           *s, *pollux();
	unsigned short  i = 4;

	if (--counter) {
		s = pollux(i / variable + i);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	unsigned short  variable;
{
	char           *s;
	static unsigned short i = 4;

	if (--counter) {
		s = castor(i * 3 / variable);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro144()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	unsigned        i = 0;
	short           increment();

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) ();
unsigned        variable;
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) ();
unsigned        variable;
{
	short           iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	unsigned        variable;
{
	return (++variable);
}
@def_
@def $macro145()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	char            i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	char            variable;
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return (++variable);
}

pollux(variable)
	char            variable;
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro146()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	unsigned short  i = 0;
	short           castor();

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	unsigned short  variable;
{
	short           pollux();
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return (++variable);
}

short 
pollux(variable)
	unsigned short  variable;
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro147()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *castor();
	char            i = 1, j = 2;

	if (*castor((i << 1 == j) * 2) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	char            variable;
{
	char           *pollux();
	if (--counter) {
		if (*pollux(variable << 1 | variable) != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	char            variable;
{
	if (--counter) {
		if (*castor(variable >> 1 & variable) != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro148()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	static char     i = 1;
	short           increment();

	if (castor(increment, (i << 1 | i) == i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) ();
register char   variable;
{
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) ();
register char   variable;
{
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	char            variable;
{
	return (++variable);
}
@def_
@def $macro149()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	static short    i = 0, j = -1, k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	register short  variable;
{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return (variable);
}

levelOneNodeTwo(variable)
	register short  variable;
{
	short           i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return (variable);
}

levelTwoNodeOne(variable)
	register short  variable;
{
	short           i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return (variable);
}

levelTwoNodeTwo(variable)
	register short  variable;
{
	short           i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return (variable);
}

levelTwoNodeThree(variable)
	register short  variable;
{
	short           i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return (i);
}

levelTwoNodeFour(variable)
	register short  variable;
{
	short           i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return (variable);
}

levelThreeLeafOne(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafTwo(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafThree(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafFour(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafFive(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafSix(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafSeven(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafEight(variable)
	short           variable;
{
	return (variable);
}
@def_
@def $macro150()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	static short    i = 0, j = -1, k = 1;
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	register short  variable;
{
	short           result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return (variable);
}

short 
levelOneNodeTwo(variable)
	register short  variable;
{
	register short  i = variable + 2;
	short           result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeOne(variable)
	register short  variable;
{
	register short  i = variable * 2;
	short           result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeTwo(variable)
	register short  variable;
{
	register short  i = variable;
	short           result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeThree(variable)
	register short  variable;
{
	register short  i = variable--;
	short           result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return (i);
}

short 
levelTwoNodeFour(variable)
	register short  variable;
{
	register short  i = variable / 2 - 1;
	short           result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return (variable);
}

short 
levelThreeLeafOne(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafTwo(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafThree(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafFour(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafFive(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafSix(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafSeven(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafEight(variable)
	short           variable;
{
	return (variable);
}
@def_
@def $macro151()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	static short    i = 0, j = 1;
	static char    *numbers = "01234567890123456789";

	s = levelOne(j, &(numbers[j * (i + 1) * (i + 2) * (i + 3) + 4 * j]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable, numbers)
	register short  variable;
	char           *numbers;
{
	char           *s, *levelTwo();
	register short  j = variable + 1;

	s = levelTwo(j, numbers - j * j * j - 2);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return (s);
}

char           *
levelTwo(variable, numbers)
	register short  variable;
	char           *numbers;
{
	char           *s, *levelThree();
	register short  k = variable + 1;

	s = levelThree(k, numbers + k * k + variable - 1);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return (s);
}

char           *
levelThree(variable, numbers)
	register short  variable;
	char           *numbers;
{
	char           *s;
	register short  l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return (s);
}
@def_
@def $macro152()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	static short    i = 3;
	short           divide4(), result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) ();
register short  integer;
{
	register short  i = integer--;

	i = (*func) ((-1 + ++i + ++integer) / 2);
	if (i != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	register short  integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) ();
register short  integer;
{
	register short  i = integer++;

	i = (*func) ((-1 - --i - --integer) / -2);
	if (i != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	register short  integer;
{
	return (integer / 2);
}
@def_
@def $macro153()
$LICENSE()
$HEAD()

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	static short    i = 1;
	short           levelOneNodeOne();
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	register short  variable;
{
	short           levelTwoNodeOne();

	return (2 * levelTwoNodeOne(2 * variable));
}

short 
levelTwoNodeOne(variable)
	register short  variable;
{
	short           levelThreeLeafOne();

	return (2 * levelThreeLeafOne(2 * variable));
}

short 
levelThreeLeafOne(variable)
	register short  variable;
{
	return (2 * variable);
}
@def_
@def $macro154()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	static short    i = 2, j = 2;
	char           *skip();

	if (compare(skip(2 * i), &(protean[i * i]), 5)
	    == compare(skip(4 * j), &(protean[j * j * j]), 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	register short  skipper;
{
	register short  i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	register short  n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro155()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	static short    i = 2;
	short           divide4();

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) ();
register short  integer;
{
	register short  i = integer % 3;

	return ((*func) ((integer + i) * (2 + i) / (2 - i)));
}

short 
divide4(integer)
	register short  integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) ();
register short  integer;
{
	short           i = integer + 1;

	return ((*func) ((i + ++integer) / 2 - 1));
}

short 
divide2(integer)
	register short  integer;
{
	return (integer / 2);
}
@def_
@def $macro156()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           recursiveFunction();

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, integer function
 * declaration 
 */
{
	register short  i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable, counter)
	register short  variable, counter;
{
	short           result = 0;
	register short  storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro157()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	static short    i = 4;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(i + i / i * i - 6, &(numbers[i * i - i - i / 2]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable, numbers, counter)
	register short  variable;
	char           *numbers;
	short           counter;
{
	char           *s;
	register short  storage = variable;

	if (--counter) {
		s = recursiveFunction((storage + ++variable + 1) / 2 - 1,
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + storage);
}
@def_
@def $macro158()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	static short    i = 0;
	short           increment();
	short           counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable, counter)
	short           (*function) ();
register short  variable, counter;
{
	short           result = 0;
	register short  storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2)
			statusFlag++;
	}
	return (function(storage));
}

short 
increment(variable)
	register short  variable;
{
	return (++variable);
}
@def_
@def $macro159()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	static short    i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	register short  variable, counter;
{
	register short  storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro160()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, integer function declaration 
 */
{
	short           recursiveFunction();
	static short    i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable, counter)
	register short  variable, counter;
{
	register short  storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro161()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	char           *recursiveFunction();
	static short    i = 1, j = 3;

	if (*recursiveFunction((i == j + 1) * i + j) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	register short  variable;
{
	register short  storage = variable;

	if (--counter)
		if (*recursiveFunction(++variable * 3 - storage * storage) != '3')
			statusFlag++;
	return (numbers + storage);
}
@def_
@def $macro162()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	short           increment();
	static short    i = 2, j = 1;

	if (dummy(increment, j + i * j >= 10 || i - j > 0) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) ();
register short  variable;
{
	register short  storage = variable;

	if (--counter)
		if (dummy(function, (++variable - 1 == 0) + 1) != 2)
			statusFlag++;
	return (function(storage));
}

short 
increment(variable)
	register short  variable;
{
	return (++variable);
}
@def_
@def $macro163()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static short    i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	register short  variable, counter;
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

pollux(variable, counter)
	register short  variable, counter;
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro164()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static short    i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0, castor();

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable, counter)
	register short  variable, counter;
{
	static short    i = 1, j = 2;
	short           result = 0, pollux();

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

short 
pollux(variable, counter)
	register short  variable, counter;
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro165()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s, *castor();
	static short    i = 1, j = 2, k = 3;

	s = castor((++i == j && ++j == k) * 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	register short  variable;
{
	char           *s, *pollux();
	static short    i = 4;

	if (--counter) {
		s = pollux(i / variable + i);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	register short  variable;
{
	char           *s;
	static short    i = 4;

	if (--counter) {
		s = castor(i * 3 / variable);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro166()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	static short    i = 0;
	short           increment();

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) ();
register short  variable;
{
	register short  ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) ();
register short  variable;
{
	register short  iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	register short  variable;
{
	return (++variable);
}
@def_
@def $macro167()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	static short    i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	register short  variable;
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return (++variable);
}

pollux(variable)
	register short  variable;
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro168()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	static short    i = 0;
	short           castor();

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	register short  variable;
{
	short           pollux();
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return (++variable);
}

short 
pollux(variable)
	register short  variable;
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro169()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *castor();
	static short    i = 1, j = 2;

	if (*castor((i << 1 == j) * 2) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	register short  variable;
{
	char           *pollux();
	if (--counter) {
		if (*pollux(variable << 1 | variable) != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	register short  variable;
{
	if (--counter) {
		if (*castor(variable >> 1 & variable) != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro170()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	static short    i = 1;
	short           increment();

	if (castor(increment, (i << 1 | i) == i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) ();
register short  variable;
{
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) ();
register short  variable;
{
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	register short  variable;
{
	return (++variable);
}
@def_
@def $macro171()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, function declared to return an integer 
 */
{
	short           result = 0;

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short           variable;
{
	short           result = 0;

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4)
		statusFlag++;
	return (variable);
}

levelOneNodeTwo(variable)
	short           variable;
{
	short           result = 0;

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6)
		statusFlag++;
	return (variable);
}

levelTwoNodeOne(variable)
	short           variable;
{
	short           result = 0;

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8)
		statusFlag++;
	return (variable);
}

levelTwoNodeTwo(variable)
	short           variable;
{
	short           result = 0;

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10)
		statusFlag++;
	return (variable);
}

levelTwoNodeThree(variable)
	short           variable;
{
	short           result = 0;

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12)
		statusFlag++;
	return (variable);
}

levelTwoNodeFour(variable)
	short           variable;
{
	short           result = 0;

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14)
		statusFlag++;
	return (variable);
}

levelThreeLeafOne(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafTwo(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafThree(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafFour(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafFive(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafSix(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafSeven(variable)
	short           variable;
{
	return (variable);
}

levelThreeLeafEight(variable)
	short           variable;
{
	return (variable);
}
@def_
@def $macro172()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, no function declaration 
 */
{
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short           variable;
{
	short           result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4)
		statusFlag++;
	return (variable);
}

short 
levelOneNodeTwo(variable)
	short           variable;
{
	short           result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeOne(variable)
	short           variable;
{
	short           result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeTwo(variable)
	short           variable;
{
	short           result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeThree(variable)
	short           variable;
{
	short           result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12)
		statusFlag++;
	return (variable);
}

short 
levelTwoNodeFour(variable)
	short           variable;
{
	short           result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14)
		statusFlag++;
	return (variable);
}

short 
levelThreeLeafOne(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafTwo(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafThree(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafFour(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafFive(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafSix(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafSeven(variable)
	short           variable;
{
	return (variable);
}

short 
levelThreeLeafEight(variable)
	short           variable;
{
	return (variable);
}
@def_
@def $macro173()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s, *levelOne();
	static char    *numbers = "01234567890123456789";

	s = levelOne(1, &(numbers[~(~(k | l) >> l) & (l | l << l)]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable, numbers)
	short           variable;
	char           *numbers;
{
	char           *s, *levelTwo();
	short           j = variable + 1;

	s = levelTwo(j, numbers - (l | l << l));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return (s);
}

char           *
levelTwo(variable, numbers)
	short           variable;
	char           *numbers;
{
	char           *s, *levelThree();
	short           k = variable + 1;

	s = levelThree(k, numbers + (~(i >> l) & (l | l << l)));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return (s);
}

char           *
levelThree(variable, numbers)
	short           variable;
	char           *numbers;
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return (s);
}
@def_
@def $macro174()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	short           divide4(), result = 0;

	result = dummy1(divide4, (k >> l & (i | l)) << l);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	short           result = 0;

	result = (*func) (integer & k);
	if (result != 3)
		statusFlag++;
	return (result);
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	short           result = 0;

	result = (*func) (integer << l >> l);
	if (result != 6)
		statusFlag++;
	return (result);
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}
@def_
@def $macro175()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(i & j & k) + levelOneNodeTwo(~(i | j | k) & l) != 62)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short           variable;
{
	return (levelTwoNodeOne(variable & 01 ? variable << 1 : variable | 01)
		+ levelTwoNodeTwo(variable & 02 ?
				  (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelOneNodeTwo(variable)
	short           variable;
{
	return (levelTwoNodeThree(variable & 01 ? variable << 1 : variable | 01)
		+ levelTwoNodeFour(variable & 02 ?
				   (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelTwoNodeOne(variable)
	short           variable;
{
	return (levelThreeLeafOne(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafTwo(variable & 02 ?
				    (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelTwoNodeTwo(variable)
	short           variable;
{
	return (levelThreeLeafThree(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafFour(variable & 02 ?
				     (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelTwoNodeThree(variable)
	short           variable;
{
	return (levelThreeLeafFive(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafSix(variable & 02 ?
				    (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelTwoNodeFour(variable)
	short           variable;
{
	return (levelThreeLeafSeven(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafEight(variable & 02 ?
				      (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02));
}

levelThreeLeafOne(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafTwo(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafThree(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafFour(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafFive(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafSix(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafSeven(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}

levelThreeLeafEight(variable)
	short           variable;
{
	return (variable & 01 ? variable << 1 : variable | 01);
}
@def_
@def $macro176()
$LICENSE()
$HEAD()

short           i = 025, j = 011, k = 055;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	short           levelOneNodeOne();
	short           counter = 0;

	while (levelOneNodeOne(i & j & k) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short           variable;
{
	short           levelTwoNodeOne();

	return (levelTwoNodeOne(variable << 1) << 1);
}

short 
levelTwoNodeOne(variable)
	short           variable;
{
	short           levelThreeLeafOne();

	return (levelThreeLeafOne(variable << 1) << 1);
}

short 
levelThreeLeafOne(variable)
	short           variable;
{
	return (variable << 1);
}
@def_
@def $macro177()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";
short           i = 025, j = 011, k = 055, l = 02;

main()				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{
	char           *skip();

	if (compare(skip(i & k ^ j ^ l << l), protean + 4, 5)
	    == compare(skip((i & k ^ j) & l << l), protean + 8, 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	short           skipper;
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro178()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           divide4();

	if (dummy1(divide4, (k >> l & (i | l)) << l) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	return ((*func) (integer & k));
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	return ((*func) (integer << l >> l));
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}
@def_
@def $macro179()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, no function declaration 
 */
{
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i & j & k, counter);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	short           variable, counter;
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro180()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return an integer 
 */
{
	short           result = 0;
	short           counter = TimeLimit;
	short           recursiveFunction();

	result = recursiveFunction(i & j & k, counter);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable, counter)
	short           variable, counter;
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return (storage);
}
@def_
@def $macro181()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *recursiveFunction();
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(~(i | j | k) & l, &(numbers[i >> 1]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable, numbers, counter)
	short           variable;
	char           *numbers;
	short           counter;
{
	char           *s;
	short           storage = variable;

	if (--counter) {
		s = recursiveFunction(((variable << l | variable) & j) >> l,
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + storage);
}
@def_
@def $macro182()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           result = 0;
	short           increment();
	short           counter = TimeLimit;

	result = dummy(increment, i & j & k, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable, counter)
	short           (*function) (), variable, counter;
{
	short           result = 0;
	short           storage = variable;

	if (--counter) {
		result = dummy(function, variable << l >> l, counter);
		if (result != 2)
			statusFlag++;
	}
	return (function(storage));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro183()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	short           counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2 != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable, counter)
	short           variable, counter;
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro184()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           recursiveFunction();
	short           counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2 != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable, counter)
	short           variable, counter;
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1)
			statusFlag++;
	return (++storage);
}
@def_
@def $macro185()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	char           *recursiveFunction();

	if (*recursiveFunction(i & j & k | l) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short           variable;
{
	short           storage = variable;

	if (--counter)
		if (*recursiveFunction(variable << l >> l) != '3')
			statusFlag++;
	return (numbers + storage);
}
@def_
@def $macro186()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{
	short           increment();

	if (dummy(increment, i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), variable;
{
	short           storage = variable;

	if (--counter)
		if (dummy(function, variable << l >> l) != 2)
			statusFlag++;
	return (function(storage));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro187()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	short           counter = TimeLimit;
	short           result = 0;

	result = castor(~(i & j & k) & l, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable, counter)
	short           variable, counter;
{
	short           result = 0;

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

pollux(variable, counter)
	short           variable, counter;
{
	short           result = 0;

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro188()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	short           counter = TimeLimit;
	short           result = 0, castor();

	result = castor(~(i & j & k) & l, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable, counter)
	short           variable, counter;
{
	short           result = 0, pollux();

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1)
			statusFlag++;
	}
	return (variable);
}

short 
pollux(variable, counter)
	short           variable, counter;
{
	short           result = 0;

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2)
			statusFlag++;
	}
	return (variable);
}
@def_
@def $macro189()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s, *castor();

	s = castor(~(i & j & k) & l);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short           variable;
{
	char           *s, *pollux();

	if (--counter) {
		s = pollux(~j & (l | l << 1));
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	short           variable;
{
	char           *s;

	if (--counter) {
		s = castor(~(i & j & k) & l);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro190()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           increment();

	i = castor(increment, i & j & k);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), variable;
{
	short           result = 0;

	if (--counter) {
		result = pollux(function, j << l >> l);
		if (result != 10)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), variable;
{
	short           result = 0;

	if (--counter) {
		result = castor(function, i & j & k);
		if (result != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro191()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (castor(i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short           variable;
{
	if (--counter) {
		if (pollux(i & k & j << l) != 5)
			statusFlag++;
	}
	return (++variable);
}

pollux(variable)
	short           variable;
{
	if (--counter) {
		if (castor(i & j & k) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro192()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	short           castor();

	if (castor(i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short           variable;
{
	short           pollux();

	if (--counter) {
		if (pollux(i & j << l & k) != 5)
			statusFlag++;
	}
	return (++variable);
}

short 
pollux(variable)
	short           variable;
{
	if (--counter) {
		if (castor(i & j & k) != 2)
			statusFlag++;
	}
	return (++variable);
}
@def_
@def $macro193()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{
	char           *castor();

	if (*castor(~(i & j & k) & l) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short           variable;
{
	char           *pollux();

	if (--counter) {
		if (*pollux((i >> l | j >> l) >> 1 << 1) != '6')
			statusFlag++;
	}
	return (numbers + variable);
}

char           *
pollux(variable)
	short           variable;
{
	if (--counter) {
		if (*castor(~(i & j & k) & l) != '2')
			statusFlag++;
	}
	return (numbers + variable);
}
@def_
@def $macro194()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

main()
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{
	short           increment();

	if (castor(increment, i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), variable;
{
	if (--counter) {
		if (pollux(function, k >> l) != 12)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), variable;
{
	if (--counter) {
		if (castor(function, i & j & k) != 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro195()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(dummy(1));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelOneNodeTwo(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeOne(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeTwo(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeThree(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeFour(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

levelThreeLeafTwo(argument)
	short           argument;
{
	if (argument != 8)
		statusFlag++;
	return (argument);
}

levelThreeLeafThree(argument)
	short           argument;
{
	if (argument != 9)
		statusFlag++;
	return (argument);
}

levelThreeLeafFour(argument)
	short           argument;
{
	if (argument != 10)
		statusFlag++;
	return (argument);
}

levelThreeLeafFive(argument)
	short           argument;
{
	if (argument != 11)
		statusFlag++;
	return (argument);
}

levelThreeLeafSix(argument)
	short           argument;
{
	if (argument != 12)
		statusFlag++;
	return (argument);
}

levelThreeLeafSeven(argument)
	short           argument;
{
	if (argument != 13)
		statusFlag++;
	return (argument);
}

levelThreeLeafEight(argument)
	short           argument;
{
	if (argument != 14)
		statusFlag++;
	return (argument);
}

dummy(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro196()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, integer function declaration 
 */
{
	short           i = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(dummy(1));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(argument)
	short           argument;
{
	short           i = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelOneNodeTwo(argument)
	short           argument;
{
	short           i = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeOne(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeTwo(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeThree(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeFour(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafTwo(argument)
	short           argument;
{
	if (argument != 8)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafThree(argument)
	short           argument;
{
	if (argument != 9)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafFour(argument)
	short           argument;
{
	if (argument != 10)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafFive(argument)
	short           argument;
{
	if (argument != 11)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafSix(argument)
	short           argument;
{
	if (argument != 12)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafSeven(argument)
	short           argument;
{
	if (argument != 13)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafEight(argument)
	short           argument;
{
	if (argument != 14)
		statusFlag++;
	return (argument);
}

dummy(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro197()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: function as argument instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s, *levelOne();

	s = levelOne(dummy(1));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(argument)
	short           argument;
{
	char           *s, *levelTwo();
	short           i;

	if (argument != 1)
		statusFlag++;
	s = levelTwo(dummy(2));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelTwo(argument)
	short           argument;
{
	char           *s, *levelThree();
	short           i;

	if (argument != 2)
		statusFlag++;
	s = levelThree(dummy(3));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelThree(argument)
	short           argument;
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

dummy(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro198()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	short           i, divide4();

	i = dummy1(divide4, twelve());
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	i = (*func) (twelve());
	if (i != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	i = (*func) (twelve());
	if (i != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}

twelve()
{
	return (12);
}
@def_
@def $macro199()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(mirror(1)) != 1)
		statusFlag++;
	if (levelOneNodeTwo(mirror(2)) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	short           argument;
{
	if (levelTwoNodeOne(mirror(3)) != 3)
		statusFlag++;
	if (levelTwoNodeTwo(mirror(4)) != 4)
		statusFlag++;
	return (argument);
}

levelOneNodeTwo(argument)
	short           argument;
{
	if (levelTwoNodeThree(mirror(5)) != 5)
		statusFlag++;
	if (levelTwoNodeFour(mirror(6)) != 6)
		statusFlag++;
	return (argument);
}

levelTwoNodeOne(argument)
	short           argument;
{
	if (levelThreeLeafOne(mirror(7)) != 7)
		statusFlag++;
	if (levelThreeLeafTwo(mirror(8)) != 8)
		statusFlag++;
	return (argument);
}

levelTwoNodeTwo(argument)
	short           argument;
{
	if (levelThreeLeafThree(mirror(9)) != 9)
		statusFlag++;
	if (levelThreeLeafFour(mirror(10)) != 10)
		statusFlag++;
	return (argument);
}

levelTwoNodeThree(argument)
	short           argument;
{
	if (levelThreeLeafFive(mirror(11)) != 11)
		statusFlag++;
	if (levelThreeLeafSix(mirror(12)) != 12)
		statusFlag++;
	return (argument);
}

levelTwoNodeFour(argument)
	short           argument;
{
	if (levelThreeLeafSeven(mirror(13)) != 13)
		statusFlag++;
	if (levelThreeLeafEight(mirror(14)) != 14)
		statusFlag++;
	return (argument);
}

levelThreeLeafOne(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafTwo(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafThree(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafFour(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafFive(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafSix(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafSeven(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafEight(argument)
	short           argument;
{
	return (argument);
}

mirror(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro200()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           object = 1;

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	short           levelOneNodeOne();

	if (levelOneNodeOne(mirror(object)) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(argument)
	short           argument;
{
	short           object = argument + 2;
	short           levelTwoNodeOne();

	if (levelTwoNodeOne(mirror(object)) != 3)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeOne(argument)
	short           argument;
{
	short           object = argument + 4;
	short           levelThreeLeafOne();

	if (levelThreeLeafOne(mirror(object)) != 7)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

mirror(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro201()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{
	char           *skip();

	if (compare(skip(mirror(4)), "andra", 5)
	    == compare(skip(mirror(8)), "across", 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	short           skipper;
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}

mirror(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro202()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           divide4();

	if (dummy1(divide4, twelve()) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	if ((i = (*func) (twelve())) != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	if ((i = (*func) (twelve())) != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}

twelve()
{
	return (12);
}
@def_
@def $macro203()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

un()
{
	static short    un = 1;
	return (un);
}
@def_
@def $macro204()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, return value, legal, integer function declaration 
 */
{
	short           i = 0;
	short           recursiveFunction();

	i = recursiveFunction(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(argument)
	short           argument;
{
	short           i;
	short           recursiveFunction();

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

un()
{
	static short    un = 1;
	return (un);
}
@def_
@def $macro205()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: function as argument instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *recursiveFunction();

	s = recursiveFunction(numero(2));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(numero(3));
		if (*s != '3')
			statusFlag++;
	}
	return (numbers + argument);
}

numero(deuxOuTrois)
	short           deuxOuTrois;
{
	return (deuxOuTrois);
}
@def_
@def $macro206()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           i, increment();

	i = dummy(increment, un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = dummy(function, un());
		if (i != 2)
			statusFlag++;
	}
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

un()
{
	register short  un = 1;
	return (un);
}
@def_
@def $macro207()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	if (!(recursiveFunction(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	short           argument;
{
	if (--counter)
		if (!(recursiveFunction(un()) == 2))
			statusFlag++;
	return (++argument);
}

un()
{
	register short  un = 1;
	return (un);
}
@def_
@def $macro208()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           recursiveFunction();

	if (!(recursiveFunction(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(argument)
	short           argument;
{
	short           recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(un()) == 2))
			statusFlag++;
	return (++argument);
}

un()
{
	static short    un = 1;
	return (un);
}
@def_
@def $macro209()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: function as argument instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	char           *recursiveFunction();

	if (!(*recursiveFunction(numero(2)) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	if (--counter)
		if (!(*recursiveFunction(numero(3)) == '3'))
			statusFlag++;
	return (numbers + argument);
}

numero(deuxOuTrois)
	short           deuxOuTrois;
{
	return (deuxOuTrois);
}
@def_
@def $macro210()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{
	short           increment();

	if (!(dummy(increment, un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(dummy(function, un()) == 2))
			statusFlag++;
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

un()
{
	static short    un = 1;
	return (un);
}
@def_
@def $macro211()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = castor(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = pollux(quatre());
		if (i != 5)
			statusFlag++;
	}
	return (++argument);
}

pollux(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = castor(un());
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

un()
{
	return (1);
}

quatre()
{
	return (4);
}
@def_
@def $macro212()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           i = 0, castor();

	i = castor(rebound(1));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(argument)
	short           argument;
{
	short           i, pollux();

	if (--counter) {
		i = pollux(rebound(4));
		if (i != 5)
			statusFlag++;
	}
	return (++argument);
}

short 
pollux(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = castor(rebound(1));
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

rebound(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro213()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: function as argument instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s, *castor();

	s = castor(numero(2));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(argument)
	short           argument;
{
	char           *s, *pollux();

	if (--counter) {
		s = pollux(numero(6));
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + argument);
}

char           *
pollux(argument)
	short           argument;
{
	char           *s;

	if (--counter) {
		s = castor(numero(3));
		if (*s != '3')
			statusFlag++;
	}
	return (numbers + argument);
}

numero(questCeQueCest)
	short           questCeQueCest;
{
	static short    tableauDeNumeros[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

	return (tableauDeNumeros[questCeQueCest]);
}
@def_
@def $macro214()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           i, increment();

	i = castor(increment, un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = pollux(function, neuf());
		if (i != 10)
			statusFlag++;
	}
	return (function(argument));
}

pollux(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = castor(function, trois());
		if (i != 4)
			statusFlag++;
	}
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

un()
{
	return (Un);
}

trois()
{
	return (Trois);
}

neuf()
{
	return (Neuf);
}
@def_
@def $macro215()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (!(castor(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	short           argument;
{
	if (--counter)
		if (!(pollux(quatre()) == 5))
			statusFlag++;
	return (++argument);
}

pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(castor(un()) == 2))
			statusFlag++;
	return (++argument);
}

un()
{
	unsigned short  un = 1;
	return (un);
}

quatre()
{
	unsigned short  quatre = 4;
	return (quatre);
}
@def_
@def $macro216()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	short           castor();

	if (!(castor(numero(Un)) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(argument)
	short           argument;
{
	short           pollux();

	if (--counter)
		if (!(pollux(numero(Quatre)) == 5))
			statusFlag++;
	return (++argument);
}

short 
pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(castor(numero(Un)) == 2))
			statusFlag++;
	return (++argument);
}

numero(questCa)
	register short  questCa;
{
	return (questCa);
}
@def_
@def $macro217()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{
	char           *castor();

	if (!(*castor(numero(2)) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(argument)
	short           argument;
{
	char           *pollux();

	if (--counter)
		if (!(*pollux(numero(6)) == '6'))
			statusFlag++;
	return (numbers + argument);
}

char           *
pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(*castor(numero(3)) == '3'))
			statusFlag++;
	return (numbers + argument);
}

numero(numero)
	register short  numero;
{
	return (numero);
}
@def_
@def $macro218()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{
	short           increment();

	if (!(castor(increment, un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(pollux(function, neuf()) == 10))
			statusFlag++;
	return (function(argument));
}

pollux(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(castor(function, trois()) == 4))
			statusFlag++;
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

un()
{
	static short    un = 1;
	return (un);
}

trois()
{
	static short    trois = 3;
	return (trois);
}

neuf()
{
	static short    neuf = 9;
	return (neuf);
}
@def_
@def $macro219()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: function as argument, variable order not determined instance  : linear tree structure, return value and
 * legal, function declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	short           i = 2, a, b, c;

	c = i--;
	b = --i;
	a = ++i;
	s = levelOne(dummy(a, b, c));
	if (*s != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(argument)
	short           argument;
{
	char           *s, *levelTwo();
	short           i = argument, a, b, c;

	if (argument != 3)
		statusFlag++;
	c = ++i;
	b = ++i;
	a = i--;
	s = levelTwo(dummy(a, b, c));
	if (*s != '4')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelTwo(argument)
	short           argument;
{
	char           *s, *levelThree();
	short           i = argument, a, b, c;

	if (argument != 4)
		statusFlag++;
	c = i -= 2;
	b = i += 2;
	a = i += 1;
	s = levelThree(dummy(a, b, c));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelThree(argument)
	short           argument;
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

dummy(primero, segundo, tercero)
	short           primero, segundo, tercero;
{
	return (primero - segundo + tercero);
}
@def_
@def $macro220()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: function as argument, variable order not determined instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	short           i = 2;

	s = recursiveFunction(indeterminacy(i++, i--, ++i));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	char           *s;
	short           i = 3;

	if (--counter) {
		s = recursiveFunction(indeterminacy(i--, i++, --i));
		if (*s != '3')
			statusFlag++;
	}
	return (numbers + argument);
}

indeterminacy(primero, segundo, tercero)
	short           primero, segundo, tercero;
{
	return (primero - segundo + tercero);
}
@def_
@def $macro221()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(uno(dos(tres(1))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2))));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelOneNodeTwo(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeOne(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeTwo(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeThree(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelTwoNodeFour(argument)
	short           argument;
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

levelThreeLeafTwo(argument)
	short           argument;
{
	if (argument != 8)
		statusFlag++;
	return (argument);
}

levelThreeLeafThree(argument)
	short           argument;
{
	if (argument != 9)
		statusFlag++;
	return (argument);
}

levelThreeLeafFour(argument)
	short           argument;
{
	if (argument != 10)
		statusFlag++;
	return (argument);
}

levelThreeLeafFive(argument)
	short           argument;
{
	if (argument != 11)
		statusFlag++;
	return (argument);
}

levelThreeLeafSix(argument)
	short           argument;
{
	if (argument != 12)
		statusFlag++;
	return (argument);
}

levelThreeLeafSeven(argument)
	short           argument;
{
	if (argument != 13)
		statusFlag++;
	return (argument);
}

levelThreeLeafEight(argument)
	short           argument;
{
	if (argument != 14)
		statusFlag++;
	return (argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro222()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	short           i = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = levelOneNodeOne(uno(dos(tres(1))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2))));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(argument)
	short           argument;
{
	short           i = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelOneNodeTwo(argument)
	short           argument;
{
	short           i = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeOne(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeTwo(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeThree(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeFour(argument)
	short           argument;
{
	short           i = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14))));
	if (i == 0)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafTwo(argument)
	short           argument;
{
	if (argument != 8)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafThree(argument)
	short           argument;
{
	if (argument != 9)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafFour(argument)
	short           argument;
{
	if (argument != 10)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafFive(argument)
	short           argument;
{
	if (argument != 11)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafSix(argument)
	short           argument;
{
	if (argument != 12)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafSeven(argument)
	short           argument;
{
	if (argument != 13)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafEight(argument)
	short           argument;
{
	if (argument != 14)
		statusFlag++;
	return (argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro223()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: nested function as argument instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s, *levelOne();

	s = levelOne(uno(dos(tres(1))));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(argument)
	short           argument;
{
	char           *s, *levelTwo();
	short           i;

	if (argument != 1)
		statusFlag++;
	s = levelTwo(uno(dos(tres(2))));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelTwo(argument)
	short           argument;
{
	char           *s, *levelThree();
	short           i;

	if (argument != 2)
		statusFlag++;
	s = levelThree(uno(dos(tres(3))));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelThree(argument)
	short           argument;
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro224()
$LICENSE()
$HEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;

main()
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning an integer 
 */
{
	short           i, divide4();

	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	i = (*func) (half(twoTimes(i)));
	if (i != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	short           i = integer;

	i = (*func) (twoTimes(half(i)));
	if (i != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}

twentyFour()
{
	return (TwoDozen);
}

twoTimes(argument)
	short           argument;
{
	return (2 * argument);
}

half(argument)
	short           argument;
{
	return (argument / 2);
}
@def_
@def $macro225()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(uno(dos(tres(1)))) != 1)
		statusFlag++;
	if (levelOneNodeTwo(uno(dos(tres(2)))) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	short           argument;
{
	if (levelTwoNodeOne(uno(dos(tres(3)))) != 3)
		statusFlag++;
	if (levelTwoNodeTwo(uno(dos(tres(4)))) != 4)
		statusFlag++;
	return (argument);
}

levelOneNodeTwo(argument)
	short           argument;
{
	if (levelTwoNodeThree(uno(dos(tres(5)))) != 5)
		statusFlag++;
	if (levelTwoNodeFour(uno(dos(tres(6)))) != 6)
		statusFlag++;
	return (argument);
}

levelTwoNodeOne(argument)
	short           argument;
{
	if (levelThreeLeafOne(uno(dos(tres(7)))) != 7)
		statusFlag++;
	if (levelThreeLeafTwo(uno(dos(tres(8)))) != 8)
		statusFlag++;
	return (argument);
}

levelTwoNodeTwo(argument)
	short           argument;
{
	if (levelThreeLeafThree(uno(dos(tres(9)))) != 9)
		statusFlag++;
	if (levelThreeLeafFour(uno(dos(tres(10)))) != 10)
		statusFlag++;
	return (argument);
}

levelTwoNodeThree(argument)
	short           argument;
{
	if (levelThreeLeafFive(uno(dos(tres(11)))) != 11)
		statusFlag++;
	if (levelThreeLeafSix(uno(dos(tres(12)))) != 12)
		statusFlag++;
	return (argument);
}

levelTwoNodeFour(argument)
	short           argument;
{
	if (levelThreeLeafSeven(uno(dos(tres(13)))) != 13)
		statusFlag++;
	if (levelThreeLeafEight(uno(dos(tres(14)))) != 14)
		statusFlag++;
	return (argument);
}

levelThreeLeafOne(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafTwo(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafThree(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafFour(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafFive(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafSix(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafSeven(argument)
	short           argument;
{
	return (argument);
}

levelThreeLeafEight(argument)
	short           argument;
{
	return (argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro226()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           object = 1;

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, integer
 * function declaration 
 */
{
	short           levelOneNodeOne();

	if (levelOneNodeOne(uno(dos(tres(object)))) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(argument)
	short           argument;
{
	short           object = argument + 2;
	short           levelTwoNodeOne();

	if (levelTwoNodeOne(uno(dos(tres(object)))) != 3)
		statusFlag++;
	return (argument);
}

short 
levelTwoNodeOne(argument)
	short           argument;
{
	short           object = argument + 4;
	short           levelThreeLeafOne();

	if (levelThreeLeafOne(uno(dos(tres(object)))) != 7)
		statusFlag++;
	return (argument);
}

short 
levelThreeLeafOne(argument)
	short           argument;
{
	if (argument != 7)
		statusFlag++;
	return (argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro227()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *skip();

	if (compare(skip(uno(dos(tres(4)))), "andra", 5)
	    == compare(skip(uno(dos(tres(8)))), "across", 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	short           skipper;
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro228()
$LICENSE()
$HEAD()

#define TwoDouzen 24
short           statusFlag = NoMistake;

main()
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           divide4();

	if (dummy1(divide4, half(twoTimes(half(TwoDouzen)))) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), integer;
{
	short           i;

	if ((i = (*func) (twoTimes(half(integer)))) != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short           integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), integer;
{
	short           i;

	if ((i = (*func) (twoTimes(half(integer)))) != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short           integer;
{
	return (integer / 2);
}

twoTimes(argument)
	short           argument;
{
	return (2 * argument);
}

half(argument)
	short           argument;
{
	return (argument / 2);
}
@def_
@def $macro229()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro230()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, integer function declaration 
 */
{
	short           i, recursiveFunction();

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(argument)
	short           argument;
{
	short           i, recursiveFunction();

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro231()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s, *recursiveFunction();

	s = recursiveFunction(uno(dos(tres(Deux))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(uno(dos(tres(Trois))));
		if (*s != '3')
			statusFlag++;
	}
	return (numbers + argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro232()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning an
 * integer 
 */
{
	short           i, increment();

	i = dummy(increment, uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro233()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(argument)
	short           argument;
{
	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro234()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           recursiveFunction();

	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(argument)
	short           argument;
{
	short           recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro235()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	char           *recursiveFunction();

	if (!(*recursiveFunction(uno(dos(tres(Deux)))) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	if (--counter)
		if (!(*recursiveFunction(uno(dos(tres(Trois)))) == '3'))
			statusFlag++;
	return (numbers + argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro236()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           increment();

	if (!(dummy(increment, uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(dummy(function, uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro237()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i;

	i = castor(uno(dos(tres(Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = pollux(uno(dos(tres(Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return (++argument);
}

pollux(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = castor(uno(dos(tres(Un))));
		if (i != Deux)
			statusFlag++;
	}
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro238()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           i, castor();

	i = castor(uno(dos(tres(Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(argument)
	short           argument;
{
	short           i, pollux();

	if (--counter) {
		i = pollux(uno(dos(tres(Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return (++argument);
}

short 
pollux(argument)
	short           argument;
{
	short           i;

	if (--counter) {
		i = castor(uno(dos(tres(Un))));
		if (i != Deux)
			statusFlag++;
	}
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro239()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
#define Neuf  9
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: nested function as argument instance  : gemini, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *castor();

	s = castor(uno(dos(tres(Deux))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(argument)
	short           argument;
{
	char           *s, *pollux();

	if (--counter) {
		s = pollux(uno(dos(tres(Neuf))));
		if (*s != '9')
			statusFlag++;
	}
	return (numbers + argument);
}

char           *
pollux(argument)
	short           argument;
{
	char           *s;

	if (--counter) {
		s = castor(uno(dos(tres(Trois))));
		if (*s != '3')
			statusFlag++;
	}
	return (numbers + argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(numero)
	short           numero;
{
	static short    tableauDeNumeros[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

	return (tableauDeNumeros[numero]);
}
@def_
@def $macro240()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           i, increment();

	i = castor(increment, uno(dos(tres(Un))));
	if (i != Un + 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = pollux(function, uno(dos(tres(Neuf))));
		if (i != Neuf + 1)
			statusFlag++;
	}
	return (function(argument));
}

pollux(function, argument)
	short           (*function) (), argument;
{
	short           i;
	if (--counter) {
		i = castor(function, uno(dos(tres(Trois))));
		if (i != Trois + 1)
			statusFlag++;
	}
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro241()
$LICENSE()
$HEAD()

#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif
short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (!(castor(uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(argument)
	short           argument;
{
	if (--counter)
		if (!(pollux(uno(dos(tres(Quatre)))) == Cinq))
			statusFlag++;
	return (++argument);
}

pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(castor(uno(dos(tres(Un)))) == Deux))
			statusFlag++;
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro242()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return an
 * integer 
 */
{
	short           castor();

	if (!(castor(uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(argument)
	short           argument;
{
	short           pollux();

	if (--counter)
		if (!(pollux(uno(dos(tres(Quatre)))) == Cinq))
			statusFlag++;
	return (++argument);
}

short 
pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(castor(uno(dos(tres(Un)))) == Deux))
			statusFlag++;
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro243()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
#ifndef Numeros
#define Deux  2
#define Trois 3
#define Six   6
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	char           *castor();

	if (!(*castor(uno(dos(tres(Deux)))) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(argument)
	short           argument;
{
	char           *pollux();

	if (--counter)
		if (!(*pollux(uno(dos(tres(Six)))) == '6'))
			statusFlag++;
	return (numbers + argument);
}

char           *
pollux(argument)
	short           argument;
{
	if (--counter)
		if (!(*castor(uno(dos(tres(Trois)))) == '3'))
			statusFlag++;
	return (numbers + argument);
}

uno(uno)
	register short  uno;
{
	return (uno);
}

dos(dos)
	register short  dos;
{
	return (dos);
}

tres(tres)
	register short  tres;
{
	return (tres);
}
@def_
@def $macro244()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

main()
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{
	short           increment();

	if (!(castor(increment, uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(pollux(function, uno(dos(tres(Neuf)))) == Dix))
			statusFlag++;
	return (function(argument));
}

pollux(function, argument)
	short           (*function) (), argument;
{
	if (--counter)
		if (!(castor(function, uno(dos(tres(Trois)))) == Quatre))
			statusFlag++;
	return (function(argument));
}

short 
increment(argument)
	short           argument;
{
	return (++argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(argument)
	short           argument;
{
	return (argument);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro245()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: nested function as argument, random order instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	short           i = 2, a, b, c;

	c = i--;
	b = --i;
	a = ++i;
	s = levelOne(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(argument)
	short           argument;
{
	char           *s, *levelTwo();
	short           i = argument, a, b, c;

	if (argument != 3)
		statusFlag++;
	c = ++i;
	b = ++i;
	a = i--;
	s = levelTwo(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '4')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelTwo(argument)
	short           argument;
{
	char           *s, *levelThree();
	short           i = argument, a, b, c;

	if (argument != 4)
		statusFlag++;
	c = i -= 2;
	b = i += 2;
	a = i += 1;
	s = levelThree(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

char           *
levelThree(argument)
	short           argument;
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return (s);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(primero, segundo, tercero)
	short           primero, segundo, tercero;
{
	return (primero - segundo + tercero);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_
@def $macro246()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: nested function as argument, random order instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	short           i = 2, a, b, c;

	c = ++i;
	b = i--;
	a = i++;
	s = recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(argument)
	short           argument;
{
	char           *s;
	short           i = 3, a, b, c;

	if (--counter) {
		c = --i;
		b = i++;
		a = i--;
		s = recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
		if (*s != '3')
			statusFlag;
	}
	return (numbers + argument);
}

uno(argument)
	short           argument;
{
	return (argument);
}

dos(primero, segundo, tercero)
	short           primero, segundo, tercero;
{
	return (primero - segundo + tercero);
}

tres(argument)
	short           argument;
{
	return (argument);
}
@def_

@def $testout()
#ifdef unix
#include<stdio.h>
#include<float.h>
#define printok() printf("@OK@\n")
#define printno() printf("@NG@\n")
#define ABS(a) ((a > 0)? (a) : (-(a)))
#define MAX(a, b) ((a > b)? (a) : (b))
#define TGEN_FLT_EQ(a, b) ( ((a)==(b)) || ABS(((a) - (b))) / MAX( ABS(a), ABS(b) ) <= FLT_EPSILON )
#endif
@def_

@dir ckr.4-2-06
@file >>def.h $macro0() @file_
@file >>fdef.h $macro1() @file_
@file >>ft3401.c $macro2() @file_
@file >>ft3402.c $macro3() @file_
@file >>ft3404.c $macro4() @file_
@file >>ft3406.c $macro5() @file_
@file >>ft3408.c $macro6() @file_
@file >>ft3410.c $macro7() @file_
@file >>ft3411.c $macro8() @file_
@file >>ft3412.c $macro9() @file_
@file >>ft3414.c $macro10() @file_
@file >>ft3416.c $macro11() @file_
@file >>ft3418.c $macro12() @file_
@file >>ft3420.c $macro13() @file_
@file >>ft3421.c $macro14() @file_
@file >>ft3422.c $macro15() @file_
@file >>ft3424.c $macro16() @file_
@file >>ft3426.c $macro17() @file_
@file >>ft3428.c $macro18() @file_
@file >>ft3430.c $macro19() @file_
@file >>ft3511.c $macro20() @file_
@file >>ft3601.c $macro21() @file_
@file >>ft3602.c $macro22() @file_
@file >>ft3604.c $macro23() @file_
@file >>ft3606.c $macro24() @file_
@file >>ft3608.c $macro25() @file_
@file >>ft3610.c $macro26() @file_
@file >>ft3611.c $macro27() @file_
@file >>ft3612.c $macro28() @file_
@file >>ft3614.c $macro29() @file_
@file >>ft3616.c $macro30() @file_
@file >>ft3618.c $macro31() @file_
@file >>ft3620.c $macro32() @file_
@file >>ft3621.c $macro33() @file_
@file >>ft3622.c $macro34() @file_
@file >>ft3624.c $macro35() @file_
@file >>ft3626.c $macro36() @file_
@file >>ft3628.c $macro37() @file_
@file >>ft3630.c $macro38() @file_
@file >>ft3711.c $macro39() @file_
@file >>lt3101.c $macro40() @file_
@file >>lt3102.c $macro41() @file_
@file >>lt3104.c $macro42() @file_
@file >>lt3112.c $macro43() @file_
@file >>lt3114.c $macro44() @file_
@file >>lt3118.c $macro45() @file_
@file >>lt3120.c $macro46() @file_
@file >>lt3122.c $macro47() @file_
@file >>lt3124.c $macro48() @file_
@file >>lt3126.c $macro49() @file_
@file >>lt3128.c $macro50() @file_
@file >>lt3201.c $macro51() @file_
@file >>lt3202.c $macro52() @file_
@file >>lt3204.c $macro53() @file_
@file >>lt3206.c $macro54() @file_
@file >>lt3208.c $macro55() @file_
@file >>lt3210.c $macro56() @file_
@file >>lt3211.c $macro57() @file_
@file >>lt3212.c $macro58() @file_
@file >>lt3214.c $macro59() @file_
@file >>lt3216.c $macro60() @file_
@file >>lt3218.c $macro61() @file_
@file >>lt3220.c $macro62() @file_
@file >>lt3221.c $macro63() @file_
@file >>lt3222.c $macro64() @file_
@file >>lt3224.c $macro65() @file_
@file >>lt3226.c $macro66() @file_
@file >>lt3228.c $macro67() @file_
@file >>lt3230.c $macro68() @file_
@file >>lt3301.c $macro69() @file_
@file >>lt3302.c $macro70() @file_
@file >>lt3304.c $macro71() @file_
@file >>lt3306.c $macro72() @file_
@file >>lt3308.c $macro73() @file_
@file >>lt3310.c $macro74() @file_
@file >>lt3311.c $macro75() @file_
@file >>lt3312.c $macro76() @file_
@file >>lt3314.c $macro77() @file_
@file >>lt3316.c $macro78() @file_
@file >>lt3318.c $macro79() @file_
@file >>lt3320.c $macro80() @file_
@file >>lt3321.c $macro81() @file_
@file >>lt3322.c $macro82() @file_
@file >>lt3324.c $macro83() @file_
@file >>lt3326.c $macro84() @file_
@file >>lt3328.c $macro85() @file_
@file >>lt3330.c $macro86() @file_
@file >>lt3401.c $macro87() @file_
@file >>lt3402.c $macro88() @file_
@file >>lt3404.c $macro89() @file_
@file >>lt3406.c $macro90() @file_
@file >>lt3408.c $macro91() @file_
@file >>lt3410.c $macro92() @file_
@file >>lt3411.c $macro93() @file_
@file >>lt3412.c $macro94() @file_
@file >>lt3414.c $macro95() @file_
@file >>lt3416.c $macro96() @file_
@file >>lt3418.c $macro97() @file_
@file >>lt3420.c $macro98() @file_
@file >>lt3421.c $macro99() @file_
@file >>lt3422.c $macro100() @file_
@file >>lt3424.c $macro101() @file_
@file >>lt3426.c $macro102() @file_
@file >>lt3428.c $macro103() @file_
@file >>lt3430.c $macro104() @file_
@file >>lt3511.c $macro105() @file_
@file >>lt3601.c $macro106() @file_
@file >>lt3602.c $macro107() @file_
@file >>lt3604.c $macro108() @file_
@file >>lt3606.c $macro109() @file_
@file >>lt3608.c $macro110() @file_
@file >>lt3610.c $macro111() @file_
@file >>lt3611.c $macro112() @file_
@file >>lt3612.c $macro113() @file_
@file >>lt3614.c $macro114() @file_
@file >>lt3616.c $macro115() @file_
@file >>lt3618.c $macro116() @file_
@file >>lt3620.c $macro117() @file_
@file >>lt3621.c $macro118() @file_
@file >>lt3622.c $macro119() @file_
@file >>lt3624.c $macro120() @file_
@file >>lt3626.c $macro121() @file_
@file >>lt3628.c $macro122() @file_
@file >>lt3630.c $macro123() @file_
@file >>lt3711.c $macro124() @file_
@file >>t3103.c $macro125() @file_
@file >>t3104.c $macro126() @file_
@file >>t3105.c $macro127() @file_
@file >>t3106.c $macro128() @file_
@file >>t3108.c $macro129() @file_
@file >>t3109.c $macro130() @file_
@file >>t3110.c $macro131() @file_
@file >>t3111.c $macro132() @file_
@file >>t3113.c $macro133() @file_
@file >>t3114.c $macro134() @file_
@file >>t3115.c $macro135() @file_
@file >>t3116.c $macro136() @file_
@file >>t3117.c $macro137() @file_
@file >>t3119.c $macro138() @file_
@file >>t3120.c $macro139() @file_
@file >>t3121.c $macro140() @file_
@file >>t3123.c $macro141() @file_
@file >>t3124.c $macro142() @file_
@file >>t3125.c $macro143() @file_
@file >>t3126.c $macro144() @file_
@file >>t3127.c $macro145() @file_
@file >>t3128.c $macro146() @file_
@file >>t3129.c $macro147() @file_
@file >>t3130.c $macro148() @file_
@file >>t3203.c $macro149() @file_
@file >>t3204.c $macro150() @file_
@file >>t3205.c $macro151() @file_
@file >>t3206.c $macro152() @file_
@file >>t3208.c $macro153() @file_
@file >>t3209.c $macro154() @file_
@file >>t3210.c $macro155() @file_
@file >>t3214.c $macro156() @file_
@file >>t3215.c $macro157() @file_
@file >>t3216.c $macro158() @file_
@file >>t3217.c $macro159() @file_
@file >>t3218.c $macro160() @file_
@file >>t3219.c $macro161() @file_
@file >>t3220.c $macro162() @file_
@file >>t3223.c $macro163() @file_
@file >>t3224.c $macro164() @file_
@file >>t3225.c $macro165() @file_
@file >>t3226.c $macro166() @file_
@file >>t3227.c $macro167() @file_
@file >>t3228.c $macro168() @file_
@file >>t3229.c $macro169() @file_
@file >>t3230.c $macro170() @file_
@file >>t3303.c $macro171() @file_
@file >>t3304.c $macro172() @file_
@file >>t3305.c $macro173() @file_
@file >>t3306.c $macro174() @file_
@file >>t3307.c $macro175() @file_
@file >>t3308.c $macro176() @file_
@file >>t3309.c $macro177() @file_
@file >>t3310.c $macro178() @file_
@file >>t3313.c $macro179() @file_
@file >>t3314.c $macro180() @file_
@file >>t3315.c $macro181() @file_
@file >>t3316.c $macro182() @file_
@file >>t3317.c $macro183() @file_
@file >>t3318.c $macro184() @file_
@file >>t3319.c $macro185() @file_
@file >>t3320.c $macro186() @file_
@file >>t3323.c $macro187() @file_
@file >>t3324.c $macro188() @file_
@file >>t3325.c $macro189() @file_
@file >>t3326.c $macro190() @file_
@file >>t3327.c $macro191() @file_
@file >>t3328.c $macro192() @file_
@file >>t3329.c $macro193() @file_
@file >>t3330.c $macro194() @file_
@file >>t3403.c $macro195() @file_
@file >>t3404.c $macro196() @file_
@file >>t3405.c $macro197() @file_
@file >>t3406.c $macro198() @file_
@file >>t3407.c $macro199() @file_
@file >>t3408.c $macro200() @file_
@file >>t3409.c $macro201() @file_
@file >>t3410.c $macro202() @file_
@file >>t3413.c $macro203() @file_
@file >>t3414.c $macro204() @file_
@file >>t3415.c $macro205() @file_
@file >>t3416.c $macro206() @file_
@file >>t3417.c $macro207() @file_
@file >>t3418.c $macro208() @file_
@file >>t3419.c $macro209() @file_
@file >>t3420.c $macro210() @file_
@file >>t3423.c $macro211() @file_
@file >>t3424.c $macro212() @file_
@file >>t3425.c $macro213() @file_
@file >>t3426.c $macro214() @file_
@file >>t3427.c $macro215() @file_
@file >>t3428.c $macro216() @file_
@file >>t3429.c $macro217() @file_
@file >>t3430.c $macro218() @file_
@file >>t3505.c $macro219() @file_
@file >>t3515.c $macro220() @file_
@file >>t3603.c $macro221() @file_
@file >>t3604.c $macro222() @file_
@file >>t3605.c $macro223() @file_
@file >>t3606.c $macro224() @file_
@file >>t3607.c $macro225() @file_
@file >>t3608.c $macro226() @file_
@file >>t3609.c $macro227() @file_
@file >>t3610.c $macro228() @file_
@file >>t3613.c $macro229() @file_
@file >>t3614.c $macro230() @file_
@file >>t3615.c $macro231() @file_
@file >>t3616.c $macro232() @file_
@file >>t3617.c $macro233() @file_
@file >>t3618.c $macro234() @file_
@file >>t3619.c $macro235() @file_
@file >>t3620.c $macro236() @file_
@file >>t3623.c $macro237() @file_
@file >>t3624.c $macro238() @file_
@file >>t3625.c $macro239() @file_
@file >>t3626.c $macro240() @file_
@file >>t3627.c $macro241() @file_
@file >>t3628.c $macro242() @file_
@file >>t3629.c $macro243() @file_
@file >>t3630.c $macro244() @file_
@file >>t3705.c $macro245() @file_
@file >>t3715.c $macro246() @file_
@file >>testout.h $testout() @file_
@dir_
