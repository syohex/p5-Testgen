@comment
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
ishiura-gcc@ksc.kwansei.ac.jp

This file was written by Yuki Uchiyama. (ishiura-gcc@ksc.kwansei.ac.jp)
@comment_

@include
license.inc
@include_

@def $HEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "def.h"
@def_

@def $FHEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "fdef.h"
@def_

@def $macro0()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
#define NoMistake 00
@def_

@def $macro1()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
float           OK_f = 1.0;
float           NO_f = 0.0;
#define NoMistake 00
@def_

@def $macro2()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i;
float           variable;

int main(void)				/* alias root */
/*
 *  test class: extern float variable instance  : linear tree structure, no return value and legal 
 */
{
	extern float    i;

	i = 1.0;
	levelOneNodeOne(i);
	i = 2.0;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	variable = 3.0;
	levelTwoNodeOne(variable);
	variable = 4.0;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 2.0)) )
		statusFlag++;
	variable = 5.0;
	levelTwoNodeThree(variable);
	variable = 6.0;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 3.0)) )
		statusFlag++;
	variable = 7.0;
	levelThreeLeafOne(variable);
	variable = 8.0;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 4.0)) )
		statusFlag++;
	variable = 9.0;
	levelThreeLeafThree(variable);
	variable = 10.0;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 5.0)) )
		statusFlag++;
	variable = 11.0;
	levelThreeLeafFive(variable);
	variable = 12.0;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 6.0)) )
		statusFlag++;
	variable = 13.0;
	levelThreeLeafSeven(variable);
	variable = 14.0;
	levelThreeLeafEight(variable);
}

void levelThreeLeafOne(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float argument)
{
	extern float    variable;

	variable = argument;
 if ( !(TGEN_FLT_EQ(variable, 14.0)) )
		statusFlag++;
}
@def_
@def $macro3()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i, variable;

int main(void)				/* alias root */
/*
 *  test class: extern float variable instance  : linear tree structure, no return value and illegal 
 */
{
	extern float    i;
	float           result = 0.0;

	i = 1.0;
/*	result = levelOneNodeOne(i);*/
	i = 2.0;
/*	result = levelOneNodeTwo(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 1.0) )
		statusFlag++;
	variable = 3.0;
/*	result = levelTwoNodeOne(variable);*/
	variable = 4.0;
/*	result = levelTwoNodeTwo(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelOneNodeTwo(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 2.0) )
		statusFlag++;
	variable = 5.0;
/*	result = levelTwoNodeThree(variable);*/
	variable = 6.0;
/*	result = levelTwoNodeFour(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelTwoNodeOne(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 3.0) )
		statusFlag++;
	variable = 7.0;
/*	result = levelThreeLeafOne(variable);*/
	variable = 8.0;
/*	result = levelThreeLeafTwo(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelTwoNodeTwo(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 4.0) )
		statusFlag++;
	variable = 9.0;
/*	result = levelThreeLeafThree(variable);*/
	variable = 10.0;
/*	result = levelThreeLeafFour(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelTwoNodeThree(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 5.0) )
		statusFlag++;
	variable = 11.0;
/*	result = levelThreeLeafFive(variable);*/
	variable = 12.0;
/*	result = levelThreeLeafSix(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelTwoNodeFour(float argument)
{
	float           result;
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 6.0) )
		statusFlag++;
	variable = 13.0;
/*	result = levelThreeLeafSeven(variable);*/
	variable = 14.0;
/*	result = levelThreeLeafEight(variable);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

void levelThreeLeafOne(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 7.0) )
		statusFlag++;
	return;
}

void levelThreeLeafTwo(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 8.0) )
		statusFlag++;
	return;
}

void levelThreeLeafThree(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 9.0) )
		statusFlag++;
	return;
}

void levelThreeLeafFour(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 10.0) )
		statusFlag++;
	return;
}

void levelThreeLeafFive(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 11.0) )
		statusFlag++;
	return;
}

void levelThreeLeafSix(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 12.0) )
		statusFlag++;
	return;
}

void levelThreeLeafSeven(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 13.0) )
		statusFlag++;
	return;
}

void levelThreeLeafEight(float argument)
{
	extern float    variable;

	if (! TGEN_FLT_EQ((variable = argument), 14.0) )
		statusFlag++;
	return;
}
@def_
@def $macro4()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float);
float levelOneNodeTwo(float);
float levelTwoNodeOne(float);
float levelTwoNodeTwo(float);
float levelTwoNodeThree(float);
float levelTwoNodeFour(float);
float levelThreeLeafOne(float);
float levelThreeLeafTwo(float);
float levelThreeLeafThree(float);
float levelThreeLeafFour(float);
float levelThreeLeafFive(float);
float levelThreeLeafSix(float);
float levelThreeLeafSeven(float);
float levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, return value and legal, Float function declaration 
 */
{
	extern float    i;

	i = 1.0;
	i = levelOneNodeOne(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	i = 2.0;
	i = levelOneNodeTwo(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           storage = variable;

	variable = 3.0;
	variable = levelTwoNodeOne(variable);
 if ( !(TGEN_FLT_EQ(variable, 3.0)) )
		statusFlag++;
	variable = 4.0;
	variable = levelTwoNodeTwo(variable);
 if ( !(TGEN_FLT_EQ(variable, 4.0)) )
		statusFlag++;
	return storage;
}

float levelOneNodeTwo(float variable)
{
	float           storage = variable;

	variable = 5.0;
	variable = levelTwoNodeThree(variable);
 if ( !(TGEN_FLT_EQ(variable, 5.0)) )
		statusFlag++;
	variable = 6.0;
	variable = levelTwoNodeFour(variable);
 if ( !(TGEN_FLT_EQ(variable, 6.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeOne(float variable)
{
	float           storage = variable;

	variable = 7.0;
	variable = levelThreeLeafOne(variable);
 if ( !(TGEN_FLT_EQ(variable, 7.0)) )
		statusFlag++;
	variable = 8.0;
	variable = levelThreeLeafTwo(variable);
 if ( !(TGEN_FLT_EQ(variable, 8.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeTwo(float variable)
{
	float           storage = variable;

	variable = 9.0;
	variable = levelThreeLeafThree(variable);
 if ( !(TGEN_FLT_EQ(variable, 9.0)) )
		statusFlag++;
	variable = 10.0;
	variable = levelThreeLeafFour(variable);
 if ( !(TGEN_FLT_EQ(variable, 10.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeThree(float variable)
{
	float           storage = variable;

	variable = 11.0;
	variable = levelThreeLeafFive(variable);
 if ( !(TGEN_FLT_EQ(variable, 11.0)) )
		statusFlag++;
	variable = 12.0;
	variable = levelThreeLeafSix(variable);
 if ( !(TGEN_FLT_EQ(variable, 12.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeFour(float variable)
{
	float           storage = variable;

	variable = 13.0;
	variable = levelThreeLeafSeven(variable);
 if ( !(TGEN_FLT_EQ(variable, 13.0)) )
		statusFlag++;
	variable = 14.0;
	variable = levelThreeLeafEight(variable);
 if ( !(TGEN_FLT_EQ(variable, 14.0)) )
		statusFlag++;
	return storage;
}

float levelThreeLeafOne(float variable)
{
	return variable;
}

float levelThreeLeafTwo(float variable)
{
	return variable;
}

float levelThreeLeafThree(float variable)
{
	return variable;
}

float levelThreeLeafFour(float variable)
{
	return variable;
}

float levelThreeLeafFive(float variable)
{
	return variable;
}

float levelThreeLeafSix(float variable)
{
	return variable;
}

float levelThreeLeafSeven(float variable)
{
	return variable;
}

float levelThreeLeafEight(float variable)
{
	return variable;
}
@def_
@def $macro5()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, return value, legal pointer to function returning a float 
 */
{
	extern float    i;

	i = 12.0;
	i = dummy1(divide4, i);
 if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	extern float    i;

	i = (*func) (Float);
 if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return i;
}

float divide4(float Float)
{

	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	extern float    i;

	i = (*func) (Float);
 if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return i;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro6()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float);
float levelTwoNodeOne(float);
float levelThreeLeafOne(float);

short           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = levelOneNodeOne(i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           ii;

	ii = 2.0 * variable;
	return 2.0 * levelTwoNodeOne(ii);
}

float levelTwoNodeOne(float variable)
{
	float           iii;

	iii = 2.0 * variable;
	return 2.0 * levelThreeLeafOne(iii);
}

float levelThreeLeafOne(float variable)
{
	return 2.0 * variable;
}
@def_
@def $macro7()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, in conditional expression, pointer to function returning a
 * float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 12.0;
	arg_a = dummy1(divide4, i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	float           ii;

	if (! TGEN_FLT_EQ( (ii = (*func) (Float)), 3.0) )
		statusFlag++;
	return ii;
}

float divide4(float Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	return ii;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro8()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, no return value, legal 
 */
{
	extern float    i;

	i = 1.0;
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro9()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : recursive call, no return value, illegal 
 */
{
	extern float    i;

	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
	float           ii;
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	if (--counter) {
/*		ii = recursiveFunction(i);*/
 if ( TGEN_FLT_EQ(ii, 0.0) )
			ii++;
	}
	return;
}
@def_
@def $macro10()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, legal, Float function declaration 
 */
{
	extern float    i;

	i = recursiveFunction(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           result;

	if (--counter) {
		result = recursiveFunction(variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro11()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, pointer to function returning a float 
 */
{
	i = dummy(increment, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           result;

	if (--counter) {
		result = dummy(function, variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro12()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : recursive call, function in conditional expression, Float function declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(i) - i;
	arg_b = 1.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(variable) - variable;
		arg_b = 1.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro13()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, in conditional expression, pointer to function returning a float 
 */
{
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = dummy(increment, i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, variable);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro14()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : gemini, no return value, legal 
 */
{
	extern float    i;

	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		variable++;
		pollux(variable);
	}
}

void pollux(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--variable;
		castor(variable);
	}
}
@def_
@def $macro15()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : gemini, no return value, illegal 
 */
{
	extern float    i;
	float           result;

/*	result = castor(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
	extern float    i;
	float           ii;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	if (--counter) {
/*		ii = pollux(i);*/
 if ( TGEN_FLT_EQ(ii, 0.0) )
			ii++;
	}
}

void pollux(float variable)
{
	extern float    i;
	float           iii;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	if (--counter) {
/*		iii = castor(i);*/
 if ( TGEN_FLT_EQ(iii, 0.0) )
			iii++;
	}
}
@def_
@def $macro16()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, legal, function declared to return a float 
 */
{
	extern float    i;

	i = 1.0;
	i = castor(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	float           ii = variable + 3.0;

	if (--counter) {
		ii = pollux(ii);
 if ( !(TGEN_FLT_EQ(ii, 5.0)) )
			statusFlag++;
	}
	return ++variable;
}

float pollux(float variable)
{
	float           iii = variable - 3.0;

	if (--counter) {
		iii = castor(iii);
 if ( !(TGEN_FLT_EQ(iii, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro17()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, pointer to function returning a float 
 */
{
	i = castor(increment, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	float           ii = variable + 8.0;
	if (--counter) {
		ii = pollux(function, ii);
 if ( !(TGEN_FLT_EQ(ii, 10.0)) )
			statusFlag++;
	}
	return function(variable);
}

float pollux(float (*function) (float), float variable)
{
	float           iii = variable - 8.0;
	if (--counter) {
		iii = castor(function, iii);
 if ( !(TGEN_FLT_EQ(iii, 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro18()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, function declared to return a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = castor(i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	extern float    ii;
	float           arg_a, arg_b;

	ii = variable + 3.0;
	if (--counter) {
		arg_a = pollux(ii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}

float pollux(float variable)
{
	extern float    iii;
	float           arg_a, arg_b;

	iii = variable - 3.0;
	if (--counter) {
		arg_a = castor(iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro19()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, pointer to function returning a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = castor(increment, i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	float           ii = variable + 10.0;
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(function, ii);
		arg_b = 12.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float pollux(float (*function) (float), float variable)
{
	float           iii = variable - 10.0;
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(function, iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro20()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, no return value and legal 
 */
{
	extern float    i;

	i = 1.0;
	levelOneNodeOne(i);
	i = 2.0;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 3.0;
	levelTwoNodeOne(i);
	i = 4.0;
	levelTwoNodeTwo(i);
	variable++;
}

void levelOneNodeTwo(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 5.0;
	levelTwoNodeThree(i);
	i = 6.0;
	levelTwoNodeFour(i);
	variable++;
}

void levelTwoNodeOne(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 7.0;
	levelThreeLeafOne(i);
	i = 8.0;
	levelThreeLeafTwo(i);
	variable++;
}

void levelTwoNodeTwo(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 9.0;
	levelThreeLeafThree(i);
	i = 10.0;
	levelThreeLeafFour(i);
	variable++;
}

void levelTwoNodeThree(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 11.0;
	levelThreeLeafFive(i);
	i = 12.0;
	levelThreeLeafSix(i);
	variable++;
}

void levelTwoNodeFour(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 13.0;
	levelThreeLeafSeven(i);
	i = 14.0;
	levelThreeLeafEight(i);
	variable++;
}

void levelThreeLeafOne(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafTwo(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafThree(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafFour(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafFive(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafSix(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafSeven(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}

void levelThreeLeafEight(float variable)
{
	float           i = 0.0;
 if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	variable++;
}
@def_
@def $macro21()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i, whatIsThis;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, no return value and illegal 
 */
{
	extern float    i;

	i = 1.0;
/*	whatIsThis = levelOneNodeOne(i);*/
	i = 2.0;
/*	whatIsThis = levelOneNodeTwo(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float variable)
{
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	i = 3.0;
/*	whatIsThis = levelTwoNodeOne(i);*/
	i = 4.0;
/*	whatIsThis = levelTwoNodeTwo(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelOneNodeTwo(float variable)
{
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 2.0) )
		statusFlag++;
	i = 5.0;
/*	whatIsThis = levelTwoNodeThree(i);*/
	i = 6.0;
/*	whatIsThis = levelTwoNodeFour(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelTwoNodeOne(float variable)
{
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 3.0) )
		statusFlag++;
	i = 7.0;
/*	whatIsThis = levelThreeLeafOne(i);*/
	i = 8.0;
/*	whatIsThis = levelThreeLeafTwo(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelTwoNodeTwo(float variable)
{
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 4.0) )
		statusFlag++;
	i = 9.0;
/*	whatIsThis = levelThreeLeafThree(i);*/
	i = 10.0;
/*	whatIsThis = levelThreeLeafFour(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelTwoNodeThree(float variable)
{
	extern float    i;

	if (! TGEN_FLT_EQ((i = variable), 5.0) )
		statusFlag++;
	i = 11.0;
/*	whatIsThis = levelThreeLeafFive(i);*/
	i = 12.0;
/*	whatIsThis = levelThreeLeafSix(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelTwoNodeFour(float variable)
{
	float           i;

	if (! TGEN_FLT_EQ((i = variable), 6.0) )
		statusFlag++;
	i = 13.0;
/*	whatIsThis = levelThreeLeafSeven(i);*/
	i = 14.0;
/*	whatIsThis = levelThreeLeafEight(i);*/
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
}

void levelThreeLeafOne(float variable)
{
	variable++;
	return;
}

void levelThreeLeafTwo(float variable)
{
	variable++;
	return;
}

void levelThreeLeafThree(float variable)
{
	variable++;
	return;
}

void levelThreeLeafFour(float variable)
{
	variable++;
	return;
}

void levelThreeLeafFive(float variable)
{
	variable++;
	return;
}

void levelThreeLeafSix(float variable)
{
	variable++;
	return;
}

void levelThreeLeafSeven(float variable)
{
	variable++;
	return;
}

void levelThreeLeafEight(float variable)
{
	variable++;
	return;
}
@def_
@def $macro22()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float);
float levelOneNodeTwo(float);
float levelTwoNodeOne(float);
float levelTwoNodeTwo(float);
float levelTwoNodeThree(float);
float levelTwoNodeFour(float);
float levelThreeLeafOne(float);
float levelThreeLeafTwo(float);
float levelThreeLeafThree(float);
float levelThreeLeafFour(float);
float levelThreeLeafFive(float);
float levelThreeLeafSix(float);
float levelThreeLeafSeven(float);
float levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i = 1.0;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, return value and legal, Float
 * function declaration 
 */
{
	i = levelOneNodeOne(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	i++;
	i = levelOneNodeTwo(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           i = 3.0;

 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(i);
 if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	i++;
	i = levelTwoNodeTwo(i);
 if ( !(TGEN_FLT_EQ(i, 4.0)) )
		statusFlag++;
	return variable;
}

float levelOneNodeTwo(float variable)
{
	float           i = 5.0;

 if ( !(TGEN_FLT_EQ(variable, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(i);
 if ( !(TGEN_FLT_EQ(i, 5.0)) )
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
 if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeOne(float variable)
{
	float           i = 7.0;

 if ( !(TGEN_FLT_EQ(variable, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(i);
 if ( !(TGEN_FLT_EQ(i, 7.0)) )
		statusFlag++;
	i++;
	i = levelThreeLeafTwo(i);
 if ( !(TGEN_FLT_EQ(i, 8.0)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeTwo(float variable)
{
	float           i = 9.0;

 if ( !(TGEN_FLT_EQ(variable, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(i);
 if ( !(TGEN_FLT_EQ(i, 9.0)) )
		statusFlag++;
	i++;
	i = levelThreeLeafFour(i);
 if ( !(TGEN_FLT_EQ(i, 10.0)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeThree(float variable)
{
	float           i = 11.0;

 if ( !(TGEN_FLT_EQ(variable, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(i);
 if ( !(TGEN_FLT_EQ(i, 11.0)) )
		statusFlag++;
	i++;
	i = levelThreeLeafSix(i);
 if ( !(TGEN_FLT_EQ(i, 12.0)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeFour(float variable)
{
	float           i = 13.0;

 if ( !(TGEN_FLT_EQ(variable, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(i);
 if ( !(TGEN_FLT_EQ(i, 13.0)) )
		statusFlag++;
	i++;
	i = levelThreeLeafEight(i);
 if ( !(TGEN_FLT_EQ(i, 14.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafOne(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 7.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafTwo(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 8.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafThree(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 9.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafFour(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 10.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafFive(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 11.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafSix(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 12.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafSeven(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 13.0)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafEight(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 14.0)) )
		statusFlag++;
	return variable;
}
@def_
@def $macro23()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, return value, legal pointer to
 * function returning a float 
 */
{
	extern float    i;

	i = 12.0;
	i = dummy1(divide4, i);
 if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	float           i;

	i = (*func) (Float);
 if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return i;
}

float divide4(float Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	float           i;

	i = (*func) (Float);
 if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return i;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro24()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float);
float levelTwoNodeOne(float);
float levelThreeLeafOne(float);

short           statusFlag = NoMistake;
float           i = 1.0;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, used in conditional expression,
 * Float function declaration 
 */
{
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           i;

	i = 2.0 * variable;
	return 2.0 * levelTwoNodeOne(i);
}

float levelTwoNodeOne(float variable)
{
	float           i;

	i = 2.0 * variable;
	return 2.0 * levelThreeLeafOne(i);
}

float levelThreeLeafOne(float variable)
{
	return 2.0 * variable;
}
@def_
@def $macro25()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, in conditional expression, pointer
 * to function returning a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 12.0;
	arg_a = dummy1(divide4, i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	float           i;

	if (!TGEN_FLT_EQ((i = (*func) (Float)), 3.0) )
		statusFlag++;
	return i;
}

float divide4(float Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	float           i;

	if (! TGEN_FLT_EQ((i = (*func) (Float)), 6.0) )
		statusFlag++;
	return i;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro26()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, no return value, legal 
 */
{
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
	float           i = variable;
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(i);
}
@def_
@def $macro27()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, no return value, illegal 
 */
{
	float           result;

/*	result = recursiveFunction(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
	extern float    i;
	float           result;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	if (--counter) {
/*		result = recursiveFunction(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
			result++;
	}
	return;
}
@def_
@def $macro28()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	extern float    i;

	i = recursiveFunction(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           i = variable;

	if (--counter) {
		i = recursiveFunction(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro29()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, pointer to function
 * returning a float 
 */
{
	i = dummy(increment, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           i = variable;
	if (--counter) {
		i = dummy(function, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro30()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, function in conditional expression, Float
 * function declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           i = 1.0;
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro31()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, in conditional expression, pointer to
 * function returning a float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy(increment, i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           i = variable;
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro32()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, no return value, legal 
 */
{
	extern float    i;

	i = 1.0;
	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
	float           i = variable + 1.0;

 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter)
		pollux(i);
}

void pollux(float variable)
{
	float           i = variable - 1.0;

 if ( !(TGEN_FLT_EQ(variable, 2.0)) )
		statusFlag++;
	if (--counter)
		castor(i);
}
@def_
@def $macro33()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
static float    i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, no return value, illegal 
 */
{
	extern float    i;
	float           result;

/*	result = castor(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
	static float    i;
	float           result;

	if (! TGEN_FLT_EQ((i = variable + 1.0), 2.0) )
		statusFlag++;
	if (--counter) {
/*		result = pollux(i);*/
 if ( TGEN_FLT_EQ(result, 0.0) )
			result++;
	}
}

void pollux(float variable)
{
	static float    i;
	float           result;

	if (! TGEN_FLT_EQ((i = variable - 1.0), 1.0) )
		statusFlag++;
	if (--counter) {
/*		result = castor(i);}*/
 if ( TGEN_FLT_EQ(result, 0.0) )
			result++;
	}
}
@def_
@def $macro34()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, legal, function declared to return a
 * float 
 */
{
	i = castor(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	float           i = variable + 3.0;

	if (--counter) {
		i = pollux(i);
 if ( !(TGEN_FLT_EQ(i, 5.0)) )
			statusFlag++;
	}
	return ++variable;
}

float pollux(float variable)
{
	float           i = variable - 3.0;

	if (--counter) {
		i = castor(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro35()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, pointer to function returning a
 * float 
 */
{
	extern float    i;

	i = castor(increment, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	float           i = variable + 8.0;
	if (--counter) {
		i = pollux(function, i);
 if ( !(TGEN_FLT_EQ(i, 10.0)) )
			statusFlag++;
	}
	return function(variable);
}

float pollux(float (*function) (float), float variable)
{
	float           i = variable - 8.0;
	if (--counter) {
		i = castor(function, i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro36()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, function declared to
 * return a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = castor(i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	float           i = variable + 3.0;

	if (--counter)
		if (! TGEN_FLT_EQ(pollux(i), 5.0))
			statusFlag++;
	return ++variable;
}

float pollux(float variable)
{
	float           i = variable - 3.0;
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro37()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, pointer to function
 * returning a float 
 */
{
	float           arg_a, arg_b;

	arg_a = castor(increment, i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	float           i = variable + 8.0;
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(function, i);
		arg_b = 10.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float pollux(float (*function) (float), float variable)
{
	float           i = variable - 8.0;
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(function, i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro38()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, no return value and legal 
 */
{
	extern float    i;

	i = 1.0;
	levelOneNodeOne(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	i = 2.0;
	levelOneNodeTwo(i);
 if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	argument++;
	variable11 = 3.0;
	levelTwoNodeOne(variable11);
 if ( !(TGEN_FLT_EQ(variable11, 3.0)) )
		statusFlag++;
	variable11 = 4.0;
	levelTwoNodeTwo(variable11);
 if ( !(TGEN_FLT_EQ(variable11, 4.0)) )
		statusFlag++;
}

void levelOneNodeTwo(float argument)
{
	argument++;
	variable12 = 5.0;
	levelTwoNodeThree(variable12);
 if ( !(TGEN_FLT_EQ(variable12, 5.0)) )
		statusFlag++;
	variable12 = 6.0;
	levelTwoNodeFour(variable12);
 if ( !(TGEN_FLT_EQ(variable12, 6.0)) )
		statusFlag++;
}

void levelTwoNodeOne(float argument)
{
	argument++;
	variable21 = 7.0;
	levelThreeLeafOne(variable21);
 if ( !(TGEN_FLT_EQ(variable21, 7.0)) )
		statusFlag++;
	variable21 = 8.0;
	levelThreeLeafTwo(variable21);
 if ( !(TGEN_FLT_EQ(variable21, 8.0)) )
		statusFlag++;
}

void levelTwoNodeTwo(float argument)
{
	argument++;
	variable22 = 9.0;
	levelThreeLeafThree(variable22);
 if ( !(TGEN_FLT_EQ(variable22, 9.0)) )
		statusFlag++;
	variable22 = 10.0;
	levelThreeLeafFour(variable22);
 if ( !(TGEN_FLT_EQ(variable22, 10.0)) )
		statusFlag++;
}

void levelTwoNodeThree(float argument)
{
	argument++;
	variable23 = 11.0;
	levelThreeLeafFive(variable23);
 if ( !(TGEN_FLT_EQ(variable23, 11.0)) )
		statusFlag++;
	variable23 = 12.0;
	levelThreeLeafSix(variable23);
 if ( !(TGEN_FLT_EQ(variable23, 12.0)) )
		statusFlag++;
}

void levelTwoNodeFour(float argument)
{
	argument++;
	variable24 = 13.0;
	levelThreeLeafSeven(variable24);
 if ( !(TGEN_FLT_EQ(variable24, 13.0)) )
		statusFlag++;
	variable24 = 14.0;
	levelThreeLeafEight(variable24);
 if ( !(TGEN_FLT_EQ(variable24, 14.0)) )
		statusFlag++;
}

void levelThreeLeafOne(float argument)
{
	argument++;
}

void levelThreeLeafTwo(float argument)
{
	argument++;
}

void levelThreeLeafThree(float argument)
{
	argument++;
}

void levelThreeLeafFour(float argument)
{
	argument++;
}

void levelThreeLeafFive(float argument)
{
	argument++;
}

void levelThreeLeafSix(float argument)
{
	argument++;
}

void levelThreeLeafSeven(float argument)
{
	argument++;
}

void levelThreeLeafEight(float argument)
{
	argument++;
}
@def_
@def $macro39()
$LICENSE()
$FHEAD()


float levelOneNodeOne(float);
float levelOneNodeTwo(float);
float levelTwoNodeOne(float);
float levelTwoNodeTwo(float);
float levelTwoNodeThree(float);
float levelTwoNodeFour(float);
float levelThreeLeafOne(float);
float levelThreeLeafTwo(float);
float levelThreeLeafThree(float);
float levelThreeLeafFour(float);
float levelThreeLeafFive(float);
float levelThreeLeafSix(float);
float levelThreeLeafSeven(float);
float levelThreeLeafEight(float);

short           statusFlag = NoMistake;
float           i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, return value and legal,
 * Float function declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	i = 1.0;
	result = levelOneNodeOne(i);
	if ( (! TGEN_FLT_EQ(result, 1.0)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           result = 0.0;

	variable11 = 3.0;
	result = levelTwoNodeOne(variable11);
 if ( !(TGEN_FLT_EQ(variable11, result)) )
		statusFlag++;
	variable11 = 4.0;
	result = levelTwoNodeTwo(variable11);
 if ( !(TGEN_FLT_EQ(variable11, result)) )
		statusFlag++;
	return variable;
}

float levelOneNodeTwo(float variable)
{
	float           result = 0.0;

	variable12 = 5.0;
	result = levelTwoNodeThree(variable12);
 if ( !(TGEN_FLT_EQ(variable12, result)) )
		statusFlag++;
	variable12 = 6.0;
	result = levelTwoNodeFour(variable12);
 if ( !(TGEN_FLT_EQ(variable12, result)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeOne(float variable)
{
	float           result = 0.0;

	variable21 = 7.0;
	result = levelThreeLeafOne(variable21);
 if ( !(TGEN_FLT_EQ(variable21, result)) )
		statusFlag++;
	variable21 = 8.0;
	result = levelThreeLeafTwo(variable21);
 if ( !(TGEN_FLT_EQ(variable21, result)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeTwo(float variable)
{
	float           result = 0.0;

	variable22 = 9.0;
	result = levelThreeLeafThree(variable22);
 if ( !(TGEN_FLT_EQ(variable22, result)) )
		statusFlag++;
	variable22 = 10.0;
	result = levelThreeLeafFour(variable22);
 if ( !(TGEN_FLT_EQ(variable22, result)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeThree(float variable)
{
	float           result = 0.0;

	variable23 = 11.0;
	result = levelThreeLeafFive(variable23);
 if ( !(TGEN_FLT_EQ(variable23, result)) )
		statusFlag++;
	variable23 = 12.0;
	result = levelThreeLeafSix(variable23);
 if ( !(TGEN_FLT_EQ(variable23, result)) )
		statusFlag++;
	return variable;
}

float levelTwoNodeFour(float variable)
{
	float           result = 0.0;

	variable24 = 13.0;
	result = levelThreeLeafSeven(variable24);
 if ( !(TGEN_FLT_EQ(variable24, result)) )
		statusFlag++;
	variable24 = 14.0;
	result = levelThreeLeafEight(variable24);
 if ( !(TGEN_FLT_EQ(variable24, result)) )
		statusFlag++;
	return variable;
}

float levelThreeLeafOne(float variable)
{
	return variable;
}

float levelThreeLeafTwo(float variable)
{
	return variable;
}

float levelThreeLeafThree(float variable)
{
	return variable;
}

float levelThreeLeafFour(float variable)
{
	return variable;
}

float levelThreeLeafFive(float variable)
{
	return variable;
}

float levelThreeLeafSix(float variable)
{
	return variable;
}

float levelThreeLeafSeven(float variable)
{
	return variable;
}

float levelThreeLeafEight(float variable)
{
	return variable;
}
@def_
@def $macro40()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, return value, legal pointer
 * to function returning a float 
 */
{
	extern float    i;
	float           result = 0.0;

	i = 12.0;
	result = dummy1(divide4, i);
	if ( (! TGEN_FLT_EQ(i, 12.0)) || (! TGEN_FLT_EQ(result, 3.0)))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	float           result = 0.0;

	result = (*func) (Float++);
 if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	return result;
}

float divide4(float Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	float           result = 0.0;

	result = (*func) (Float++);
 if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return result;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro41()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float);
float levelTwoNodeOne(float);
float levelThreeLeafOne(float);

short           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, Float function declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = levelOneNodeOne(i);
	arg_b = 32.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float variable)
{
	float           ii;

	ii = 2.0 * variable++;
	return 2.0 * levelTwoNodeOne(ii);
}

float levelTwoNodeOne(float variable)
{
	float           iii;

	iii = 2.0 * variable++;
	return 2.0 * levelThreeLeafOne(iii);
}

float levelThreeLeafOne(float variable)
{
	return 2.0 * variable++;
}
@def_
@def $macro42()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float), float);
float divide4(float);
float dummy2(float (*) (float), float);
float divide2(float);

short           statusFlag = NoMistake;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, in conditional expression,
 * pointer to function returning a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 12.0;
	arg_a = dummy1(divide4, i);
	arg_b = 3.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 12.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float), float Float)
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0) )
		statusFlag++;
	Float++;
	return ii;
}

float divide4(float Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float), float Float)
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	Float++;
	return ii;
}

float divide2(float Float)
{
	return Float / 2.0;
}
@def_
@def $macro43()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, no return value, legal 
 */
{
	extern float    i;

	i = 1.0;
	recursiveFunction(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable++);
}
@def_
@def $macro44()
$LICENSE()
$FHEAD()

void recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, no return value, illegal 
 */
{
	extern float    i;

	recursiveFunction(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float variable)
{
	extern float    i;
	float           ii = 0.0;

	if (! TGEN_FLT_EQ((i = variable), 1.0) )
		statusFlag++;
	if (--counter)
/*		ii = recursiveFunction(i);*/
	variable = ii;
	return;
}
@def_
@def $macro45()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, legal, Float
 * function declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	result = recursiveFunction(i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           result;

	if (--counter) {
		result = recursiveFunction(variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro46()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, pointer to function
 * returning a float 
 */
{
	float           result = 0.0;

	result = dummy(increment, i);
	if ((! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           result;

	if (--counter) {
		result = dummy(function, variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(variable--);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro47()
$LICENSE()
$FHEAD()

float recursiveFunction(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, Float function declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(i);
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(	arg_a, 	arg_b)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float variable)
{
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(variable);
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(variable, 1.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro48()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, in conditional expression, pointer
 * to function returning a float 
 */
{
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = dummy(increment, i);
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float variable)
{
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, variable);
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(variable, 1.0)) )
			statusFlag++;
	}
	return function(variable--);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro49()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, no return value, legal 
 */
{
	extern float    i;

	castor(i);
 if ( !(TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		variable++;
		pollux(variable++);
	}
}

void pollux(float variable)
{
 if ( !(TGEN_FLT_EQ(variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--variable;
		castor(variable--);
	}
}
@def_
@def $macro50()
$LICENSE()
$FHEAD()

void castor(float);
void pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, no return value, illegal 
 */
{
	extern float    i;
	float           result;

/*	result = castor(i);*/
 if (! TGEN_FLT_EQ(i, 1.0) )
		statusFlag++;
 if (! TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float variable)
{
	float           ii;
	extern float    i;

	if (! TGEN_FLT_EQ( (i = variable++), 1.0) )
		statusFlag++;
	if (--counter)
/*		ii = pollux(i);*/
	variable += ii;
	return;
}

void pollux(float variable)
{
	float           iii;
	extern float    i;

	if (! TGEN_FLT_EQ( (i = variable++), 1.0) )
		statusFlag++;
	if (--counter)
/*		iii = castor(i);*/
	variable += iii;
	return;
}
@def_
@def $macro51()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, legal, function declared to
 * return a float 
 */
{
	extern float    i;
	float           result = 0.0;

	i = 1.0;
	result = castor(i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	float           ii = variable + 3.0;

	if (--counter) {
		ii = pollux(ii);
 if ( !(TGEN_FLT_EQ(ii, 5.0)) )
			statusFlag++;
	}
	return ++variable;
}

float pollux(float variable)
{
	float           iii = variable - 3.0;

	if (--counter) {
		iii = castor(iii);
 if ( !(TGEN_FLT_EQ(iii, 2.0)) )
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro52()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, pointer to function
 * returning a float 
 */
{
	float           result = 0.0;

	i = 1.0;
	result = castor(increment, i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	ii = variable + 8.0;
	if (--counter) {
		ii = pollux(function, ii);
 if ( !(TGEN_FLT_EQ(ii, 10.0)) )
			statusFlag++;
	}
	return function(variable);
}

float pollux(float (*function) (float), float variable)
{
	iii = variable - 8.0;
	if (--counter) {
		iii = castor(function, iii);
 if ( !(TGEN_FLT_EQ(iii, 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro53()
$LICENSE()
$FHEAD()

float castor(float);
float pollux(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = castor(i);
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 1.0)) || (! TGEN_FLT_EQ(ii, 4.0)) || (! TGEN_FLT_EQ(iii, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float variable)
{
	extern float    ii;
	float           arg_a, arg_b;

	ii = variable + 3.0;
	if (--counter) {
		arg_a = pollux(ii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}

float pollux(float variable)
{
	extern float    iii;
	float           arg_a, arg_b;

	iii = variable - 3.0;
	if (--counter) {
		arg_a = castor(iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro54()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float);
float pollux(float (*) (float), float);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, pointer to
 * function returning a float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	i = 1.0;
	arg_a = castor(increment, i);
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float variable)
{
	float           ii = variable + 10.0;
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(function, ii);
		arg_b = 12.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(ii, 11.0)) )
			statusFlag++;
	}
	return function(variable++);
}

float pollux(float (*function) (float), float variable)
{
	float           iii = variable - 10.0;
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(function, iii);
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(iii, 1.0)) )
			statusFlag++;
	}
	return function(variable++);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro55()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i;
long            variable;

int main(void)				/* alias root */
/*
 *  test class: extern long variable instance  : linear tree structure, no return value and legal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 1L)
		statusFlag++;
	variable = 3;
	levelTwoNodeOne(variable);
	variable = 4;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 2L)
		statusFlag++;
	variable = 5;
	levelTwoNodeThree(variable);
	variable = 6;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 3L)
		statusFlag++;
	variable = 7;
	levelThreeLeafOne(variable);
	variable = 8;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 4L)
		statusFlag++;
	variable = 9;
	levelThreeLeafThree(variable);
	variable = 10;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 5L)
		statusFlag++;
	variable = 11;
	levelThreeLeafFive(variable);
	variable = 12;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 6L)
		statusFlag++;
	variable = 13;
	levelThreeLeafSeven(variable);
	variable = 14;
	levelThreeLeafEight(variable);
}

void levelThreeLeafOne(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long argument)
{
	extern long     variable;

	variable = argument;
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro56()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i, variable;

int main(void)				/* alias root */
/*
 *  test class: extern long variable instance  : linear tree structure, no return value and illegal 
 */
{
	extern long     i;
	long            result = 0;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 1L)
		statusFlag++;
	variable = 3;
	levelTwoNodeOne(variable);
	variable = 4;
	levelTwoNodeTwo(variable);
	if (result == 0L)
		result++;
}

void levelOneNodeTwo(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 2L)
		statusFlag++;
	variable = 5;
	levelTwoNodeThree(variable);
	variable = 6;
	levelTwoNodeFour(variable);
	if (result == 0L)
		result++;
}

void levelTwoNodeOne(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 3L)
		statusFlag++;
	variable = 7;
	levelThreeLeafOne(variable);
	variable = 8;
	levelThreeLeafTwo(variable);
	if (result == 0L)
		result++;
}

void levelTwoNodeTwo(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 4L)
		statusFlag++;
	variable = 9;
	levelThreeLeafThree(variable);
	variable = 10;
	levelThreeLeafFour(variable);
	if (result == 0L)
		result++;
}

void levelTwoNodeThree(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 5L)
		statusFlag++;
	variable = 11;
	levelThreeLeafFive(variable);
	variable = 12;
	levelThreeLeafSix(variable);
	if (result == 0L)
		result++;
}

void levelTwoNodeFour(long argument)
{
	long            result;
	extern long     variable;

	if ((variable = argument) != 6L)
		statusFlag++;
	variable = 13;
	levelThreeLeafSeven(variable);
	variable = 14;
	levelThreeLeafEight(variable);
	if (result == 0L)
		result++;
}

void levelThreeLeafOne(long argument)
{
	extern long     variable;

	if ((variable = argument) != 7L)
		statusFlag++;
	return;
}

void levelThreeLeafTwo(long argument)
{
	extern long     variable;

	if ((variable = argument) != 8L)
		statusFlag++;
	return;
}

void levelThreeLeafThree(long argument)
{
	extern long     variable;

	if ((variable = argument) != 9L)
		statusFlag++;
	return;
}

void levelThreeLeafFour(long argument)
{
	extern long     variable;

	if ((variable = argument) != 10L)
		statusFlag++;
	return;
}

void levelThreeLeafFive(long argument)
{
	extern long     variable;

	if ((variable = argument) != 11L)
		statusFlag++;
	return;
}

void levelThreeLeafSix(long argument)
{
	extern long     variable;

	if ((variable = argument) != 12L)
		statusFlag++;
	return;
}

void levelThreeLeafSeven(long argument)
{
	extern long     variable;

	if ((variable = argument) != 13L)
		statusFlag++;
	return;
}

void levelThreeLeafEight(long argument)
{
	extern long     variable;

	if ((variable = argument) != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro57()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, return value and legal, Long function declaration 
 */
{
	extern long     i;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1L)
		statusFlag++;
	i = 2;
	i = levelOneNodeTwo(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            storage = variable;

	variable = 3;
	variable = levelTwoNodeOne(variable);
	if (variable != 3L)
		statusFlag++;
	variable = 4;
	variable = levelTwoNodeTwo(variable);
	if (variable != 4L)
		statusFlag++;
	return storage;
}

long levelOneNodeTwo(long variable)
{
	long            storage = variable;

	variable = 5;
	variable = levelTwoNodeThree(variable);
	if (variable != 5L)
		statusFlag++;
	variable = 6;
	variable = levelTwoNodeFour(variable);
	if (variable != 6L)
		statusFlag++;
	return storage;
}

long levelTwoNodeOne(long variable)
{
	long            storage = variable;

	variable = 7;
	variable = levelThreeLeafOne(variable);
	if (variable != 7L)
		statusFlag++;
	variable = 8;
	variable = levelThreeLeafTwo(variable);
	if (variable != 8L)
		statusFlag++;
	return storage;
}

long levelTwoNodeTwo(long variable)
{
	long            storage = variable;

	variable = 9;
	variable = levelThreeLeafThree(variable);
	if (variable != 9L)
		statusFlag++;
	variable = 10;
	variable = levelThreeLeafFour(variable);
	if (variable != 10L)
		statusFlag++;
	return storage;
}

long levelTwoNodeThree(long variable)
{
	long            storage = variable;

	variable = 11;
	variable = levelThreeLeafFive(variable);
	if (variable != 11L)
		statusFlag++;
	variable = 12;
	variable = levelThreeLeafSix(variable);
	if (variable != 12L)
		statusFlag++;
	return storage;
}

long levelTwoNodeFour(long variable)
{
	long            storage = variable;

	variable = 13;
	variable = levelThreeLeafSeven(variable);
	if (variable != 13L)
		statusFlag++;
	variable = 14;
	variable = levelThreeLeafEight(variable);
	if (variable != 14L)
		statusFlag++;
	return storage;
}

long levelThreeLeafOne(long variable)
{
	return variable;
}

long levelThreeLeafTwo(long variable)
{
	return variable;
}

long levelThreeLeafThree(long variable)
{
	return variable;
}

long levelThreeLeafFour(long variable)
{
	return variable;
}

long levelThreeLeafFive(long variable)
{
	return variable;
}

long levelThreeLeafSix(long variable)
{
	return variable;
}

long levelThreeLeafSeven(long variable)
{
	return variable;
}

long levelThreeLeafEight(long variable)
{
	return variable;
}
@def_
@def $macro58()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, return value, legal pointer to function returning a long 
 */
{
	extern long     i;

	i = 12;
	i = dummy1(divide4, i);
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	extern long     i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return i;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	extern long     i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return i;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro59()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, used in conditional expression, Long function declaration 
 */
{
	extern long     i;

	i = 1;
	if (!(levelOneNodeOne(i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            ii;

	ii = 2 * variable;
	return 2 * levelTwoNodeOne(ii);
}

long levelTwoNodeOne(long variable)
{
	long            iii;

	iii = 2 * variable;
	return 2 * levelThreeLeafOne(iii);
}

long levelThreeLeafOne(long variable)
{
	return 2 * variable;
}
@def_
@def $macro60()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, in conditional expression, pointer to function returning a
 * long 
 */
{
	extern long     i;

	i = 12;
	if (dummy1(divide4, i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return ii;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return ii;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro61()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, no return value, legal 
 */
{
	extern long     i;

	i = 1;
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro62()
$LICENSE()
$HEAD()

int recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, no return value, illegal 
 */
{
	extern long     i;

	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(long variable)
{
	long            ii;
	extern long     i;

	if ((i = variable) != 1L)
		statusFlag++;
	if (--counter) {
		ii = recursiveFunction(i);
		if (ii == 0L)
			ii++;
	}
	return;
}
@def_
@def $macro63()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, legal, Long function declaration 
 */
{
	extern long     i;

	i = recursiveFunction(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	long            result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro64()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, pointer to function returning a long 
 */
{
	i = dummy(increment, i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro65()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, function in conditional expression, Long function declaration 
 */
{
	extern long     i;

	if (!(recursiveFunction(i) - i == 1L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - variable == 1L))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro66()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, in conditional expression, pointer to function returning a long 
 */
{
	i = 1;
	if (!(dummy(increment, i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            dummy();
	if (--counter)
		if (!(dummy(function, variable) == 2L))
			statusFlag++;
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro67()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : gemini, no return value, legal 
 */
{
	extern long     i;

	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		variable++;
		pollux(variable);
	}
}

void pollux(long variable)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		--variable;
		castor(variable);
	}
}
@def_
@def $macro68()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : gemini, no return value, illegal 
 */
{
	extern long     i;
	long            result;

	castor(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	extern long     i;
	long            ii;

	if ((i = variable) != 1L)
		statusFlag++;
	if (--counter) {
		 pollux(i);
		if (ii == 0L)
			ii++;
	}
}

void pollux(long variable)
{
	extern long     i;
	long            iii;

	if ((i = variable) != 1L)
		statusFlag++;
	if (--counter) {
		castor(i);
		if (iii == 0L)
			iii++;
	}
}
@def_
@def $macro69()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, legal, function declared to return a long 
 */
{
	extern long     i;

	i = 1;
	i = castor(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	long            ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	long            iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro70()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, pointer to function returning a long 
 */
{
	i = castor(increment, i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            ii = variable + 8;
	if (--counter) {
		ii = pollux(function, ii);
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            iii = variable - 8;
	if (--counter) {
		iii = castor(function, iii);
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro71()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	extern long     i;

	if (!(castor(i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	extern long     ii;

	ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5L))
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	extern long     iii;

	iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2L))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro72()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{
	extern long     i;

	i = 1;
	if (!(castor(increment, i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            ii = variable + 10;
	if (--counter) {
		if (!(pollux(function, ii) == 12L))
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            iii = variable - 10;
	if (--counter) {
		if (!(castor(function, iii) == 2L))
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro73()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, no return value and legal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 3;
	levelTwoNodeOne(i);
	i = 4;
	levelTwoNodeTwo(i);
	variable++;
}

void levelOneNodeTwo(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 5;
	levelTwoNodeThree(i);
	i = 6;
	levelTwoNodeFour(i);
	variable++;
}

void levelTwoNodeOne(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 7;
	levelThreeLeafOne(i);
	i = 8;
	levelThreeLeafTwo(i);
	variable++;
}

void levelTwoNodeTwo(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 9;
	levelThreeLeafThree(i);
	i = 10;
	levelThreeLeafFour(i);
	variable++;
}

void levelTwoNodeThree(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 11;
	levelThreeLeafFive(i);
	i = 12;
	levelThreeLeafSix(i);
	variable++;
}

void levelTwoNodeFour(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	i = 13;
	levelThreeLeafSeven(i);
	i = 14;
	levelThreeLeafEight(i);
	variable++;
}

void levelThreeLeafOne(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafTwo(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafThree(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafFour(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafFive(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafSix(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafSeven(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}

void levelThreeLeafEight(long variable)
{
	long            i = 0;
	if (i != 0L)
		statusFlag++;
	variable++;
}
@def_
@def $macro74()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i, whatIsThis;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, no return value and illegal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (whatIsThis == 0L)
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	extern long     i;

	if ((i = variable) != 1L)
		statusFlag++;
	i = 3;
	levelTwoNodeOne(i);
	i = 4;
	levelTwoNodeTwo(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelOneNodeTwo(long variable)
{
	extern long     i;

	if ((i = variable) != 2L)
		statusFlag++;
	i = 5;
	levelTwoNodeThree(i);
	i = 6;
	levelTwoNodeFour(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelTwoNodeOne(long variable)
{
	extern long     i;

	if ((i = variable) != 3L)
		statusFlag++;
	i = 7;
	levelThreeLeafOne(i);
	i = 8;
	levelThreeLeafTwo(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelTwoNodeTwo(long variable)
{
	extern long     i;

	if ((i = variable) != 4L)
		statusFlag++;
	i = 9;
	levelThreeLeafThree(i);
	i = 10;
	levelThreeLeafFour(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelTwoNodeThree(long variable)
{
	extern long     i;

	if ((i = variable) != 5L)
		statusFlag++;
	i = 11;
	levelThreeLeafFive(i);
	i = 12;
	levelThreeLeafSix(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelTwoNodeFour(long variable)
{
	long            i;

	if ((i = variable) != 6L)
		statusFlag++;
	i = 13;
	levelThreeLeafSeven(i);
	i = 14;
	levelThreeLeafEight(i);
	if (whatIsThis == 0L)
		whatIsThis++;
}

void levelThreeLeafOne(long variable)
{
	variable++;
	return;
}

void levelThreeLeafTwo(long variable)
{
	variable++;
	return;
}

void levelThreeLeafThree(long variable)
{
	variable++;
	return;
}

void levelThreeLeafFour(long variable)
{
	variable++;
	return;
}

void levelThreeLeafFive(long variable)
{
	variable++;
	return;
}

void levelThreeLeafSix(long variable)
{
	variable++;
	return;
}

void levelThreeLeafSeven(long variable)
{
	variable++;
	return;
}

void levelThreeLeafEight(long variable)
{
	variable++;
	return;
}
@def_
@def $macro75()
$LICENSE()
$HEAD()


long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, return value and legal, Long
 * function declaration 
 */
{
	i = levelOneNodeOne(i);
	if (i != 1L)
		statusFlag++;
	i++;
	i = levelOneNodeTwo(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            i = 3;

	if (variable != 1L)
		statusFlag++;
	i = levelTwoNodeOne(i);
	if (i != 3L)
		statusFlag++;
	i++;
	i = levelTwoNodeTwo(i);
	if (i != 4L)
		statusFlag++;
	return variable;
}

long levelOneNodeTwo(long variable)
{
	long            i = 5;

	if (variable != 2L)
		statusFlag++;
	i = levelTwoNodeThree(i);
	if (i != 5L)
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
	if (i != 6L)
		statusFlag++;
	return variable;
}

long levelTwoNodeOne(long variable)
{
	long            i = 7;

	if (variable != 3L)
		statusFlag++;
	i = levelThreeLeafOne(i);
	if (i != 7L)
		statusFlag++;
	i++;
	i = levelThreeLeafTwo(i);
	if (i != 8L)
		statusFlag++;
	return variable;
}

long levelTwoNodeTwo(long variable)
{
	long            i = 9;

	if (variable != 4L)
		statusFlag++;
	i = levelThreeLeafThree(i);
	if (i != 9L)
		statusFlag++;
	i++;
	i = levelThreeLeafFour(i);
	if (i != 10L)
		statusFlag++;
	return variable;
}

long levelTwoNodeThree(long variable)
{
	long            i = 11;

	if (variable != 5L)
		statusFlag++;
	i = levelThreeLeafFive(i);
	if (i != 11L)
		statusFlag++;
	i++;
	i = levelThreeLeafSix(i);
	if (i != 12L)
		statusFlag++;
	return variable;
}

long levelTwoNodeFour(long variable)
{
	long            i = 13;

	if (variable != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(i);
	if (i != 13L)
		statusFlag++;
	i++;
	i = levelThreeLeafEight(i);
	if (i != 14L)
		statusFlag++;
	return variable;
}

long levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
	return variable;
}

long levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
	return variable;
}

long levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
	return variable;
}

long levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
	return variable;
}

long levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
	return variable;
}

long levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
	return variable;
}

long levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
	return variable;
}

long levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
	return variable;
}
@def_
@def $macro76()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	extern long     i;

	i = 12;
	i = dummy1(divide4, i);
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return i;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return i;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro77()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

short           statusFlag = NoMistake;
long            i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, used in conditional expression,
 * Long function declaration 
 */
{
	if (!(levelOneNodeOne(i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            i;

	i = 2 * variable;
	return 2 * levelTwoNodeOne(i);
}

long levelTwoNodeOne(long variable)
{
	long            i;

	i = 2 * variable;
	return 2 * levelThreeLeafOne(i);
}

long levelThreeLeafOne(long variable)
{
	return 2 * variable;
}
@def_
@def $macro78()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, in conditional expression, pointer
 * to function returning a long 
 */
{
	extern long     i;

	i = 12;
	if (dummy1(divide4, i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            i;

	if ((i = (*func) (Long)) != 3L)
		statusFlag++;
	return i;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            i;

	if ((i = (*func) (Long)) != 6L)
		statusFlag++;
	return i;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro79()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, no return value, legal 
 */
{
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	long            i = variable;
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(i);
}
@def_
@def $macro80()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, no return value, illegal 
 */
{
	long            result;

	recursiveFunction(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	extern long     i;
	long            result;

	if ((i = variable) != 1L)
		statusFlag++;
	if (--counter) {
		recursiveFunction(i);
		if (result == 0L)
			result++;
	}
	return;
}
@def_
@def $macro81()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	extern long     i;

	i = recursiveFunction(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	long            i = variable;

	if (--counter) {
		i = recursiveFunction(i);
		if (i != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro82()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	i = dummy(increment, i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            i = variable;
	if (--counter) {
		i = dummy(function, i);
		if (i != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro83()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	extern long     i;

	if (!(recursiveFunction(i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	long            i = 1;

	if (--counter)
		if (!(recursiveFunction(i) == 2L))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro84()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	if (!(dummy(increment, i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            i = variable;
	if (--counter)
		if (!(dummy(function, i) == 2L))
			statusFlag++;
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro85()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, no return value, legal 
 */
{
	extern long     i;

	i = 1;
	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	long            i = variable + 1;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		pollux(i);
}

void pollux(long variable)
{
	long            i = variable - 1;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		castor(i);
}
@def_
@def $macro86()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
static long     i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, no return value, illegal 
 */
{
	extern long     i;
	long            result;

	castor(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	static long     i;
	long            result;

	if ((i = variable + 1) != 2L)
		statusFlag++;
	if (--counter) {
		pollux(i);
		if (result == 0L)
			result++;
	}
}

void pollux(long variable)
{
	static long     i;
	long            result;

	if ((i = variable - 1) != 1L)
		statusFlag++;
	if (--counter) {
		castor(i);
		if (result == 0L)
			result++;
	}
}
@def_
@def $macro87()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, legal, function declared to return a
 * long 
 */
{
	i = castor(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	long            i = variable + 3;

	if (--counter) {
		i = pollux(i);
		if (i != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	long            i = variable - 3;

	if (--counter) {
		i = castor(i);
		if (i != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro88()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, pointer to function returning a long 
 */
{
	extern long     i;

	i = castor(increment, i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            i = variable + 8;
	if (--counter) {
		i = pollux(function, i);
		if (i != 10L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            i = variable - 8;
	if (--counter) {
		i = castor(function, i);
		if (i != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro89()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	extern long     i;

	i = 1;
	if (!(castor(i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	long            i = variable + 3;

	if (--counter)
		if (!(pollux(i) == 5L))
			statusFlag++;
	return ++variable;
}

long pollux(long variable)
{
	long            i = variable - 3;

	if (--counter)
		if (!(castor(i) == 2L))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro90()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	if (!(castor(increment, i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            i = variable + 8;

	if (--counter)
		if (!(pollux(function, i) == 10L))
			statusFlag++;
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            i = variable - 8;

	if (--counter)
		if (!(castor(function, i) == 2L))
			statusFlag++;
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro91()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, no return value and legal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(i);
	if (i != 1L)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	argument++;
	variable11 = 3;
	levelTwoNodeOne(variable11);
	if (variable11 != 3L)
		statusFlag++;
	variable11 = 4;
	levelTwoNodeTwo(variable11);
	if (variable11 != 4L)
		statusFlag++;
}

void levelOneNodeTwo(long argument)
{
	argument++;
	variable12 = 5;
	levelTwoNodeThree(variable12);
	if (variable12 != 5L)
		statusFlag++;
	variable12 = 6;
	levelTwoNodeFour(variable12);
	if (variable12 != 6L)
		statusFlag++;
}

void levelTwoNodeOne(long argument)
{
	argument++;
	variable21 = 7;
	levelThreeLeafOne(variable21);
	if (variable21 != 7L)
		statusFlag++;
	variable21 = 8;
	levelThreeLeafTwo(variable21);
	if (variable21 != 8L)
		statusFlag++;
}

void levelTwoNodeTwo(long argument)
{
	argument++;
	variable22 = 9;
	levelThreeLeafThree(variable22);
	if (variable22 != 9L)
		statusFlag++;
	variable22 = 10;
	levelThreeLeafFour(variable22);
	if (variable22 != 10L)
		statusFlag++;
}

void levelTwoNodeThree(long argument)
{
	argument++;
	variable23 = 11;
	levelThreeLeafFive(variable23);
	if (variable23 != 11L)
		statusFlag++;
	variable23 = 12;
	levelThreeLeafSix(variable23);
	if (variable23 != 12L)
		statusFlag++;
}

void levelTwoNodeFour(long argument)
{
	argument++;
	variable24 = 13;
	levelThreeLeafSeven(variable24);
	if (variable24 != 13L)
		statusFlag++;
	variable24 = 14;
	levelThreeLeafEight(variable24);
	if (variable24 != 14L)
		statusFlag++;
}

void levelThreeLeafOne(long argument)
{
	argument++;
}

void levelThreeLeafTwo(long argument)
{
	argument++;
}

void levelThreeLeafThree(long argument)
{
	argument++;
}

void levelThreeLeafFour(long argument)
{
	argument++;
}

void levelThreeLeafFive(long argument)
{
	argument++;
}

void levelThreeLeafSix(long argument)
{
	argument++;
}

void levelThreeLeafSeven(long argument)
{
	argument++;
}

void levelThreeLeafEight(long argument)
{
	argument++;
}
@def_
@def $macro92()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, return value and legal,
 * Long function declaration 
 */
{
	extern long     i;
	long            result = 0;

	i = 1;
	result = levelOneNodeOne(i);
	if (result != 1L || i != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(i);
	if (result != 2L || i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            result = 0;

	variable11 = 3;
	result = levelTwoNodeOne(variable11);
	if (variable11 != result)
		statusFlag++;
	variable11 = 4;
	result = levelTwoNodeTwo(variable11);
	if (variable11 != result)
		statusFlag++;
	return variable;
}

long levelOneNodeTwo(long variable)
{
	long            result = 0;

	variable12 = 5;
	result = levelTwoNodeThree(variable12);
	if (variable12 != result)
		statusFlag++;
	variable12 = 6;
	result = levelTwoNodeFour(variable12);
	if (variable12 != result)
		statusFlag++;
	return variable;
}

long levelTwoNodeOne(long variable)
{
	long            result = 0;

	variable21 = 7;
	result = levelThreeLeafOne(variable21);
	if (variable21 != result)
		statusFlag++;
	variable21 = 8;
	result = levelThreeLeafTwo(variable21);
	if (variable21 != result)
		statusFlag++;
	return variable;
}

long levelTwoNodeTwo(long variable)
{
	long            result = 0;

	variable22 = 9;
	result = levelThreeLeafThree(variable22);
	if (variable22 != result)
		statusFlag++;
	variable22 = 10;
	result = levelThreeLeafFour(variable22);
	if (variable22 != result)
		statusFlag++;
	return variable;
}

long levelTwoNodeThree(long variable)
{
	long            result = 0;

	variable23 = 11;
	result = levelThreeLeafFive(variable23);
	if (variable23 != result)
		statusFlag++;
	variable23 = 12;
	result = levelThreeLeafSix(variable23);
	if (variable23 != result)
		statusFlag++;
	return variable;
}

long levelTwoNodeFour(long variable)
{
	long            result = 0;

	variable24 = 13;
	result = levelThreeLeafSeven(variable24);
	if (variable24 != result)
		statusFlag++;
	variable24 = 14;
	result = levelThreeLeafEight(variable24);
	if (variable24 != result)
		statusFlag++;
	return variable;
}

long levelThreeLeafOne(long variable)
{
	return variable;
}

long levelThreeLeafTwo(long variable)
{
	return variable;
}

long levelThreeLeafThree(long variable)
{
	return variable;
}

long levelThreeLeafFour(long variable)
{
	return variable;
}

long levelThreeLeafFive(long variable)
{
	return variable;
}

long levelThreeLeafSix(long variable)
{
	return variable;
}

long levelThreeLeafSeven(long variable)
{
	return variable;
}

long levelThreeLeafEight(long variable)
{
	return variable;
}
@def_
@def $macro93()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, return value, legal pointer
 * to function returning a long 
 */
{
	extern long     i;
	long            result = 0;

	i = 12;
	result = dummy1(divide4, i);
	if (i != 12L || result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            result = 0;

	result = (*func) (Long++);
	if (result != 3L)
		statusFlag++;
	return result;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            result = 0;

	result = (*func) (Long++);
	if (result != 6L)
		statusFlag++;
	return result;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro94()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	extern long     i;

	i = 1;
	if (levelOneNodeOne(i) != 32L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            ii;

	ii = 2 * variable++;
	return 2 * levelTwoNodeOne(ii);
}

long levelTwoNodeOne(long variable)
{
	long            iii;

	iii = 2 * variable++;
	return 2 * levelThreeLeafOne(iii);
}

long levelThreeLeafOne(long variable)
{
	return 2 * variable++;
}
@def_
@def $macro95()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, in conditional expression,
 * pointer to function returning a long 
 */
{
	extern long     i;

	i = 12;
	if (dummy1(divide4, i) != 3L || i != 12L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	Long++;
	return ii;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	Long++;
	return ii;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro96()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, no return value, legal 
 */
{
	extern long     i;

	i = 1;
	recursiveFunction(i);
	if (i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable++);
}
@def_
@def $macro97()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, no return value, illegal 
 */
{
	extern long     i;

	recursiveFunction(i);
	if (i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	extern long     i;
	long            ii = 0;

	if ((i = variable) != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(i);
	variable = ii;
	return;
}
@def_
@def $macro98()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	extern long     i;
	long            result = 0;

	result = recursiveFunction(i);
	if (result != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	long            result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro99()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	long            result = 0;

	result = dummy(increment, i);
	if (result != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            result;
	if (--counter) {
		result = dummy(function, variable);
		if (result != 2L)
			statusFlag++;
	}
	return function(variable--);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro100()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	extern long     i;

	if (recursiveFunction(i) != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	if (--counter)
		if (recursiveFunction(variable) != 2L || variable != 1L)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro101()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, in conditional expression, pointer
 * to function returning a long 
 */
{
	i = 1;
	if (dummy(increment, i) != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	if (--counter)
		if (dummy(function, variable) != 2L || variable != 1L)
			statusFlag++;
	return function(variable--);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro102()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, no return value, legal 
 */
{
	extern long     i;

	castor(i);
	if (i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		variable++;
		pollux(variable++);
	}
}

void pollux(long variable)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		--variable;
		castor(variable--);
	}
}
@def_
@def $macro103()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, no return value, illegal 
 */
{
	extern long     i;
	long            result;

	castor(i);
	if (i != 1L)
		statusFlag++;
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	long            ii;
	extern long     i;

	if ((i = variable++) != 1L)
		statusFlag++;
	if (--counter)
		pollux(i);
	variable += ii;
	return;
}

void pollux(long variable)
{
	long            iii;
	extern long     i;

	if ((i = variable++) != 1L)
		statusFlag++;
	if (--counter)
		castor(i);
	variable += iii;
	return;
}
@def_
@def $macro104()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	extern long     i;
	long            result = 0;

	i = 1;
	result = castor(i);
	if (result != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	long            ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	long            iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro105()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	long            result = 0;

	i = 1;
	result = castor(increment, i);
	if (result != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	ii = variable + 8;
	if (--counter) {
		ii = pollux(function, ii);
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	iii = variable - 8;
	if (--counter) {
		iii = castor(function, iii);
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro106()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	extern long     i;

	if (castor(i) != 2L || i != 1L || ii != 4L || iii != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	extern long     ii;

	ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5L))
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	extern long     iii;

	iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2L))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro107()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	extern long     i;

	i = 1;
	if (castor(increment, i) != 2L || i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            ii = variable + 10;
	long            pollux();
	if (--counter) {
		if (pollux(function, ii) != 12L || ii != 11L)
			statusFlag++;
	}
	return function(variable++);
}

long pollux(long (*function) (long), long variable)
{
	long            iii = variable - 10;
	if (--counter) {
		if (castor(function, iii) != 2L || iii != 1L)
			statusFlag++;
	}
	return function(variable++);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro108()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	extern short    i;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           storage = variable;

	variable += 2;
	variable = levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable++;
	variable = levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(short variable)
{
	short           storage = variable;

	variable += 3;
	variable = levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable++;
	variable = levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(short variable)
{
	short           storage = variable;

	variable += 4;
	variable = levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable++;
	variable = levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(short variable)
{
	short           storage = variable;

	variable += 5;
	variable = levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable++;
	variable = levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(short variable)
{
	short           storage = variable;

	variable += 6;
	variable = levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable++;
	variable = levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(short variable)
{
	short           storage = variable;

	variable += 7;
	variable = levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable++;
	variable = levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro109()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, return value and legal, integer function declaration 
 */
{
	extern short    i;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           storage = variable;

	variable = 3;
	variable = levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable = 4;
	variable = levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(short variable)
{
	short           storage = variable;

	variable = 5;
	variable = levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable = 6;
	variable = levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(short variable)
{
	short           storage = variable;

	variable = 7;
	variable = levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable = 8;
	variable = levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(short variable)
{
	short           storage = variable;

	variable = 9;
	variable = levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable = 10;
	variable = levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(short variable)
{
	short           storage = variable;

	variable = 11;
	variable = levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable = 12;
	variable = levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(short variable)
{
	short           storage = variable;

	variable = 13;
	variable = levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable = 14;
	variable = levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(short variable)
{
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	return variable;
}

short levelThreeLeafThree(short variable)
{
	return variable;
}

short levelThreeLeafFour(short variable)
{
	return variable;
}

short levelThreeLeafFive(short variable)
{
	return variable;
}

short levelThreeLeafSix(short variable)
{
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro110()
$LICENSE()
$HEAD()

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           i, j, k;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 1;
	s = levelOne(i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable)
{
	char           *s;
	extern short    j;

	if (variable != 1)
		statusFlag++;
	j = 2;
	s = levelTwo(j);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char *levelTwo(short variable)
{
	char           *s;
	extern short    k;

	if (variable != 2)
		statusFlag++;
	k = 3;
	s = levelThree(k);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char *levelThree(short variable)
{
	char           *s;
	short           l;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro111()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	extern short    i;

	i = 12;
	i = dummy1(divide4, i);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	extern short    i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	extern short    i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro112()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i, j;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, used in conditional expression, no function declaration 
 */
{
	extern short    i, j;

	i = 1;
	j = i++;
	if (!(levelOneNodeOne(j) + levelOneNodeTwo(i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           ii, jj;
	jj = (ii = ++variable) + 1;
	return levelTwoNodeOne(ii) + levelTwoNodeTwo(jj);
}

int levelOneNodeTwo(short variable)
{
	short           iii, jjj;
	jjj = (iii = ++variable) + 1;
	return levelTwoNodeThree(iii) + levelTwoNodeFour(jjj);
}

int levelTwoNodeOne(short variable)
{
	short           iiii, jjjj;
	jjjj = (iiii = ++variable) + 1;
	return levelThreeLeafOne(iiii) + levelThreeLeafTwo(jjjj);
}

int levelTwoNodeTwo(short variable)
{
	short           iiiii, jjjjj;
	jjjjj = (iiiii = ++variable) + 1;
	return levelThreeLeafThree(iiiii) + levelThreeLeafFour(jjjjj);
}

int levelTwoNodeThree(short variable)
{
	short           iiiiii, jjjjjj;
	jjjjjj = (iiiiii = ++variable) + 1;
	return levelThreeLeafFive(iiiiii) + levelThreeLeafSix(jjjjjj);
}

int levelTwoNodeFour(short variable)
{
	short           iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = ++variable) + 1;
	return levelThreeLeafSeven(iiiiiii) + levelThreeLeafEight(jjjjjjj);
}

int levelThreeLeafOne(short variable)
{
	return ++variable;
}

int levelThreeLeafTwo(short variable)
{
	return ++variable;
}

int levelThreeLeafThree(short variable)
{
	return ++variable;
}

int levelThreeLeafFour(short variable)
{
	return ++variable;
}

int levelThreeLeafFive(short variable)
{
	return ++variable;
}

int levelThreeLeafSix(short variable)
{
	return ++variable;
}

int levelThreeLeafSeven(short variable)
{
	return ++variable;
}

int levelThreeLeafEight(short variable)
{
	return ++variable;
}
@def_
@def $macro113()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	extern short    i;

	i = 1;
	if (!(levelOneNodeOne(i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           ii;

	ii = 2 * variable;
	return 2 * levelTwoNodeOne(ii);
}

short levelTwoNodeOne(short variable)
{
	short           iii;

	iii = 2 * variable;
	return 2 * levelThreeLeafOne(iii);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro114()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            i = 4, j = 8;

int main(void)				/* alias root */
/*
 *  test class: extern variable instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{
	extern char     i, j;

	if (compare(skip(i), "andra", 5) == compare(skip(j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < skipper; ii++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro115()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: extern variable instance  : linear tree structure, in conditional expression, pointer to function returning
 * an integer 
 */
{
	extern short    i;

	i = 12;
	if (dummy1(divide4, i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return ii;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return ii;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro116()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, legal, no function declaration 
 */
{
	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro117()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, legal, integer function declaration 
 */
{
	extern short    i;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro118()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, function declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 2;
	s = recursiveFunction(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro119()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	i = dummy(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           result;
	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro120()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, j;

int main(void)
/*
 * test class: extern variable instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	extern short    j;

	j = variable;
	if (--counter)
		if (!(recursiveFunction(j) - j == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro121()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : recursive call, function in conditional expression, integer function declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - variable == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro122()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, in conditional expression, function declared to return a pointer
 * to character 
 */
{
	extern char    *numbers;
	extern short    i;

	i = 2;
	if (!(*recursiveFunction(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	if (--counter)
		if (!(*recursiveFunction(variable) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro123()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{
	i = 1;
	if (!(dummy(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	if (--counter)
		if (!(dummy(function, variable) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro124()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, legal, no function declaration 
 */
{
	i = 1;
	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	ii = variable + 3;
	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	iii = variable - 3;
	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro125()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	extern short    i;

	i = 1;
	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	short           ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	short           iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro126()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 2;
	s = castor(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	short           ii = variable + 4;
	char           *s;

	if (--counter) {
		s = pollux(ii);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	short           iii = variable - 4;
	char           *s;

	if (--counter) {
		s = castor(iii);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro127()
$LICENSE()
$HEAD()


int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : gemini, return value, pointer to function returning an integer 
 */
{
	i = castor(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           ii = variable + 8;
	if (--counter) {
		ii = pollux(function, ii);
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	short           iii = variable - 8;
	if (--counter) {
		iii = castor(function, iii);
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro128()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	short           ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	short           iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro129()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	extern short    i;

	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	extern short    ii;

	ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	extern short    iii;

	iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro130()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
static short    i, ii, iii;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{
	extern short    i;

	i = 2;
	if (!(*castor(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	extern short    ii;

	ii = variable + 4;
	if (--counter) {
		if (!(*pollux(ii) == '6'))
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	extern short    iii;

	iii = variable - 4;
	if (--counter) {
		if (!(*castor(iii) == '2'))
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro131()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{
	extern short    i;

	i = 1;
	if (!(castor(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           ii = variable + 10;
	if (--counter) {
		if (!(pollux(function, ii) == 12))
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	short           iii = variable - 10;
	if (--counter) {
		if (!(castor(function, iii) == 2))
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro132()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	extern short    i;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	++i;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           i = variable + 2;

	if (variable != 1)
		statusFlag++;
	i = levelTwoNodeOne(i);
	if (i != 3)
		statusFlag++;
	++i;
	i = levelTwoNodeTwo(i);
	if (i != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	short           i = variable + 3;

	if (variable != 2)
		statusFlag++;
	i = levelTwoNodeThree(i);
	if (i != 5)
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
	if (i != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	short           i = variable + 4;

	if (variable != 3)
		statusFlag++;
	i = levelThreeLeafOne(i);
	if (i != 7)
		statusFlag++;
	++i;
	i = levelThreeLeafTwo(i);
	if (i != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	short           i = variable + 5;

	if (variable != 4)
		statusFlag++;
	i = levelThreeLeafThree(i);
	if (i != 9)
		statusFlag++;
	++i;
	i = levelThreeLeafFour(i);
	if (i != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	short           i = variable + 6;

	if (variable != 5)
		statusFlag++;
	i = levelThreeLeafFive(i);
	if (i != 11)
		statusFlag++;
	++i;
	i = levelThreeLeafSix(i);
	if (i != 12)
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	short           i = variable + 7;

	if (variable != 6)
		statusFlag++;
	i = levelThreeLeafSeven(i);
	if (i != 13)
		statusFlag++;
	++i;
	i = levelThreeLeafEight(i);
	if (i != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	if (variable != 7)
		statusFlag++;
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	if (variable != 8)
		statusFlag++;
	return variable;
}

int levelThreeLeafThree(short variable)
{
	if (variable != 9)
		statusFlag++;
	return variable;
}

int levelThreeLeafFour(short variable)
{
	if (variable != 10)
		statusFlag++;
	return variable;
}

int levelThreeLeafFive(short variable)
{
	if (variable != 11)
		statusFlag++;
	return variable;
}

int levelThreeLeafSix(short variable)
{
	if (variable != 12)
		statusFlag++;
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	if (variable != 13)
		statusFlag++;
	return variable;
}

int levelThreeLeafEight(short variable)
{
	if (variable != 14)
		statusFlag++;
	return variable;
}
@def_
@def $macro133()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i++;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           i = 3;

	if (variable != 1)
		statusFlag++;
	i = levelTwoNodeOne(i);
	if (i != 3)
		statusFlag++;
	i++;
	i = levelTwoNodeTwo(i);
	if (i != 4)
		statusFlag++;
	return variable;
}

short levelOneNodeTwo(short variable)
{
	short           i = 5;

	if (variable != 2)
		statusFlag++;
	i = levelTwoNodeThree(i);
	if (i != 5)
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
	if (i != 6)
		statusFlag++;
	return variable;
}

short levelTwoNodeOne(short variable)
{
	short           i = 7;

	if (variable != 3)
		statusFlag++;
	i = levelThreeLeafOne(i);
	if (i != 7)
		statusFlag++;
	i++;
	i = levelThreeLeafTwo(i);
	if (i != 8)
		statusFlag++;
	return variable;
}

short levelTwoNodeTwo(short variable)
{
	short           i = 9;

	if (variable != 4)
		statusFlag++;
	i = levelThreeLeafThree(i);
	if (i != 9)
		statusFlag++;
	i++;
	i = levelThreeLeafFour(i);
	if (i != 10)
		statusFlag++;
	return variable;
}

short levelTwoNodeThree(short variable)
{
	short           i = 11;

	if (variable != 5)
		statusFlag++;
	i = levelThreeLeafFive(i);
	if (i != 11)
		statusFlag++;
	i++;
	i = levelThreeLeafSix(i);
	if (i != 12)
		statusFlag++;
	return variable;
}

short levelTwoNodeFour(short variable)
{
	short           i = 13;

	if (variable != 6)
		statusFlag++;
	i = levelThreeLeafSeven(i);
	if (i != 13)
		statusFlag++;
	i++;
	i = levelThreeLeafEight(i);
	if (i != 14)
		statusFlag++;
	return variable;
}

short levelThreeLeafOne(short variable)
{
	if (variable != 7)
		statusFlag++;
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	if (variable != 8)
		statusFlag++;
	return variable;
}

short levelThreeLeafThree(short variable)
{
	if (variable != 9)
		statusFlag++;
	return variable;
}

short levelThreeLeafFour(short variable)
{
	if (variable != 10)
		statusFlag++;
	return variable;
}

short levelThreeLeafFive(short variable)
{
	if (variable != 11)
		statusFlag++;
	return variable;
}

short levelThreeLeafSix(short variable)
{
	if (variable != 12)
		statusFlag++;
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	if (variable != 13)
		statusFlag++;
	return variable;
}

short levelThreeLeafEight(short variable)
{
	if (variable != 14)
		statusFlag++;
	return variable;
}
@def_
@def $macro134()
$LICENSE()
$HEAD()

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 1;
	s = levelOne(i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable)
{
	char           *s;
	short           i = variable + 1;

	if (variable != 1)
		statusFlag++;
	s = levelTwo(i);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}

char *levelTwo(short variable)
{
	char           *s;
	short           i = variable + 1;

	if (variable != 2)
		statusFlag++;
	s = levelThree(i);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}

char *levelThree(short variable)
{
	char           *s;
	short           i;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}
@def_
@def $macro135()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	extern short    i;

	i = 12;
	i = dummy1(divide4, i);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro136()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, used in conditional expression, no
 * function declaration 
 */
{
	extern short    i;

	i = 1;
	if (!(levelOneNodeOne(i) == 1))
		statusFlag++;
	i++;
	if (!(levelOneNodeTwo(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           i = variable + 2;

	if (!(levelTwoNodeOne(i) == 3))
		statusFlag++;
	i++;
	if (!(levelTwoNodeTwo(i) == 4))
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	short           i = variable + 3;

	if (!(levelTwoNodeThree(i) == 5))
		statusFlag++;
	i++;
	if (!(levelTwoNodeFour(i) == 6))
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	short           i = variable + 4;

	if (!(levelThreeLeafOne(i) == 7))
		statusFlag++;
	i++;
	if (!(levelThreeLeafTwo(i) == 8))
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	short           i = variable + 5;

	if (!(levelThreeLeafThree(i) == 9))
		statusFlag++;
	i++;
	if (!(levelThreeLeafFour(i) == 10))
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	short           i = variable + 6;

	if (!(levelThreeLeafFive(i) == 11))
		statusFlag++;
	i++;
	if (!(levelThreeLeafSix(i) == 12))
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	short           i = variable + 7;

	if (!(levelThreeLeafSeven(i) == 13))
		statusFlag++;
	i++;
	if (!(levelThreeLeafEight(i) == 14))
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro137()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;
short           i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	if (!(levelOneNodeOne(i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           i;

	i = 2 * variable;
	return 2 * levelTwoNodeOne(i);
}

short levelTwoNodeOne(short variable)
{
	short           i;

	i = 2 * variable;
	return 2 * levelThreeLeafOne(i);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro138()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            i = 4, j = 8;

int main(void)				/* alias root */
/*
 *  test class: external variable, with local namesake instance  : linear tree structure, used in conditional expression,
 * function declared to return a pointer to character 
 */
{
	extern char     i, j;

	if (compare(skip(i), "andra", 5) == compare(skip(j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro139()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : linear tree structure, in conditional expression, pointer
 * to function returning an integer 
 */
{
	extern short    i;

	i = 12;
	if (dummy1(divide4, i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           i;

	if ((i = (*func) (integer)) != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           i;

	if ((i = (*func) (integer)) != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro140()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	extern short    i;

	i = 1;
	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           i = variable;

	if (--counter) {
		i = recursiveFunction(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro141()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	extern short    i;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	short           i = variable;

	if (--counter) {
		i = recursiveFunction(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro142()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, function declared to return
 * a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 2;
	s = recursiveFunction(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	short           i = 3;
	char           *s;

	if (--counter) {
		s = recursiveFunction(i);
		if (*s != '3')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro143()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	i = dummy(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           i = variable;
	if (--counter) {
		i = dummy(function, i);
		if (i != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro144()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           i = 1;
	if (--counter)
		if (!(recursiveFunction(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro145()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	short           i = 1;

	if (--counter)
		if (!(recursiveFunction(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro146()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	extern short    i;

	i = 2;
	if (!(*recursiveFunction(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	short           i = variable;
	if (--counter)
		if (!(*recursiveFunction(i) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro147()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	if (!(dummy(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           i = variable;
	if (--counter)
		if (!(dummy(function, i) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro148()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
static short    i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, legal, no function declaration 
 */
{
	extern short    i;

	i = 1;
	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	static short    i;

	i = variable + 3;
	if (--counter) {
		i = pollux(i);
		if (i != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	static short    i;

	i = variable - 3;
	if (--counter) {
		i = castor(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro149()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, legal, function declared to return
 * an integer 
 */
{
	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	short           i = variable + 3;

	if (--counter) {
		i = pollux(i);
		if (i != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	short           i = variable - 3;

	if (--counter) {
		i = castor(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro150()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s;

	s = castor(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	char           *s;
	short           i = variable + 4;

	if (--counter) {
		s = pollux(i);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	char           *s;
	short           i = variable - 4;

	if (--counter) {
		s = castor(i);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro151()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	extern short    i;

	i = castor(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           i = variable + 8;
	if (--counter) {
		i = pollux(function, i);
		if (i != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	short           i = variable - 8;
	if (--counter) {
		i = castor(function, i);
		if (i != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro152()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, no function declaration 
 */
{
	extern short    i;

	i = 1;
	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	short           i = variable + 3;

	if (--counter)
		if (!(pollux(i) == 5))
			statusFlag++;
	return ++variable;
}

int pollux(short variable)
{
	short           i = variable - 3;

	if (--counter)
		if (!(castor(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro153()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	extern short    i;

	i = 1;
	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	short           i = variable + 3;

	if (--counter)
		if (!(pollux(i) == 5))
			statusFlag++;
	return ++variable;
}

short pollux(short variable)
{
	short           i = variable - 3;

	if (--counter)
		if (!(castor(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro154()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	if (!(*castor(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	short           i = variable + 4;

	if (--counter)
		if (!(*pollux(i) == '6'))
			statusFlag++;
	return numbers + variable;
}

char *pollux(short variable)
{
	short           i = variable - 4;

	if (--counter)
		if (!(*castor(i) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro155()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable, with local namesake instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	if (!(castor(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	register short  i = variable + 8;

	if (--counter)
		if (!(pollux(function, i) == 10))
			statusFlag++;
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	register short  i = variable - 8;

	if (--counter)
		if (!(castor(function, i) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro156()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(i);
	if (result != 1 || i != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           result = 0;

	variable11 = 3;
	result = levelTwoNodeOne(variable11);
	if (variable11 != result)
		statusFlag++;
	variable11 = 4;
	result = levelTwoNodeTwo(variable11);
	if (variable11 != result)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	short           result = 0;

	variable12 = 5;
	result = levelTwoNodeThree(variable12);
	if (variable12 != result)
		statusFlag++;
	variable12 = 6;
	result = levelTwoNodeFour(variable12);
	if (variable12 != result)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	short           result = 0;

	variable21 = 7;
	result = levelThreeLeafOne(variable21);
	if (variable21 != result)
		statusFlag++;
	variable21 = 8;
	result = levelThreeLeafTwo(variable21);
	if (variable21 != result)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	short           result = 0;

	variable22 = 9;
	result = levelThreeLeafThree(variable22);
	if (variable22 != result)
		statusFlag++;
	variable22 = 10;
	result = levelThreeLeafFour(variable22);
	if (variable22 != result)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	short           result = 0;

	variable23 = 11;
	result = levelThreeLeafFive(variable23);
	if (variable23 != result)
		statusFlag++;
	variable23 = 12;
	result = levelThreeLeafSix(variable23);
	if (variable23 != result)
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	short           result = 0;

	variable24 = 13;
	result = levelThreeLeafSeven(variable24);
	if (variable24 != result)
		statusFlag++;
	variable24 = 14;
	result = levelThreeLeafEight(variable24);
	if (variable24 != result)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro157()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i, variable11, variable12, variable21, variable22, variable23, variable24;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, return value and legal,
 * integer function declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(i);
	if (result != 1 || i != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           result = 0;

	variable11 = 3;
	result = levelTwoNodeOne(variable11);
	if (variable11 != result)
		statusFlag++;
	variable11 = 4;
	result = levelTwoNodeTwo(variable11);
	if (variable11 != result)
		statusFlag++;
	return variable;
}

short levelOneNodeTwo(short variable)
{
	short           result = 0;

	variable12 = 5;
	result = levelTwoNodeThree(variable12);
	if (variable12 != result)
		statusFlag++;
	variable12 = 6;
	result = levelTwoNodeFour(variable12);
	if (variable12 != result)
		statusFlag++;
	return variable;
}

short levelTwoNodeOne(short variable)
{
	short           result = 0;

	variable21 = 7;
	result = levelThreeLeafOne(variable21);
	if (variable21 != result)
		statusFlag++;
	variable21 = 8;
	result = levelThreeLeafTwo(variable21);
	if (variable21 != result)
		statusFlag++;
	return variable;
}

short levelTwoNodeTwo(short variable)
{
	short           result = 0;

	variable22 = 9;
	result = levelThreeLeafThree(variable22);
	if (variable22 != result)
		statusFlag++;
	variable22 = 10;
	result = levelThreeLeafFour(variable22);
	if (variable22 != result)
		statusFlag++;
	return variable;
}

short levelTwoNodeThree(short variable)
{
	short           result = 0;

	variable23 = 11;
	result = levelThreeLeafFive(variable23);
	if (variable23 != result)
		statusFlag++;
	variable23 = 12;
	result = levelThreeLeafSix(variable23);
	if (variable23 != result)
		statusFlag++;
	return variable;
}

short levelTwoNodeFour(short variable)
{
	short           result = 0;

	variable24 = 13;
	result = levelThreeLeafSeven(variable24);
	if (variable24 != result)
		statusFlag++;
	variable24 = 14;
	result = levelThreeLeafEight(variable24);
	if (variable24 != result)
		statusFlag++;
	return variable;
}

short levelThreeLeafOne(short variable)
{
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	return variable;
}

short levelThreeLeafThree(short variable)
{
	return variable;
}

short levelThreeLeafFour(short variable)
{
	return variable;
}

short levelThreeLeafFive(short variable)
{
	return variable;
}

short levelThreeLeafSix(short variable)
{
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro158()
$LICENSE()
$HEAD()

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           i, j, k;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 1;
	s = levelOne(i);
	if (*s != '1' || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable)
{
	char           *s;
	extern short    j;

	if (variable != 1)
		statusFlag++;
	j = 2;
	s = levelTwo(j);
	if (*s != '2' || j != 2)
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	variable++;
	return s;
}

char *levelTwo(short variable)
{
	char           *s;
	extern short    k;

	if (variable != 2)
		statusFlag++;
	k = 3;
	s = levelThree(k);
	if (*s != '3' || k != 3)
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	variable++;
	return s;
}

char *levelThree(short variable)
{
	char           *s;
	short           l;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < variable; l++, s++);
	variable++;
	return s;
}
@def_
@def $macro159()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, return value, legal pointer
 * to function returning an integer 
 */
{
	extern short    i;
	short           result = 0;

	i = 12;
	result = dummy1(divide4, i);
	if (i != 12 || result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           result = 0;

	result = (*func) (integer++);
	if (result != 3)
		statusFlag++;
	return result;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           result = 0;

	result = (*func) (integer++);
	if (result != 6)
		statusFlag++;
	return result;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro160()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;
short           i, j, ii, jj, iii, jjj, iiii, jjjj, iiiii, jjjjj, iiiiii, jjjjjj, iiiiiii, jjjjjjj;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, no function declaration 
 */
{
	i = 1;
	j = i++;
	if (!(levelOneNodeOne(j) + levelOneNodeTwo(i) == 44))
		statusFlag++;
	if (i != 2 || j != 1 || ii != 2 || jj != 3 || iii != 3 || jjj != 4 ||
	    iiii != 3 || jjjj != 4 || iiiii != 4 || jjjjj != 5 || iiiiii != 4 ||
	    jjjjjj != 5 || iiiiiii != 5 || jjjjjjj != 6)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	extern short    ii, jj;
	jj = (ii = ++variable) + 1;
	return levelTwoNodeOne(ii) + levelTwoNodeTwo(jj);
}

int levelOneNodeTwo(short variable)
{
	extern short    iii, jjj;
	jjj = (iii = ++variable) + 1;
	return levelTwoNodeThree(iii) + levelTwoNodeFour(jjj);
}

int levelTwoNodeOne(short variable)
{
	extern short    iiii, jjjj;
	jjjj = (iiii = ++variable) + 1;
	return levelThreeLeafOne(iiii) + levelThreeLeafTwo(jjjj);
}

int levelTwoNodeTwo(short variable)
{
	extern short    iiiii, jjjjj;
	jjjjj = (iiiii = ++variable) + 1;
	return levelThreeLeafThree(iiiii) + levelThreeLeafFour(jjjjj);
}

int levelTwoNodeThree(short variable)
{
	extern short    iiiiii, jjjjjj;
	jjjjjj = (iiiiii = ++variable) + 1;
	return levelThreeLeafFive(iiiiii) + levelThreeLeafSix(jjjjjj);
}

int levelTwoNodeFour(short variable)
{
	extern short    iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = ++variable) + 1;
	return levelThreeLeafSeven(iiiiiii) + levelThreeLeafEight(jjjjjjj);
}

int levelThreeLeafOne(short variable)
{
	return ++variable;
}

int levelThreeLeafTwo(short variable)
{
	return ++variable;
}

int levelThreeLeafThree(short variable)
{
	return ++variable;
}

int levelThreeLeafFour(short variable)
{
	return ++variable;
}

int levelThreeLeafFive(short variable)
{
	return ++variable;
}

int levelThreeLeafSix(short variable)
{
	return ++variable;
}

int levelThreeLeafSeven(short variable)
{
	return ++variable;
}

int levelThreeLeafEight(short variable)
{
	return ++variable;
}
@def_
@def $macro161()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	extern short    i;

	i = 1;
	if (levelOneNodeOne(i) != 32 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           ii;

	ii = 2 * variable++;
	return 2 * levelTwoNodeOne(ii);
}

short levelTwoNodeOne(short variable)
{
	short           iii;

	iii = 2 * variable++;
	return 2 * levelThreeLeafOne(iii);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable++;
}
@def_
@def $macro162()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            i = 4, j = 8;

int main(void)				/* alias root */
/*
 *  test class: extern variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	extern char     i, j;

	if (compare(skip(i), "andra", 5) == compare(skip(j), "across", 6) ||
	    j != 2 * i)
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < skipper; ii++)
		pointer++;
	skipper *= 2;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro163()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : linear tree structure, in conditional expression,
 * pointer to function returning an integer 
 */
{
	extern short    i;

	i = 12;
	if (dummy1(divide4, i) != 3 || i != 12)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	integer++;
	return ii;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	integer++;
	return ii;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro164()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	short           result = 0;
	result = recursiveFunction(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro165()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, legal, integer
 * function declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = recursiveFunction(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro166()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 2;
	s = recursiveFunction(i);
	if (*s != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro167()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	short           result = 0;

	result = dummy(increment, i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           result;
	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return function(variable--);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro168()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, j;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	extern short    i;

	if (recursiveFunction(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	extern short    j;

	j = variable;
	if (--counter)
		if (recursiveFunction(j) != 2 || j != 1)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro169()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, integer function declaration 
 */
{
	extern short    i;

	if (recursiveFunction(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	if (--counter)
		if (recursiveFunction(variable) != 2 || variable != 1)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro170()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	extern char    *numbers;
	extern short    i;

	i = 2;
	if (*recursiveFunction(i) != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	if (--counter)
		if (*recursiveFunction(variable) != '2' || i != 2)
			statusFlag++;
	return numbers + variable--;
}
@def_
@def $macro171()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : recursive call, in conditional expression, pointer
 * to function returning an integer 
 */
{
	i = 1;
	if (dummy(increment, i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	if (--counter)
		if (dummy(function, variable) != 2 || variable != 1)
			statusFlag++;
	return function(variable--);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro172()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, legal, no function
 * declaration 
 */
{
	short           result = 0;

	i = 1;
	result = castor(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	ii = variable + 3;
	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	iii = variable - 3;
	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro173()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = castor(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	short           ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	short           iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro174()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, function declared to return
 * a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 2;
	s = castor(i);
	if (*s != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	short           ii = variable + 4;
	char           *s;

	if (--counter) {
		s = pollux(ii);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable--;
}

char *pollux(short variable)
{
	short           iii = variable - 4;
	char           *s;

	if (--counter) {
		s = castor(iii);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro175()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	short           result = 0;

	i = 1;
	result = castor(increment, i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	ii = variable + 8;
	if (--counter) {
		ii = pollux(function, ii);
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	iii = variable - 8;
	if (--counter) {
		iii = castor(function, iii);
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro176()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	if (castor(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	short           ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	short           iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro177()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	extern short    i;

	if (castor(i) != 2 || i != 1 || ii != 4 || iii != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	extern short    ii;

	ii = variable + 3;
	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	extern short    iii;

	iii = variable - 3;
	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro178()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
static short    i, ii, iii;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	extern short    i;

	i = 2;
	if (*castor(i) != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	extern short    ii;

	ii = variable + 4;
	if (--counter) {
		if (*pollux(ii) != '6' || ii != 6)
			statusFlag++;
	}
	return numbers + variable--;
}

char *pollux(short variable)
{
	extern short    iii;

	iii = variable - 4;
	if (--counter) {
		if (*castor(iii) != '2' || iii != 2)
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro179()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i;

int main(void)
/*
 * test class: extern variable, mistaken as called by address instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	extern short    i;

	i = 1;
	if (castor(increment, i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           ii = variable + 10;
	if (--counter) {
		if (pollux(function, ii) != 12 || ii != 11)
			statusFlag++;
	}
	return function(variable++);
}

int pollux(short (*function) (short), short variable)
{
	short           iii = variable - 10;
	if (--counter) {
		if (castor(function, iii) != 2 || iii != 1)
			statusFlag++;
	}
	return function(variable++);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro180()
$LICENSE()
$HEAD()

void levelOneNodeOne(register short);
void levelOneNodeTwo(register short);
void levelTwoNodeOne(register short);
void levelTwoNodeTwo(register short);
void levelTwoNodeThree(register short);
void levelTwoNodeFour(register short);
void levelThreeLeafOne(short);
void levelThreeLeafTwo(short);
void levelThreeLeafThree(short);
void levelThreeLeafFour(short);
void levelThreeLeafFive(short);
void levelThreeLeafSix(short);
void levelThreeLeafSeven(short);
void levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, no return value and legal 
 */
{
	register short  i;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(register short variable)
{
	if (variable != 1)
		statusFlag++;
	variable += 2;
	levelTwoNodeOne(variable);
	variable++;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(register short variable)
{
	if (variable != 2)
		statusFlag++;
	variable += 3;
	levelTwoNodeThree(variable);
	variable++;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(register short variable)
{
	if (variable != 3)
		statusFlag++;
	variable += 4;
	levelThreeLeafOne(variable);
	variable++;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(register short variable)
{
	if (variable != 4)
		statusFlag++;
	variable += 5;
	levelThreeLeafThree(variable);
	variable++;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(register short variable)
{
	if (variable != 5)
		statusFlag++;
	variable += 6;
	levelThreeLeafFive(variable);
	variable++;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(register short variable)
{
	if (variable != 6)
		statusFlag++;
	variable += 7;
	levelThreeLeafSeven(variable);
	variable++;
	levelThreeLeafEight(variable);
}

void levelThreeLeafOne(short variable)
{
	if (variable != 7)
		statusFlag++;
}

void levelThreeLeafTwo(short variable)
{
	if (variable != 8)
		statusFlag++;
}

void levelThreeLeafThree(short variable)
{
	if (variable != 9)
		statusFlag++;
}

void levelThreeLeafFour(short variable)
{
	if (variable != 10)
		statusFlag++;
}

void levelThreeLeafFive(short variable)
{
	if (variable != 11)
		statusFlag++;
}

void levelThreeLeafSix(short variable)
{
	if (variable != 12)
		statusFlag++;
}

void levelThreeLeafSeven(short variable)
{
	if (variable != 13)
		statusFlag++;
}

void levelThreeLeafEight(short variable)
{
	if (variable != 14)
		statusFlag++;
}
@def_
@def $macro181()
$LICENSE()
$HEAD()

void levelOneNodeOne(register short);
void levelOneNodeTwo(register short);
void levelTwoNodeOne(register short);
void levelTwoNodeTwo(register short);
void levelTwoNodeThree(register short);
void levelTwoNodeFour(register short);
void levelThreeLeafOne(short);
void levelThreeLeafTwo(short);
void levelThreeLeafThree(short);
void levelThreeLeafFour(short);
void levelThreeLeafFive(short);
void levelThreeLeafSix(short);
void levelThreeLeafSeven(short);
void levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, no return value and illegal 
 */
{
	register short  i;
	short           result;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (result == 0)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(register short variable)
{
	short           result;

	if (variable != 1)
		statusFlag++;
	variable += 2;
	levelTwoNodeOne(variable);
	variable++;
	levelTwoNodeTwo(variable);
	if (result == 0)
		result++;
}

void levelOneNodeTwo(register short variable)
{
	short           result;

	if (variable != 2)
		statusFlag++;
	variable += 3;
	levelTwoNodeThree(variable);
	variable++;
	levelTwoNodeFour(variable);
	if (result == 0)
		result++;
}

void levelTwoNodeOne(register short variable)
{
	short           result;

	if (variable != 3)
		statusFlag++;
	variable += 4;
	levelThreeLeafOne(variable);
	variable++;
	levelThreeLeafTwo(variable);
	if (result == 0)
		result++;
}

void levelTwoNodeTwo(register short variable)
{
	short           result;

	if (variable != 4)
		statusFlag++;
	variable += 5;
	levelThreeLeafThree(variable);
	variable++;
	levelThreeLeafFour(variable);
	if (result == 0)
		result++;
}

void levelTwoNodeThree(register short variable)
{
	short           result;

	if (variable != 5)
		statusFlag++;
	variable += 6;
	levelThreeLeafFive(variable);
	variable++;
	levelThreeLeafSix(variable);
	if (result == 0)
		result++;
}

void levelTwoNodeFour(register short variable)
{
	short           result;

	if (variable != 6)
		statusFlag++;
	variable += 7;
	levelThreeLeafSeven(variable);
	variable++;
	levelThreeLeafEight(variable);
	if (result == 0)
		result++;
}

void levelThreeLeafOne(short variable)
{
	variable++;
	return;
}

void levelThreeLeafTwo(short variable)
{
	variable++;
	return;
}

void levelThreeLeafThree(short variable)
{
	variable++;
	return;
}

void levelThreeLeafFour(short variable)
{
	variable++;
	return;
}

void levelThreeLeafFive(short variable)
{
	variable++;
	return;
}

void levelThreeLeafSix(short variable)
{
	variable++;
	return;
}

void levelThreeLeafSeven(short variable)
{
	variable++;
	return;
}

void levelThreeLeafEight(short variable)
{
	variable++;
	return;
}
@def_
@def $macro182()
$LICENSE()
$HEAD()

int levelOneNodeOne(register short);
int levelOneNodeTwo(register short);
int levelTwoNodeOne(register short);
int levelTwoNodeTwo(register short);
int levelTwoNodeThree(register short);
int levelTwoNodeFour(register short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	register short  i = 0;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(register short variable)
{
	short           storage = variable;

	variable += 2;
	variable = levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable++;
	variable = levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(register short variable)
{
	short           storage = variable;

	variable += 3;
	variable = levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable++;
	variable = levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(register short variable)
{
	short           storage = variable;

	variable += 4;
	variable = levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable++;
	variable = levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(register short variable)
{
	short           storage = variable;

	variable += 5;
	variable = levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable++;
	variable = levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(register short variable)
{
	short           storage = variable;

	variable += 6;
	variable = levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable++;
	variable = levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(register short variable)
{
	short           storage = variable;

	variable += 7;
	variable = levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable++;
	variable = levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
	return storage;				
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro183()
$LICENSE()
$HEAD()

short levelOneNodeOne(register short);
short levelOneNodeTwo(register short);
short levelTwoNodeOne(register short);
short levelTwoNodeTwo(register short);
short levelTwoNodeThree(register short);
short levelTwoNodeFour(register short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, return value and legal, integer function declaration 
 */
{
	register short  i = 0;

	i = 1;
	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(register short variable)
{
	short           storage = variable;

	variable = 3;
	variable = levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable = 4;
	variable = levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(register short variable)
{
	short           storage = variable;

	variable = 5;
	variable = levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable = 6;
	variable = levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(register short variable)
{
	short           storage = variable;

	variable = 7;
	variable = levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable = 8;
	variable = levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(register short variable)
{
	short           storage = variable;

	variable = 9;
	variable = levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable = 10;
	variable = levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(register short variable)
{
	short           storage = variable;

	variable = 11;
	variable = levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable = 12;
	variable = levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(register short variable)
{
	short           storage = variable;

	variable = 13;
	variable = levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable = 14;
	variable = levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(short variable)
{
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	return variable;
}

short levelThreeLeafThree(short variable)
{
	return variable;
}

short levelThreeLeafFour(short variable)
{
	return variable;
}

short levelThreeLeafFive(short variable)
{
	return variable;
}

short levelThreeLeafSix(short variable)
{
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro184()
$LICENSE()
$HEAD()

char *levelOne(register short);
char *levelTwo(register short);
char *levelThree(register short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	register short  i;

	i = 1;
	s = levelOne(i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(register short variable)
{
	char           *s;
	short           j;

	if (variable != 1)
		statusFlag++;
	j = 2;
	s = levelTwo(j);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char *levelTwo(register short variable)
{
	char           *s;
	short           k;

	if (variable != 2)
		statusFlag++;
	k = 3;
	s = levelThree(k);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char *levelThree(register short variable)
{
	char           *s;
	short           l;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro185()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), register short);
short divide4(short);
int dummy2(short (*) (short), register short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	register short  i;

	i = 12;
	i = dummy1(divide4, i);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), register short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), register short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro186()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	register short  i = 1, j = i++;

	if (!(levelOneNodeOne(j) + levelOneNodeTwo(i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	register short  ii, jj;
	jj = (ii = ++variable) + 1;
	return levelTwoNodeOne(ii) + levelTwoNodeTwo(jj);
}

int levelOneNodeTwo(short variable)
{
	register short  iii, jjj;
	jjj = (iii = ++variable) + 1;
	return levelTwoNodeThree(iii) + levelTwoNodeFour(jjj);
}

int levelTwoNodeOne(short variable)
{
	register short  iiii, jjjj;
	jjjj = (iiii = ++variable) + 1;
	return levelThreeLeafOne(iiii) + levelThreeLeafTwo(jjjj);
}

int levelTwoNodeTwo(short variable)
{
	register short  iiiii, jjjjj;
	jjjjj = (iiiii = ++variable) + 1;
	return levelThreeLeafThree(iiiii) + levelThreeLeafFour(jjjjj);
}

int levelTwoNodeThree(short variable)
{
	register short  iiiiii, jjjjjj;
	jjjjjj = (iiiiii = ++variable) + 1;
	return levelThreeLeafFive(iiiiii) + levelThreeLeafSix(jjjjjj);
}

int levelTwoNodeFour(short variable)
{
	register short  iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = ++variable) + 1;
	return levelThreeLeafSeven(iiiiiii) + levelThreeLeafEight(jjjjjjj);
}

int levelThreeLeafOne(short variable)
{
	return ++variable;
}

int levelThreeLeafTwo(short variable)
{
	return ++variable;
}

int levelThreeLeafThree(short variable)
{
	return ++variable;
}

int levelThreeLeafFour(short variable)
{
	return ++variable;
}

int levelThreeLeafFive(short variable)
{
	return ++variable;
}

int levelThreeLeafSix(short variable)
{
	return ++variable;
}

int levelThreeLeafSeven(short variable)
{
	return ++variable;
}

int levelThreeLeafEight(short variable)
{
	return ++variable;
}
@def_
@def $macro187()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	register short  i = 1;

	if (!(levelOneNodeOne(i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	register short  ii;

	ii = 2 * variable;
	return 2 * levelTwoNodeOne(ii);
}

short levelTwoNodeOne(short variable)
{
	register short  iii;

	iii = 2 * variable;
	return 2 * levelThreeLeafOne(iii);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro188()
$LICENSE()
$HEAD()

char *skip(register short);
int compare(char*, char*, short);

char           *protean = "cassandracross";

int main(void)				/* alias root */
/*
 *  test class: registered variable instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{
	register char   i = 4, j;

	j = 2 * i;
	if (compare(skip(i), "andra", 5) == compare(skip(j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(register short skipper)
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < skipper; ii++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro189()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), register short);
short divide4(short);
int dummy2(short (*) (short), register short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	register short  i = 12;

	if (dummy1(divide4, i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), register short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return ii;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), register short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return ii;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro190()
$LICENSE()
$HEAD()

void recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, no return value, legal 
 */
{
	register short  i;

	i = 1;
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(register short variable)
{
	if (variable != 1)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro191()
$LICENSE()
$HEAD()

void recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, no return value, illegal 
 */
{
	register short  i = 1;

	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(register short variable)
{
	short           ii;

	if (variable != 1)
		statusFlag++;
	if (--counter) {
		recursiveFunction(variable);
		if (ii == 0)
			ii++;
	}
	return;
}
@def_
@def $macro192()
$LICENSE()
$HEAD()

int recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, return value, legal, no function declaration 
 */
{
	register short  i = 1;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(register short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro193()
$LICENSE()
$HEAD()

short recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, return value, legal, integer function declaration 
 */
{
	register short  i = 1;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(register short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro194()
$LICENSE()
$HEAD()

char *recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;
	register short  i = 2;

	s = recursiveFunction(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(register short variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro195()
$LICENSE()
$HEAD()

int dummy(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	register short  i = 1;

	i = dummy(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), register short variable)
{
	short           result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro196()
$LICENSE()
$HEAD()

int recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	register short  i = 1;

	if (!(recursiveFunction(i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(register short variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - variable == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro197()
$LICENSE()
$HEAD()

short recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	register short  i = 1;

	if (!(recursiveFunction(i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(register short variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - variable == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro198()
$LICENSE()
$HEAD()

char *recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	register short  i = 2;

	if (!(*recursiveFunction(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(register short variable)
{
	if (--counter)
		if (!(*recursiveFunction(variable) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro199()
$LICENSE()
$HEAD()

int dummy(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{
	register short  i = 1;

	if (!(dummy(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), register short variable)
{
	if (--counter)
		if (!(dummy(function, variable) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro200()
$LICENSE()
$HEAD()

void castor(register short);
void pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, no return value, legal 
 */
{
	register short  i = 1;

	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(register short variable)
{
	if (variable != 1)
		statusFlag++;
	if (--counter) {
		variable++;
		pollux(variable);
	}
}

void pollux(register short variable)
{
	if (variable != 2)
		statusFlag++;
	if (--counter) {
		--variable;
		castor(variable);
	}
}
@def_
@def $macro201()
$LICENSE()
$HEAD()

void castor(register short);
void pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, no return value, illegal 
 */
{
	register short  i = 1;

	 castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(register short variable)
{
	short           ii;

	if (variable != 1)
		statusFlag++;
	if (--counter) {
		pollux(variable);
		if (ii == 0)
			ii++;
	}
}

void pollux(register short variable)
{
	short           iii;

	if (variable != 1)
		statusFlag++;
	if (--counter) {
		castor(variable);
		if (iii == 0)
			iii++;
	}
}
@def_
@def $macro202()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, return value, legal, no function declaration 
 */
{
	register short  i = 1;

	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro203()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	register short  i = 1;

	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		ii = pollux(ii);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		iii = castor(iii);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro204()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s;
	register short  i = 2;

	s = castor(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	register short  ii = variable + 4;
	char           *s;

	if (--counter) {
		s = pollux(ii);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	register short  iii = variable - 4;
	char           *s;

	if (--counter) {
		s = castor(iii);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro205()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, return value, pointer to function returning an integer 
 */
{
	register short  i = 1;

	i = castor(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	register short  ii = variable + 8;

	if (--counter) {
		ii = pollux(function, ii);
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	register short  iii = variable - 8;

	if (--counter) {
		iii = castor(function, iii);
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro206()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, in conditional expression, no function declaration 
 */
{
	register short  i = 1;

	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro207()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	register short  i = 1;

	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		if (!(pollux(ii) == 5))
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		if (!(castor(iii) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro208()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{
	register short  i = 2;

	if (!(*castor(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	register short  ii = variable + 4;

	if (--counter) {
		if (!(*pollux(ii) == '6'))
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	register short  iii = variable - 4;

	if (--counter) {
		if (!(*castor(iii) == '2'))
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro209()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{
	register short  i = 1;

	if (!(castor(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	register short  ii = variable + 10;

	if (--counter) {
		if (!(pollux(function, ii) == 12))
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	register short  iii = variable - 10;

	if (--counter) {
		if (!(castor(function, iii) == 2))
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro210()
$LICENSE()
$HEAD()

void levelOneNodeOne(short);
void levelOneNodeTwo(short);
void levelTwoNodeOne(short);
void levelTwoNodeTwo(short);
void levelTwoNodeThree(short);
void levelTwoNodeFour(short);
void levelThreeLeafOne(short);
void levelThreeLeafTwo(short);
void levelThreeLeafThree(short);
void levelThreeLeafFour(short);
void levelThreeLeafFive(short);
void levelThreeLeafSix(short);
void levelThreeLeafSeven(short);
void levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, no return value and legal 
 */
{
	register short  i = 0;
	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 3;
	levelTwoNodeOne(i);
	i = 4;
	levelTwoNodeTwo(i);
	variable++;
}

void levelOneNodeTwo(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 5;
	levelTwoNodeThree(i);
	i = 6;
	levelTwoNodeFour(i);
	variable++;
}

void levelTwoNodeOne(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 7;
	levelThreeLeafOne(i);
	i = 8;
	levelThreeLeafTwo(i);
	variable++;
}

void levelTwoNodeTwo(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 9;
	levelThreeLeafThree(i);
	i = 10;
	levelThreeLeafFour(i);
	variable++;
}

void levelTwoNodeThree(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 11;
	levelThreeLeafFive(i);
	i = 12;
	levelThreeLeafSix(i);
	variable++;
}

void levelTwoNodeFour(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	i = 13;
	levelThreeLeafSeven(i);
	i = 14;
	levelThreeLeafEight(i);
	variable++;
}

void levelThreeLeafOne(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafTwo(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafThree(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafFour(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafFive(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafSix(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafSeven(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}

void levelThreeLeafEight(short variable)
{
	register short  i = 0;
	if (i != 0)
		statusFlag++;
	variable++;
}
@def_
@def $macro211()
$LICENSE()
$HEAD()

void levelOneNodeOne(short);
void levelOneNodeTwo(short);
void levelTwoNodeOne(short);
void levelTwoNodeTwo(short);
void levelTwoNodeThree(short);
void levelTwoNodeFour(short);
void levelThreeLeafOne(short);
void levelThreeLeafTwo(short);
void levelThreeLeafThree(short);
void levelThreeLeafFour(short);
void levelThreeLeafFive(short);
void levelThreeLeafSix(short);
void levelThreeLeafSeven(short);
void levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, no return value and illegal 
 */
{
	register short  i;

	i = 1;
	levelOneNodeOne(i);
	i = 2;
	levelOneNodeTwo(i);
	if (i == 0)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(short variable)
{
	register short  i;

	if (i == variable && i != 1 || variable != 1)
		statusFlag++;
	i = 3;
	levelTwoNodeOne(i);
	i = 4;
	levelTwoNodeTwo(i);
	if (i == 0)
		i++;
}

void levelOneNodeTwo(short variable)
{
	register short  i;

	if (i == variable && i != 2 || variable != 2)
		statusFlag++;
	i = 5;
	levelTwoNodeThree(i);
	i = 6;
	levelTwoNodeFour(i);
	if (i == 0)
		i++;
}

void levelTwoNodeOne(short variable)
{
	register short  i;

	if (i == variable && i != 3 || variable != 3)
		statusFlag++;
	i = 7;
	levelThreeLeafOne(i);
	i = 8;
	levelThreeLeafTwo(i);
	if (i == 0)
		i++;
}

void levelTwoNodeTwo(short variable)
{
	register short  i;

	if (i == variable && i != 4 || variable != 4)
		statusFlag++;
	i = 9;
	levelThreeLeafThree(i);
	i = 10;
	levelThreeLeafFour(i);
	if (i == 0)
		i++;
}

void levelTwoNodeThree(short variable)
{
	register short  i;

	if (i == variable && i != 5 || variable != 5)
		statusFlag++;
	i = 11;
	levelThreeLeafFive(i);
	i = 12;
	levelThreeLeafSix(i);
	if (i == 0)
		i++;
}

void levelTwoNodeFour(short variable)
{
	register short  i;

	if (i == variable && i != 6 || variable != 6)
		statusFlag++;
	i = 13;
	levelThreeLeafSeven(i);
	i = 14;
	levelThreeLeafEight(i);
	if (i == 0)
		i++;
}

void levelThreeLeafOne(short variable)
{
	variable++;
	return;
}

void levelThreeLeafTwo(short variable)
{
	variable++;
	return;
}

void levelThreeLeafThree(short variable)
{
	variable++;
	return;
}

void levelThreeLeafFour(short variable)
{
	variable++;
	return;
}

void levelThreeLeafFive(short variable)
{
	variable++;
	return;
}

void levelThreeLeafSix(short variable)
{
	variable++;
	return;
}

void levelThreeLeafSeven(short variable)
{
	variable++;
	return;
}

void levelThreeLeafEight(short variable)
{
	variable++;
	return;
}
@def_
@def $macro212()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	register short  i = 1;

	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	++i;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	register short  i = variable + 2;

	if (variable != 1)
		statusFlag++;
	i = levelTwoNodeOne(i);
	if (i != 3)
		statusFlag++;
	++i;
	i = levelTwoNodeTwo(i);
	if (i != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	register short  i = variable + 3;

	if (variable != 2)
		statusFlag++;
	i = levelTwoNodeThree(i);
	if (i != 5)
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
	if (i != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	register short  i = variable + 4;

	if (variable != 3)
		statusFlag++;
	i = levelThreeLeafOne(i);
	if (i != 7)
		statusFlag++;
	++i;
	i = levelThreeLeafTwo(i);
	if (i != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	register short  i = variable + 5;

	if (variable != 4)
		statusFlag++;
	i = levelThreeLeafThree(i);
	if (i != 9)
		statusFlag++;
	++i;
	i = levelThreeLeafFour(i);
	if (i != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	register short  i = variable + 6;

	if (variable != 5)
		statusFlag++;
	i = levelThreeLeafFive(i);
	if (i != 11)
		statusFlag++;
	++i;
	i = levelThreeLeafSix(i);
	if (i != 12)
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	register short  i = variable + 7;

	if (variable != 6)
		statusFlag++;
	i = levelThreeLeafSeven(i);
	if (i != 13)
		statusFlag++;
	++i;
	i = levelThreeLeafEight(i);
	if (i != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	if (variable != 7)
		statusFlag++;
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	if (variable != 8)
		statusFlag++;
	return variable;
}

int levelThreeLeafThree(short variable)
{
	if (variable != 9)
		statusFlag++;
	return variable;
}

int levelThreeLeafFour(short variable)
{
	if (variable != 10)
		statusFlag++;
	return variable;
}

int levelThreeLeafFive(short variable)
{
	if (variable != 11)
		statusFlag++;
	return variable;
}

int levelThreeLeafSix(short variable)
{
	if (variable != 12)
		statusFlag++;
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	if (variable != 13)
		statusFlag++;
	return variable;
}

int levelThreeLeafEight(short variable)
{
	if (variable != 14)
		statusFlag++;
	return variable;
}
@def_
@def $macro213()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	register short  i = 1;

	i = levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i++;
	i = levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	register short  i = 3;

	if (variable != 1)
		statusFlag++;
	i = levelTwoNodeOne(i);
	if (i != 3)
		statusFlag++;
	i++;
	i = levelTwoNodeTwo(i);
	if (i != 4)
		statusFlag++;
	return variable;
}

short levelOneNodeTwo(short variable)
{
	register short  i = 5;

	if (variable != 2)
		statusFlag++;
	i = levelTwoNodeThree(i);
	if (i != 5)
		statusFlag++;
	++i;
	i = levelTwoNodeFour(i);
	if (i != 6)
		statusFlag++;
	return variable;
}

short levelTwoNodeOne(short variable)
{
	register short  i = 7;

	if (variable != 3)
		statusFlag++;
	i = levelThreeLeafOne(i);
	if (i != 7)
		statusFlag++;
	i++;
	i = levelThreeLeafTwo(i);
	if (i != 8)
		statusFlag++;
	return variable;
}

short levelTwoNodeTwo(short variable)
{
	register short  i = 9;

	if (variable != 4)
		statusFlag++;
	i = levelThreeLeafThree(i);
	if (i != 9)
		statusFlag++;
	i++;
	i = levelThreeLeafFour(i);
	if (i != 10)
		statusFlag++;
	return variable;
}

short levelTwoNodeThree(short variable)
{
	register short  i = 11;

	if (variable != 5)
		statusFlag++;
	i = levelThreeLeafFive(i);
	if (i != 11)
		statusFlag++;
	i++;
	i = levelThreeLeafSix(i);
	if (i != 12)
		statusFlag++;
	return variable;
}

short levelTwoNodeFour(short variable)
{
	register short  i = 13;

	if (variable != 6)
		statusFlag++;
	i = levelThreeLeafSeven(i);
	if (i != 13)
		statusFlag++;
	i++;
	i = levelThreeLeafEight(i);
	if (i != 14)
		statusFlag++;
	return variable;
}

short levelThreeLeafOne(short variable)
{
	if (variable != 7)
		statusFlag++;
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	if (variable != 8)
		statusFlag++;
	return variable;
}

short levelThreeLeafThree(short variable)
{
	if (variable != 9)
		statusFlag++;
	return variable;
}

short levelThreeLeafFour(short variable)
{
	if (variable != 10)
		statusFlag++;
	return variable;
}

short levelThreeLeafFive(short variable)
{
	if (variable != 11)
		statusFlag++;
	return variable;
}

short levelThreeLeafSix(short variable)
{
	if (variable != 12)
		statusFlag++;
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	if (variable != 13)
		statusFlag++;
	return variable;
}

short levelThreeLeafEight(short variable)
{
	if (variable != 14)
		statusFlag++;
	return variable;
}
@def_
@def $macro214()
$LICENSE()
$HEAD()

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, doubled instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	register short  i = 1;

	s = levelOne(i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable)
{
	char           *s;
	register short  i = variable + 1;

	if (variable != 1)
		statusFlag++;
	s = levelTwo(i);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}

char *levelTwo(short variable)
{
	char           *s;
	register short  i = variable + 1;

	if (variable != 2)
		statusFlag++;
	s = levelThree(i);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}

char *levelThree(short variable)
{
	char           *s;
	register short  i;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < variable; i++, s++);
	return s;
}
@def_
@def $macro215()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, doubled instance  : linear tree structure, return value, legal pointer to function
 * returning an integer 
 */
{
	register short  i = 12;

	i = dummy1(divide4, i);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	register short  i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	register short  i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro216()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	register short  i = 1;

	if (!(levelOneNodeOne(i) == 1))
		statusFlag++;
	i++;
	if (!(levelOneNodeTwo(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	register short  i = variable + 2;

	if (!(levelTwoNodeOne(i) == 3))
		statusFlag++;
	i++;
	if (!(levelTwoNodeTwo(i) == 4))
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	register short  i = variable + 3;

	if (!(levelTwoNodeThree(i) == 5))
		statusFlag++;
	i++;
	if (!(levelTwoNodeFour(i) == 6))
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	register short  i = variable + 4;

	if (!(levelThreeLeafOne(i) == 7))
		statusFlag++;
	i++;
	if (!(levelThreeLeafTwo(i) == 8))
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	register short  i = variable + 5;

	if (!(levelThreeLeafThree(i) == 9))
		statusFlag++;
	i++;
	if (!(levelThreeLeafFour(i) == 10))
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	register short  i = variable + 6;

	if (!(levelThreeLeafFive(i) == 11))
		statusFlag++;
	i++;
	if (!(levelThreeLeafSix(i) == 12))
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	register short  i = variable + 7;

	if (!(levelThreeLeafSeven(i) == 13))
		statusFlag++;
	i++;
	if (!(levelThreeLeafEight(i) == 14))
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro217()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, used in conditional expression, integer
 * function declaration 
 */
{
	register short  i = 1;

	if (!(levelOneNodeOne(i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	register short  i;

	i = 2 * variable;
	return 2 * levelTwoNodeOne(i);
}

short levelTwoNodeOne(short variable)
{
	register short  i;

	i = 2 * variable;
	return 2 * levelThreeLeafOne(i);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro218()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";

int main(void)				/* alias root */
/*
 *  test class: registered variable, doubled instance  : linear tree structure, used in conditional expression, function
 * declared to return a pointer to character 
 */
{
	register char   i = 4, j;

	j = 2 * i;
	if (compare(skip(i), "andra", 5) == compare(skip(j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	register char   i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro219()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, doubled instance  : linear tree structure, in conditional expression, pointer to
 * function returning an integer 
 */
{
	register short  i;

	i = 12;
	if (dummy1(divide4, i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	register short  i;

	if ((i = (*func) (integer)) != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	register short  i;

	if ((i = (*func) (integer)) != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro220()
$LICENSE()
$HEAD()

void recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, no return value, legal 
 */
{
	register short  i = 1;

	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(short variable)
{
	register short  i = variable;

	if (variable != 1)
		statusFlag++;
	if (--counter)
		recursiveFunction(i);
}
@def_
@def $macro221()
$LICENSE()
$HEAD()

void recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, no return value, illegal 
 */
{
	register short  i = 1;
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(short variable)
{
	register short  i;

	if (i == variable && i != 1 || variable != 1)
		statusFlag++;
	if (--counter) {
		recursiveFunction(variable);
		if (i == 0)
			i++;
	}
	return;
}
@def_
@def $macro222()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, return value, legal, no function declaration 
 */
{
	register short  i = 1;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	register short  i = variable;

	if (--counter) {
		i = recursiveFunction(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro223()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, return value, legal, integer function declaration 
 */
{
	register short  i = 1;

	i = recursiveFunction(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	register short  i = variable;

	if (--counter) {
		i = recursiveFunction(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro224()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s;
	register short  i = 2;

	s = recursiveFunction(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	register short  i = 3;
	char           *s;

	if (--counter) {
		s = recursiveFunction(i);
		if (*s != '3')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro225()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, return value, pointer to function returning an
 * integer 
 */
{
	register short  i = 1;

	i = dummy(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	register short  i = variable;

	if (--counter) {
		i = dummy(function, i);
		if (i != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro226()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	register short  i = 1;

	if (!(recursiveFunction(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	register short  i = 1;

	if (--counter)
		if (!(recursiveFunction(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro227()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	register short  i = 1;

	if (!(recursiveFunction(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	register short  i = 1;

	if (--counter)
		if (!(recursiveFunction(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro228()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	register short  i = 2;

	if (!(*recursiveFunction(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	register short  i = variable;
	if (--counter)
		if (!(*recursiveFunction(i) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro229()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : recursive call, in conditional expression, pointer to function
 * returning an integer 
 */
{
	register short  i = 1;

	if (!(dummy(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	register short  i = variable;

	if (--counter)
		if (!(dummy(function, i) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro230()
$LICENSE()
$HEAD()

void castor(short);
void pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, no return value, legal 
 */
{
	register short  i = 1;

	castor(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(short variable)
{
	register short  i = variable + 1;

	if (variable != 1)
		statusFlag++;
	if (--counter)
		pollux(i);
}

void pollux(short variable)
{
	register short  i = variable - 1;

	if (variable != 2)
		statusFlag++;
	if (--counter)
		castor(i);
}
@def_
@def $macro231()
$LICENSE()
$HEAD()

void castor(short);
void pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, no return value, illegal 
 */
{
	register short  i = 1;

	castor(i);
	if (i == 0)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(short variable)
{
	register short  i;

	if (i == variable && i != 1 || variable != 1)
		statusFlag++;
	i = variable + 1;
	if (--counter) {
		pollux(i);
		if (i == 0)
			i++;
	}
}

void pollux(short variable)
{
	register short  i;

	if (i == variable && i != 2 || variable != 2)
		statusFlag++;
	i = variable - 1;
	if (--counter) {
		castor(i);
		if (i == 0)
			i++;
	}
}
@def_
@def $macro232()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, return value, legal, no function declaration 
 */
{
	register short  i = 1;

	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	register short  i = variable + 3;

	if (--counter) {
		i = pollux(i);
		if (i != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	register short  i = variable - 3;

	if (--counter) {
		i = castor(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro233()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	register short  i = 1;

	i = castor(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	register short  i = variable + 3;

	if (--counter) {
		i = pollux(i);
		if (i != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	register short  i = variable - 3;

	if (--counter) {
		i = castor(i);
		if (i != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro234()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;
	register short  i = 2;

	s = castor(i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	char           *s;
	register short  i = variable + 4;

	if (--counter) {
		s = pollux(i);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	char           *s;
	register short  i = variable - 4;

	if (--counter) {
		s = castor(i);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro235()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, return value, pointer to function returning an integer 
 */
{
	register short  i = 1;

	i = castor(increment, i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	register short  i = variable + 8;

	if (--counter) {
		i = pollux(function, i);
		if (i != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	register short  i = variable - 8;

	if (--counter) {
		i = castor(function, i);
		if (i != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro236()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, in conditional expression, no function declaration 
 */
{
	register short  i = 1;

	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	register short  i = variable + 3;

	if (--counter)
		if (!(pollux(i) == 5))
			statusFlag++;
	return ++variable;
}

int pollux(short variable)
{
	register short  i = variable - 3;

	if (--counter)
		if (!(castor(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro237()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, in conditional expression, function declared to return an
 * integer 
 */
{
	register short  i = 1;

	if (!(castor(i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	register short  i = variable + 3;

	if (--counter)
		if (!(pollux(i) == 5))
			statusFlag++;
	return ++variable;
}

short pollux(short variable)
{
	register short  i = variable - 3;

	if (--counter)
		if (!(castor(i) == 2))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro238()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	register short  i = 2;

	if (!(*castor(i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	register short  i = variable + 4;

	if (--counter)
		if (!(*pollux(i) == '6'))
			statusFlag++;
	return numbers + variable;
}

char *pollux(short variable)
{
	register short  i = variable - 4;

	if (--counter)
		if (!(*castor(i) == '2'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro239()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, doubled instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{
	register short  i = 1;

	if (!(castor(increment, i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	register short  i = variable + 8;

	if (--counter)
		if (!(pollux(function, i) == 10))
			statusFlag++;
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	register short  i = variable - 8;

	if (--counter)
		if (!(castor(function, i) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro240()
$LICENSE()
$HEAD()

void levelOneNodeOne(register short);
void levelOneNodeTwo(register short);
void levelTwoNodeOne(register short);
void levelTwoNodeTwo(register short);
void levelTwoNodeThree(register short);
void levelTwoNodeFour(register short);
void levelThreeLeafOne(register short);
void levelThreeLeafTwo(register short);
void levelThreeLeafThree(register short);
void levelThreeLeafFour(register short);
void levelThreeLeafFive(register short);
void levelThreeLeafSix(register short);
void levelThreeLeafSeven(register short);
void levelThreeLeafEight(register short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, no return value and
 * legal 
 */
{
	register short  i;

	i = 1;
	levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(register short variable)
{
	variable += 2;
	levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable++;
	levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
}

void levelOneNodeTwo(register short variable)
{
	variable += 3;
	levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable++;
	levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
}

void levelTwoNodeOne(register short variable)
{
	variable += 4;
	levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable++;
	levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
}

void levelTwoNodeTwo(register short variable)
{
	variable += 5;
	levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable++;
	levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
}

void levelTwoNodeThree(register short variable)
{
	variable += 6;
	levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable++;
	levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
}

void levelTwoNodeFour(register short variable)
{
	variable += 7;
	levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable++;
	levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
}

void levelThreeLeafOne(register short variable)
{
	if (variable++);
}

void levelThreeLeafTwo(register short variable)
{
	if (variable++);
}

void levelThreeLeafThree(register short variable)
{
	if (variable++);
}

void levelThreeLeafFour(register short variable)
{
	if (variable++);
}

void levelThreeLeafFive(register short variable)
{
	if (variable++);
}

void levelThreeLeafSix(register short variable)
{
	if (variable++);
}

void levelThreeLeafSeven(register short variable)
{
	if (variable++);
}

void levelThreeLeafEight(register short variable)
{
	if (variable++);
}
@def_
@def $macro241()
$LICENSE()
$HEAD()

void levelOneNodeOne(register short);
void levelOneNodeTwo(register short);
void levelTwoNodeOne(register short);
void levelTwoNodeTwo(register short);
void levelTwoNodeThree(register short);
void levelTwoNodeFour(register short);
void levelThreeLeafOne(register short);
void levelThreeLeafTwo(register short);
void levelThreeLeafThree(register short);
void levelThreeLeafFour(register short);
void levelThreeLeafFive(register short);
void levelThreeLeafSix(register short);
void levelThreeLeafSeven(register short);
void levelThreeLeafEight(register short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, no return value and
 * illegal 
 */
{
	register short  i;
	short           result;

	i = 1;
	levelOneNodeOne(i);
	if (i != 1)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(i);
	if (i != 2)
		statusFlag++;
	if (result == 0)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(register short variable)
{
	short           result;

	variable += 2;
	levelTwoNodeOne(variable);
	if (variable != 3)
		statusFlag++;
	variable++;
	levelTwoNodeTwo(variable);
	if (variable != 4)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelOneNodeTwo(register short variable)
{
	short           result;

	variable += 3;
	levelTwoNodeThree(variable);
	if (variable != 5)
		statusFlag++;
	variable++;
	levelTwoNodeFour(variable);
	if (variable != 6)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelTwoNodeOne(register short variable)
{
	short           result;

	variable += 4;
	levelThreeLeafOne(variable);
	if (variable != 7)
		statusFlag++;
	variable++;
	levelThreeLeafTwo(variable);
	if (variable != 8)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelTwoNodeTwo(register short variable)
{
	short           result;

	variable += 5;
	levelThreeLeafThree(variable);
	if (variable != 9)
		statusFlag++;
	variable++;
	levelThreeLeafFour(variable);
	if (variable != 10)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelTwoNodeThree(register short variable)
{
	short           result;

	variable += 6;
	levelThreeLeafFive(variable);
	if (variable != 11)
		statusFlag++;
	variable++;
	levelThreeLeafSix(variable);
	if (variable != 12)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelTwoNodeFour(register short variable)
{
	short           result;

	variable += 7;
	levelThreeLeafSeven(variable);
	if (variable != 13)
		statusFlag++;
	variable++;
	levelThreeLeafEight(variable);
	if (variable != 14)
		statusFlag++;
	if (result == 0)
		result++;
}

void levelThreeLeafOne(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafTwo(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafThree(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafFour(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafFive(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafSix(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafSeven(register short variable)
{
	if (variable++);
	return;
}

void levelThreeLeafEight(register short variable)
{
	if (variable++);
	return;
}
@def_
@def $macro242()
$LICENSE()
$HEAD()

int levelOneNodeOne(register short);
int levelOneNodeTwo(register short);
int levelTwoNodeOne(register short);
int levelTwoNodeTwo(register short);
int levelTwoNodeThree(register short);
int levelTwoNodeFour(register short);
int levelThreeLeafOne(register short);
int levelThreeLeafTwo(register short);
int levelThreeLeafThree(register short);
int levelThreeLeafFour(register short);
int levelThreeLeafFive(register short);
int levelThreeLeafSix(register short);
int levelThreeLeafSeven(register short);
int levelThreeLeafEight(register short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	register short  i = 0;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(i);
	if (i != 1 || result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(i);
	if (i != 2 || result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(register short variable)
{
	short           storage = variable, result = 0;

	variable += 2;
	result = levelTwoNodeOne(variable);
	if (variable != 3 || result != 3)
		statusFlag++;
	variable++;
	result = levelTwoNodeTwo(variable);
	if (variable != 4 || result != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(register short variable)
{
	short           storage = variable, result = 0;

	variable += 3;
	result = levelTwoNodeThree(variable);
	if (variable != 5 || result != 5)
		statusFlag++;
	variable++;
	result = levelTwoNodeFour(variable);
	if (variable != 6 || result != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(register short variable)
{
	short           storage = variable, result = 0;

	variable += 4;
	result = levelThreeLeafOne(variable);
	if (variable != 7 || result != 7)
		statusFlag++;
	variable++;
	result = levelThreeLeafTwo(variable);
	if (variable != 8 || result != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(register short variable)
{
	short           storage = variable, result = 0;

	variable += 5;
	result = levelThreeLeafThree(variable);
	if (variable != 9 || result != 9)
		statusFlag++;
	variable++;
	result = levelThreeLeafFour(variable);
	if (variable != 10 || result != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(register short variable)
{
	short           storage = variable, result = 0;

	variable += 6;
	result = levelThreeLeafFive(variable);
	if (variable != 11 || result != 11)
		statusFlag++;
	variable++;
	result = levelThreeLeafSix(variable);
	if (variable != 12 || result != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(register short variable)
{
	short           storage = variable, result = 0;

	variable += 7;
	result = levelThreeLeafSeven(variable);
	if (variable != 13 || result != 13)
		statusFlag++;
	variable++;
	result = levelThreeLeafEight(variable);
	if (variable != 14 || result != 14)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafTwo(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafThree(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafFour(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafFive(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafSix(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafSeven(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

int levelThreeLeafEight(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}
@def_
@def $macro243()
$LICENSE()
$HEAD()

short levelOneNodeOne(register short variable);
short levelOneNodeTwo(register short variable);
short levelTwoNodeOne(register short variable);
short levelTwoNodeTwo(register short variable);
short levelTwoNodeThree(register short variable);
short levelTwoNodeFour(register short variable);
short levelThreeLeafOne(register short variable);
short levelThreeLeafTwo(register short variable);
short levelThreeLeafThree(register short variable);
short levelThreeLeafFour(register short variable);
short levelThreeLeafFive(register short variable);
short levelThreeLeafSix(register short variable);
short levelThreeLeafSeven(register short variable);
short levelThreeLeafEight(register short variable);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	register short  i = 0;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(i);
	if (i != 1 || result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(i);
	if (i != 2 || result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(register short variable)
{
	short           storage = variable, result = 0;

	variable = 3;
	result = levelTwoNodeOne(variable);
	if (variable != 3 || result != 3)
		statusFlag++;
	variable = 4;
	result = levelTwoNodeTwo(variable);
	if (variable != 4 || result != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(register short variable)
{
	short           storage = variable, result = 0;

	variable = 5;
	result = levelTwoNodeThree(variable);
	if (variable != 5 || result != 5)
		statusFlag++;
	variable = 6;
	result = levelTwoNodeFour(variable);
	if (variable != 6 || result != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(register short variable)
{
	short           storage = variable, result = 0;

	variable = 7;
	result = levelThreeLeafOne(variable);
	if (variable != 7 || result != 7)
		statusFlag++;
	variable = 8;
	result = levelThreeLeafTwo(variable);
	if (variable != 8 || result != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(register short variable)
{
	short           storage = variable, result = 0;

	variable = 9;
	result = levelThreeLeafThree(variable);
	if (variable != 9 || result != 9)
		statusFlag++;
	variable = 10;
	result = levelThreeLeafFour(variable);
	if (variable != 10 || result != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(register short variable)
{
	short           storage = variable, result = 0;

	variable = 11;
	result = levelThreeLeafFive(variable);
	if (variable != 11 || result != 11)
		statusFlag++;
	variable = 12;
	result = levelThreeLeafSix(variable);
	if (variable != 12 || result != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(register short variable)
{
	short           storage = variable, result = 0;

	variable = 13;
	result = levelThreeLeafSeven(variable);
	if (variable != 13 || result != 13)
		statusFlag++;
	variable = 14;
	result = levelThreeLeafEight(variable);
	if (variable != 14 || result != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafTwo(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafThree(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafFour(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafFive(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafSix(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafSeven(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}

short levelThreeLeafEight(register short variable)
{
	short           storage = variable;

	variable++;
	return storage;
}
@def_
@def $macro244()
$LICENSE()
$HEAD()

char *levelOne(register short);
char *levelTwo(register short);
char *levelThree(register short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s;
	register short  i;

	i = 1;
	s = levelOne(i);
	if (*s != '1' || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(register short variable)
{
	char           *s;
	register short  j;

	j = 2;
	s = levelTwo(j);
	if (*s != '2' || j != 2)
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	variable++;
	return s;
}

char *levelTwo(register short variable)
{
	char           *s;
	short           k;

	k = 3;
	s = levelThree(k);
	if (*s != '3' || k != 3)
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	variable++;
	return s;
}

char *levelThree(register short variable)
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	variable++;
	return s;
}
@def_
@def $macro245()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), register short);
short divide4(short);
int dummy2(short (*) (short), register short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	register short  i;
	short           result = 0;

	i = 12;
	result = dummy1(divide4, i);
	if (i != 12 || result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), register short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3 || integer != 12)
		statusFlag++;
	integer++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), register short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6 || integer != 12)
		statusFlag++;
	integer++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro246()
$LICENSE()
$HEAD()

int levelOneNodeOne(register short);
int levelOneNodeTwo(register short);
int levelTwoNodeOne(register short);
int levelTwoNodeTwo(register short);
int levelTwoNodeThree(register short);
int levelTwoNodeFour(register short);
int levelThreeLeafOne(register short);
int levelThreeLeafTwo(register short);
int levelThreeLeafThree(register short);
int levelThreeLeafFour(register short);
int levelThreeLeafFive(register short);
int levelThreeLeafSix(register short);
int levelThreeLeafSeven(register short);
int levelThreeLeafEight(register short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, no function declaration 
 */
{
	register short  i = 1, j = i++;

	if (levelOneNodeOne(j) + levelOneNodeTwo(i) != 44)
		statusFlag++;
	if (i != 2 || j != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(register short variable)
{
	register short  ii, jj, result = 0;

	jj = (ii = ++variable) + 1;
	result = levelTwoNodeOne(ii) + levelTwoNodeTwo(jj);
	if (jj != 3 || ii != 2)
		statusFlag++;
	return result;
}

int levelOneNodeTwo(register short variable)
{
	register short  iii, jjj, result = 0;

	jjj = (iii = ++variable) + 1;
	result = levelTwoNodeThree(iii) + levelTwoNodeFour(jjj);
	if (jjj != 4 || iii != 3)
		statusFlag++;
	return result;
}

int levelTwoNodeOne(register short variable)
{
	register short  iiii, jjjj, result = 0;

	jjjj = (iiii = ++variable) + 1;
	result = levelThreeLeafOne(iiii) + levelThreeLeafTwo(jjjj);
	if (jjjj != 4 || iiii != 3)
		statusFlag++;
	return result;
}

int levelTwoNodeTwo(register short variable)
{
	register short  iiiii, jjjjj, result = 0;

	jjjjj = (iiiii = ++variable) + 1;
	result = levelThreeLeafThree(iiiii) + levelThreeLeafFour(jjjjj);
	if (jjjjj != 5 || iiiii != 4)
		statusFlag++;
	return result;
}

int levelTwoNodeThree(register short variable)
{
	register short  iiiiii, jjjjjj, result = 0;

	jjjjjj = (iiiiii = ++variable) + 1;
	result = levelThreeLeafFive(iiiiii) + levelThreeLeafSix(jjjjjj);
	if (jjjjjj != 5 || iiiiii != 4)
		statusFlag++;
	return result;
}

int levelTwoNodeFour(register short variable)
{
	register short  iiiiiii, jjjjjjj, result = 0;

	jjjjjjj = (iiiiiii = ++variable) + 1;
	result = levelThreeLeafSeven(iiiiiii) + levelThreeLeafEight(jjjjjjj);
	if (jjjjjjj != 6 || iiiiiii != 5)
		statusFlag++;
	return result;
}

int levelThreeLeafOne(register short variable)
{
	return ++variable;
}

int levelThreeLeafTwo(register short variable)
{
	return ++variable;
}

int levelThreeLeafThree(register short variable)
{
	return ++variable;
}

int levelThreeLeafFour(register short variable)
{
	return ++variable;
}

int levelThreeLeafFive(register short variable)
{
	return ++variable;
}

int levelThreeLeafSix(register short variable)
{
	return ++variable;
}

int levelThreeLeafSeven(register short variable)
{
	return ++variable;
}

int levelThreeLeafEight(register short variable)
{
	return ++variable;
}
@def_
@def $macro247()
$LICENSE()
$HEAD()

short levelOneNodeOne(register short);
short levelTwoNodeOne(register short);
short levelThreeLeafOne(register short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	register short  i = 1;

	if (levelOneNodeOne(i) != 32 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(register short variable)
{
	register short  ii;
	short           result = 0;

	ii = 2 * variable++;
	result = 2 * levelTwoNodeOne(ii);
	if (ii != 2)
		statusFlag++;
	return result;
}

short levelTwoNodeOne(register short variable)
{
	register short  iii;
	short           result = 0;

	iii = 2 * variable++;
	result = 2 * levelThreeLeafOne(iii);
	if (iii != 4)
		statusFlag++;
	return result;
}

short levelThreeLeafOne(register short variable)
{
	return 2 * variable++;
}
@def_
@def $macro248()
$LICENSE()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
/* $Id: ckr.4-2-03.tt,v 1.4 2006/01/11 05:17:21 share Exp $ */


#include "def.h"

char *skip(register short);
int compare(char*, char*, short);

char           *protean = "cassandracross";
short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: registered variable, mistaken as called by address instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	register char   i = 5, j = 2 * i;

	if (compare(skip(i), "andra", 5) == compare(skip(j), "cross", 5))
		statusFlag++;
	if (i != 5 || j != 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *skip(register short skipper)
{
	char           *pointer;

	for (pointer = protean; skipper > 0; skipper--){
		pointer++;
	}
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro249()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), register short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	register short  i;

	i = 12;
	if (dummy1(divide4, i) != 3 || i != 12)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), register short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3 || integer != 12)
		statusFlag++;
	integer++;
	return ii;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6 || integer != 12)
		statusFlag++;
	integer++;
	return ii;
}

short divide2(short integer)
{
	return integer++ / 2;
}
@def_
@def $macro250()
$LICENSE()
$HEAD()

void recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, no return value, legal 
 */
{
	register short  i;

	i = 1;
	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(register short variable)
{
	if (variable != 1)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable++);
}
@def_
@def $macro251()
$LICENSE()
$HEAD()

void recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, no return value, illegal 
 */
{
	register short  i = 1;

	recursiveFunction(i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(register short variable)
{
	short           i = 0;

	if (--counter) {
		recursiveFunction(variable);
		if (variable != 1)
			statusFlag++;
		variable++;
	}
	if (i == 0)
		i++;
	return;
}
@def_
@def $macro252()
$LICENSE()
$HEAD()

int recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, return value, legal, no
 * function declaration 
 */
{
	register short  i = 1;
	short           result = 0;

	result = recursiveFunction(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(register short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2 || variable != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro253()
$LICENSE()
$HEAD()

short recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, return value, legal, integer
 * function declaration 
 */
{
	register short  i = 1;
	short           result = 0;

	result = recursiveFunction(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(register short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != 2 || variable != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro254()
$LICENSE()
$HEAD()

char *recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	register short  i = 2;

	s = recursiveFunction(i);
	if (*s != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(register short variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2' || variable != 2)
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro255()
$LICENSE()
$HEAD()

int dummy(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	register short  i = 1;
	short           result = 0;

	result = dummy(increment, i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), register short variable)
{
	short           result;
	if (--counter) {
		result = dummy(function, variable);
		if (result != 2 || variable != 1)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro256()
$LICENSE()
$HEAD()

int recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	register short  i = 1;

	if (recursiveFunction(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(register short variable)
{
	if (--counter)
		if (recursiveFunction(variable) != 2 || variable != 1)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro257()
$LICENSE()
$HEAD()

short recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, function in conditional
 * expression, integer function declaration 
 */
{
	register short  i = 1;

	if (recursiveFunction(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(register short variable)
{
	if (--counter)
		if (recursiveFunction(variable) != 2 || variable != 1)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro258()
$LICENSE()
$HEAD()

char *recursiveFunction(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	register short  i = 2;

	if (*recursiveFunction(i) != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(register short variable)
{
	if (--counter)
		if (*recursiveFunction(variable) != '2' || variable != 2)
			statusFlag++;
	return numbers + variable--;
}
@def_
@def $macro259()
$LICENSE()
$HEAD()

int dummy(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	register short  i = 1;

	if (dummy(increment, i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), register short variable)
{
	if (--counter)
		if (dummy(function, variable) != 2 || variable != 1)
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro260()
$LICENSE()
$HEAD()

void castor(register short);
void pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, no return value, legal 
 */
{
	register short  i = 1;

	castor(i);
	if (i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(register short variable)
{
	if (--counter) {
		variable++;
		pollux(variable);
		if (variable != 2)
			statusFlag++;
	}
}

void pollux(register short variable)
{
	if (--counter) {
		--variable;
		castor(variable);
		if (variable != 1)
			statusFlag++;
	}
}
@def_
@def $macro261()
$LICENSE()
$HEAD()

void castor(register short);
void pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;
short           result;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, no return value, illegal 
 */
{
	register short  i = 1;

	castor(i);
	if (i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(register short variable)
{
	if (--counter) {
		pollux(variable);
		if (variable != 1)
			statusFlag++;
	}
}

void pollux(register short variable)
{
	if (--counter) {
		castor(variable);
		if (variable != 1)
			statusFlag++;
	}
}
@def_
@def $macro262()
$LICENSE()
$HEAD()

int castor(register short);
int pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, return value, legal, no function
 * declaration 
 */
{
	register short  i = 1;
	short           result = 0;

	result = castor(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(register short variable)
{
	register short  ii = variable + 3;
	short           result = 0;

	if (--counter) {
		result = pollux(ii);
		if (result != 5 || ii != 4)
			statusFlag++;
	}
	return ++variable;
}

int pollux(register short variable)
{
	register short  iii = variable - 3;
	short           result = 0;

	if (--counter) {
		result = castor(iii);
		if (result != 2 || iii != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro263()
$LICENSE()
$HEAD()

short castor(register short);
short pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, return value, legal, function declared
 * to return an integer 
 */
{
	register short  i = 1;
	short           result = 0;

	result = castor(i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(register short variable)
{
	register short  ii = variable + 3;
	short           result = 0;

	if (--counter) {
		result = pollux(ii);
		if (result != 5 || ii != 4)
			statusFlag++;
	}
	return ++variable;
}

short pollux(register short variable)
{
	register short  iii = variable - 3;
	short           result = 0;

	if (--counter) {
		result = castor(iii);
		if (result != 2 || iii != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro264()
$LICENSE()
$HEAD()

char *castor(register short);
char *pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	register short  i = 2;

	s = castor(i);
	if (*s != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(register short variable)
{
	register short  ii = variable + 4;
	char           *s;

	if (--counter) {
		s = pollux(ii);
		if (*s != '6' || variable != 2)
			statusFlag++;
	}
	return numbers + variable--;
}

char *pollux(register short variable)
{
	register short  iii = variable - 4;
	char           *s;

	if (--counter) {
		s = castor(iii);
		if (*s != '2' || variable != 6)
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro265()
$LICENSE()
$HEAD()

int castor(short (*) (short), register short);
int pollux(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	register short  i = 1;
	short           result = 0;

	result = castor(increment, i);
	if (result != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), register short variable)
{
	register short  ii = variable + 8;
	short           result = 0;

	if (--counter) {
		result = pollux(function, ii);
		if (result != 10 || ii != 9)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), register short variable)
{
	register short  iii = variable - 8;
	short           result = 0;

	if (--counter) {
		result = castor(function, iii);
		if (result != 2 || iii != 1)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro266()
$LICENSE()
$HEAD()

int castor(register short);
int pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	register short  i = 1;

	if (castor(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(register short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		if (pollux(ii) != 5 || ii != 4)
			statusFlag++;
	}
	return ++variable;
}

int pollux(register short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		if (castor(iii) != 2 || iii != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro267()
$LICENSE()
$HEAD()

short castor(register short);
short pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	register short  i = 1;

	if (castor(i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(register short variable)
{
	register short  ii = variable + 3;

	if (--counter) {
		if (pollux(ii) != 5 || ii != 4)
			statusFlag++;
	}
	return ++variable;
}

short pollux(register short variable)
{
	register short  iii = variable - 3;

	if (--counter) {
		if (castor(iii) != 2 || iii != 1)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro268()
$LICENSE()
$HEAD()

char *castor(register short);
char *pollux(register short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	register short  i = 2;

	if (*castor(i) != '2' || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(register short variable)
{
	register short  ii = variable + 4;

	if (--counter) {
		if (*pollux(ii) != '6' || ii != 6)
			statusFlag++;
	}
	return numbers + variable--;
}

char *pollux(register short variable)
{
	register short  iii = variable - 4;

	if (--counter) {
		if (*castor(iii) != '2' || iii != 2)
			statusFlag++;
	}
	return numbers + variable--;
}
@def_
@def $macro269()
$LICENSE()
$HEAD()

int castor(short (*) (short), register short);
int pollux(short (*) (short), register short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: registered variable, mistaken as called by address instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	register short  i = 1;

	if (castor(increment, i) != 2 || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), register short variable)
{
	register short  ii = variable + 10;

	if (--counter) {
		if (pollux(function, ii) != 12 || ii != 11)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), register short variable)
{
	register short  iii = variable - 10;

	if (--counter) {
		if (castor(function, iii) != 2 || iii != 1)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_

@def $testout()
#ifdef unix
#include<stdio.h>
#include<float.h>
#define printok() printf("@OK@\n")
#define printno() printf("@NG@\n")
#define ABS(a) ((a > 0)? (a) : (-(a)))
#define MAX(a, b) ((a > b)? (a) : (b))
#define TGEN_FLT_EQ(a, b) ( ((a)==(b)) || ABS(((a) - (b))) / MAX( ABS(a), ABS(b) ) <= FLT_EPSILON )
#endif
@def_

@dir c89.4-2-03
@file >>def.h $macro0() @file_
@file >>fdef.h $macro1() @file_
@file >>ft1301.c $macro2() @file_
@file >>ft1302.c $macro3() @file_
@file >>ft1304.c $macro4() @file_
@file >>ft1306.c $macro5() @file_
@file >>ft1308.c $macro6() @file_
@file >>ft1310.c $macro7() @file_
@file >>ft1311.c $macro8() @file_
@file >>ft1312.c $macro9() @file_
@file >>ft1314.c $macro10() @file_
@file >>ft1316.c $macro11() @file_
@file >>ft1318.c $macro12() @file_
@file >>ft1320.c $macro13() @file_
@file >>ft1321.c $macro14() @file_
@file >>ft1322.c $macro15() @file_
@file >>ft1324.c $macro16() @file_
@file >>ft1326.c $macro17() @file_
@file >>ft1328.c $macro18() @file_
@file >>ft1330.c $macro19() @file_
@file >>ft1401.c $macro20() @file_
@file >>ft1402.c $macro21() @file_
@file >>ft1404.c $macro22() @file_
@file >>ft1406.c $macro23() @file_
@file >>ft1408.c $macro24() @file_
@file >>ft1410.c $macro25() @file_
@file >>ft1411.c $macro26() @file_
@file >>ft1412.c $macro27() @file_
@file >>ft1414.c $macro28() @file_
@file >>ft1416.c $macro29() @file_
@file >>ft1418.c $macro30() @file_
@file >>ft1420.c $macro31() @file_
@file >>ft1421.c $macro32() @file_
@file >>ft1422.c $macro33() @file_
@file >>ft1424.c $macro34() @file_
@file >>ft1426.c $macro35() @file_
@file >>ft1428.c $macro36() @file_
@file >>ft1430.c $macro37() @file_
@file >>ft1501.c $macro38() @file_
@file >>ft1504.c $macro39() @file_
@file >>ft1506.c $macro40() @file_
@file >>ft1508.c $macro41() @file_
@file >>ft1510.c $macro42() @file_
@file >>ft1511.c $macro43() @file_
@file >>ft1512.c $macro44() @file_
@file >>ft1514.c $macro45() @file_
@file >>ft1516.c $macro46() @file_
@file >>ft1518.c $macro47() @file_
@file >>ft1520.c $macro48() @file_
@file >>ft1521.c $macro49() @file_
@file >>ft1522.c $macro50() @file_
@file >>ft1524.c $macro51() @file_
@file >>ft1526.c $macro52() @file_
@file >>ft1528.c $macro53() @file_
@file >>ft1530.c $macro54() @file_
@file >>lt1301.c $macro55() @file_
@file >>lt1302.c $macro56() @file_
@file >>lt1304.c $macro57() @file_
@file >>lt1306.c $macro58() @file_
@file >>lt1308.c $macro59() @file_
@file >>lt1310.c $macro60() @file_
@file >>lt1311.c $macro61() @file_
@file >>lt1312.c $macro62() @file_
@file >>lt1314.c $macro63() @file_
@file >>lt1316.c $macro64() @file_
@file >>lt1318.c $macro65() @file_
@file >>lt1320.c $macro66() @file_
@file >>lt1321.c $macro67() @file_
@file >>lt1322.c $macro68() @file_
@file >>lt1324.c $macro69() @file_
@file >>lt1326.c $macro70() @file_
@file >>lt1328.c $macro71() @file_
@file >>lt1330.c $macro72() @file_
@file >>lt1401.c $macro73() @file_
@file >>lt1402.c $macro74() @file_
@file >>lt1404.c $macro75() @file_
@file >>lt1406.c $macro76() @file_
@file >>lt1408.c $macro77() @file_
@file >>lt1410.c $macro78() @file_
@file >>lt1411.c $macro79() @file_
@file >>lt1412.c $macro80() @file_
@file >>lt1414.c $macro81() @file_
@file >>lt1416.c $macro82() @file_
@file >>lt1418.c $macro83() @file_
@file >>lt1420.c $macro84() @file_
@file >>lt1421.c $macro85() @file_
@file >>lt1422.c $macro86() @file_
@file >>lt1424.c $macro87() @file_
@file >>lt1426.c $macro88() @file_
@file >>lt1428.c $macro89() @file_
@file >>lt1430.c $macro90() @file_
@file >>lt1501.c $macro91() @file_
@file >>lt1504.c $macro92() @file_
@file >>lt1506.c $macro93() @file_
@file >>lt1508.c $macro94() @file_
@file >>lt1510.c $macro95() @file_
@file >>lt1511.c $macro96() @file_
@file >>lt1512.c $macro97() @file_
@file >>lt1514.c $macro98() @file_
@file >>lt1516.c $macro99() @file_
@file >>lt1518.c $macro100() @file_
@file >>lt1520.c $macro101() @file_
@file >>lt1521.c $macro102() @file_
@file >>lt1522.c $macro103() @file_
@file >>lt1524.c $macro104() @file_
@file >>lt1526.c $macro105() @file_
@file >>lt1528.c $macro106() @file_
@file >>lt1530.c $macro107() @file_
@file >>t1303.c $macro108() @file_
@file >>t1304.c $macro109() @file_
@file >>t1305.c $macro110() @file_
@file >>t1306.c $macro111() @file_
@file >>t1307.c $macro112() @file_
@file >>t1308.c $macro113() @file_
@file >>t1309.c $macro114() @file_
@file >>t1310.c $macro115() @file_
@file >>t1313.c $macro116() @file_
@file >>t1314.c $macro117() @file_
@file >>t1315.c $macro118() @file_
@file >>t1316.c $macro119() @file_
@file >>t1317.c $macro120() @file_
@file >>t1318.c $macro121() @file_
@file >>t1319.c $macro122() @file_
@file >>t1320.c $macro123() @file_
@file >>t1323.c $macro124() @file_
@file >>t1324.c $macro125() @file_
@file >>t1325.c $macro126() @file_
@file >>t1326.c $macro127() @file_
@file >>t1327.c $macro128() @file_
@file >>t1328.c $macro129() @file_
@file >>t1329.c $macro130() @file_
@file >>t1330.c $macro131() @file_
@file >>t1403.c $macro132() @file_
@file >>t1404.c $macro133() @file_
@file >>t1405.c $macro134() @file_
@file >>t1406.c $macro135() @file_
@file >>t1407.c $macro136() @file_
@file >>t1408.c $macro137() @file_
@file >>t1409.c $macro138() @file_
@file >>t1410.c $macro139() @file_
@file >>t1413.c $macro140() @file_
@file >>t1414.c $macro141() @file_
@file >>t1415.c $macro142() @file_
@file >>t1416.c $macro143() @file_
@file >>t1417.c $macro144() @file_
@file >>t1418.c $macro145() @file_
@file >>t1419.c $macro146() @file_
@file >>t1420.c $macro147() @file_
@file >>t1423.c $macro148() @file_
@file >>t1424.c $macro149() @file_
@file >>t1425.c $macro150() @file_
@file >>t1426.c $macro151() @file_
@file >>t1427.c $macro152() @file_
@file >>t1428.c $macro153() @file_
@file >>t1429.c $macro154() @file_
@file >>t1430.c $macro155() @file_
@file >>t1503.c $macro156() @file_
@file >>t1504.c $macro157() @file_
@file >>t1505.c $macro158() @file_
@file >>t1506.c $macro159() @file_
@file >>t1507.c $macro160() @file_
@file >>t1508.c $macro161() @file_
@file >>t1509.c $macro162() @file_
@file >>t1510.c $macro163() @file_
@file >>t1513.c $macro164() @file_
@file >>t1514.c $macro165() @file_
@file >>t1515.c $macro166() @file_
@file >>t1516.c $macro167() @file_
@file >>t1517.c $macro168() @file_
@file >>t1518.c $macro169() @file_
@file >>t1519.c $macro170() @file_
@file >>t1520.c $macro171() @file_
@file >>t1523.c $macro172() @file_
@file >>t1524.c $macro173() @file_
@file >>t1525.c $macro174() @file_
@file >>t1526.c $macro175() @file_
@file >>t1527.c $macro176() @file_
@file >>t1528.c $macro177() @file_
@file >>t1529.c $macro178() @file_
@file >>t1530.c $macro179() @file_
@file >>t1601.c $macro180() @file_
@file >>t1602.c $macro181() @file_
@file >>t1603.c $macro182() @file_
@file >>t1604.c $macro183() @file_
@file >>t1605.c $macro184() @file_
@file >>t1606.c $macro185() @file_
@file >>t1607.c $macro186() @file_
@file >>t1608.c $macro187() @file_
@file >>t1609.c $macro188() @file_
@file >>t1610.c $macro189() @file_
@file >>t1611.c $macro190() @file_
@file >>t1612.c $macro191() @file_
@file >>t1613.c $macro192() @file_
@file >>t1614.c $macro193() @file_
@file >>t1615.c $macro194() @file_
@file >>t1616.c $macro195() @file_
@file >>t1617.c $macro196() @file_
@file >>t1618.c $macro197() @file_
@file >>t1619.c $macro198() @file_
@file >>t1620.c $macro199() @file_
@file >>t1621.c $macro200() @file_
@file >>t1622.c $macro201() @file_
@file >>t1623.c $macro202() @file_
@file >>t1624.c $macro203() @file_
@file >>t1625.c $macro204() @file_
@file >>t1626.c $macro205() @file_
@file >>t1627.c $macro206() @file_
@file >>t1628.c $macro207() @file_
@file >>t1629.c $macro208() @file_
@file >>t1630.c $macro209() @file_
@file >>t1701.c $macro210() @file_
@file >>t1702.c $macro211() @file_
@file >>t1703.c $macro212() @file_
@file >>t1704.c $macro213() @file_
@file >>t1705.c $macro214() @file_
@file >>t1706.c $macro215() @file_
@file >>t1707.c $macro216() @file_
@file >>t1708.c $macro217() @file_
@file >>t1709.c $macro218() @file_
@file >>t1710.c $macro219() @file_
@file >>t1711.c $macro220() @file_
@file >>t1712.c $macro221() @file_
@file >>t1713.c $macro222() @file_
@file >>t1714.c $macro223() @file_
@file >>t1715.c $macro224() @file_
@file >>t1716.c $macro225() @file_
@file >>t1717.c $macro226() @file_
@file >>t1718.c $macro227() @file_
@file >>t1719.c $macro228() @file_
@file >>t1720.c $macro229() @file_
@file >>t1721.c $macro230() @file_
@file >>t1722.c $macro231() @file_
@file >>t1723.c $macro232() @file_
@file >>t1724.c $macro233() @file_
@file >>t1725.c $macro234() @file_
@file >>t1726.c $macro235() @file_
@file >>t1727.c $macro236() @file_
@file >>t1728.c $macro237() @file_
@file >>t1729.c $macro238() @file_
@file >>t1730.c $macro239() @file_
@file >>t1801.c $macro240() @file_
@file >>t1802.c $macro241() @file_
@file >>t1803.c $macro242() @file_
@file >>t1804.c $macro243() @file_
@file >>t1805.c $macro244() @file_
@file >>t1806.c $macro245() @file_
@file >>t1807.c $macro246() @file_
@file >>t1808.c $macro247() @file_
@file >>t1809.c $macro248() @file_
@file >>t1810.c $macro249() @file_
@file >>t1811.c $macro250() @file_
@file >>t1812.c $macro251() @file_
@file >>t1813.c $macro252() @file_
@file >>t1814.c $macro253() @file_
@file >>t1815.c $macro254() @file_
@file >>t1816.c $macro255() @file_
@file >>t1817.c $macro256() @file_
@file >>t1818.c $macro257() @file_
@file >>t1819.c $macro258() @file_
@file >>t1820.c $macro259() @file_
@file >>t1821.c $macro260() @file_
@file >>t1822.c $macro261() @file_
@file >>t1823.c $macro262() @file_
@file >>t1824.c $macro263() @file_
@file >>t1825.c $macro264() @file_
@file >>t1826.c $macro265() @file_
@file >>t1827.c $macro266() @file_
@file >>t1828.c $macro267() @file_
@file >>t1829.c $macro268() @file_
@file >>t1830.c $macro269() @file_
@file >>testout.h $testout() @file_
@dir_
