@comment
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
ishiura-gcc@ksc.kwansei.ac.jp

This file was written by Yuki Uchiyama. (ishiura-gcc@ksc.kwansei.ac.jp)
@comment_

@def $LICENSE()
/*
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
hikichi@sra.co.jp(Nobuyuki Hikichi)

This file was written by several people in Software Research Associates,
Inc. Japan in several years.
*/
@def_

@def $HEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "def.h"
@def_

@def $FHEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "fdef.h"
@def_

@def $macro0()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
#define NoMistake 00
@def_

@def $macro1()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
float           OK_f = 1.0;
float           NO_f = 0.0;
#define NoMistake 00
@def_

@def $macro2()
$LICENSE()
$FHEAD()
short           statusFlag = NoMistake;
/*float           dummy();*/

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);
float dummy(float);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and legal 
 */
{
	levelOneNodeOne(dummy(1.0));
	levelOneNodeTwo(dummy(2.0));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	levelTwoNodeOne(dummy(3.0));
	levelTwoNodeTwo(dummy(4.0));
}

void levelOneNodeTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	levelTwoNodeThree(dummy(5.0));
	levelTwoNodeFour(dummy(6.0));
}

void levelTwoNodeOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	levelThreeLeafOne(dummy(7.0));
	levelThreeLeafTwo(dummy(8.0));
}

void levelTwoNodeTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	levelThreeLeafThree(dummy(9.0));
	levelThreeLeafFour(dummy(10.0));
}

void levelTwoNodeThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	levelThreeLeafFive(dummy(11.0));
	levelThreeLeafSix(dummy(12.0));
}

void levelTwoNodeFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	levelThreeLeafSeven(dummy(13.0));
	levelThreeLeafEight(dummy(14.0));
}

void levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
dummy(float argument)
{
	return argument;
}
@def_
@def $macro3()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
/*float	dummy();*/

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);
float dummy(float);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	float           i = 0.0;

	/*i = levelOneNodeOne(dummy(1.0));*/
	/*i = levelOneNodeTwo(dummy(2.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	/*i = levelTwoNodeOne(dummy(3.0));
	i = levelTwoNodeTwo(dummy(4.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelOneNodeTwo(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	/*i = levelTwoNodeThree(dummy(5.0));
	i = levelTwoNodeFour(dummy(6.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeOne(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	/*i = levelThreeLeafOne(dummy(7.0));
	i = levelThreeLeafTwo(dummy(8.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeTwo(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	/*i = levelThreeLeafThree(dummy(9.0));
	i = levelThreeLeafFour(dummy(10.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeThree(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	/*i = levelThreeLeafFive(dummy(11.0));
	i = levelThreeLeafSix(dummy(12.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeFour(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	/*i = levelThreeLeafSeven(dummy(13.0));
	i = levelThreeLeafEight(dummy(14.0));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
dummy(float argument)
{
	return argument;
}
@def_
@def $macro4()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
/*float	dummy();*/

float levelOneNodeOne(float);
float levelOneNodeTwo(float);
float levelTwoNodeOne(float);
float levelTwoNodeTwo(float);
float levelTwoNodeThree(float);
float levelTwoNodeFour(float);
float levelThreeLeafOne(float);
float levelThreeLeafTwo(float);
float levelThreeLeafThree(float);
float levelThreeLeafFour(float);
float levelThreeLeafFive(float);
float levelThreeLeafSix(float);
float levelThreeLeafSeven(float);
float levelThreeLeafEight(float);
float dummy(float);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, Float function declaration 
 */
{
	float           i = 0.0;
	/*float           levelOneNodeOne(), levelOneNodeTwo();*/

	i = levelOneNodeOne(dummy(1.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelOneNodeTwo(dummy(2.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
levelOneNodeOne(float argument)
{
	float           i = 0.0;
	/*float           levelTwoNodeOne(), levelTwoNodeTwo();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(dummy(3.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeTwo(dummy(4.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelOneNodeTwo(float argument)
{
	float           i = 0.0;
	/*float           levelTwoNodeThree(), levelTwoNodeFour();*/

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(dummy(5.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeFour(dummy(6.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeOne(float argument)
{
	float           i = 0.0;
	/*float           levelThreeLeafOne(), levelThreeLeafTwo();*/

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(dummy(7.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafTwo(dummy(8.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeTwo(float argument)
{
	float           i = 0.0;
	/*float           levelThreeLeafThree(), levelThreeLeafFour();*/

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(dummy(9.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafFour(dummy(10.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeThree(float argument)
{
	float           i = 0.0;
	/*float           levelThreeLeafFive(), levelThreeLeafSix();*/

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(dummy(11.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafSix(dummy(12.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeFour(float argument)
{
	float           i = 0.0;
	/*float           levelThreeLeafSeven(), levelThreeLeafEight();*/

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafEight(dummy(14.0));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
	return argument;
}

float 
dummy(float argument)
{
	return argument;
}
@def_
@def $macro5()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
/*float	twelve();*/

float dummy1(float (*)(float), float);
float divide4(float);
float dummy2(float (*)(float), float);
float divide2(float);
float twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning a
 * float 
 */
{
	/*float           i, divide4(), dummy1();*/
	float i;

	i = dummy1(divide4, twelve());
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy1(float (*func)(float), float Float)
{
	float           i = Float;

	i = (*func) (twelve());
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return i;
}

float 
divide4(float Float)
{
	/*float           divide2(), dummy2();*/

	return dummy2(divide2, Float) / 2.0;
}

float 
dummy2(float (*func)(float), float Float)
{
	float           i = Float;

	i = (*func) (twelve());
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return i;
}

float 
divide2(float Float)
{
	return Float / 2.0;
}

float 
twelve(void)
{
	return 12.0;
}
@def_
@def $macro6()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           object = 1.0;
/*float	mirror();*/

float levelOneNodeOne(float);
float levelTwoNodeOne(float);
float levelThreeLeafOne(float);
float mirror(float);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	/*float           levelOneNodeOne();*/
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(mirror(object));
	arg_b = object;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
levelOneNodeOne(float argument)
{
	float           object = argument + 2.0;
	/*float           levelTwoNodeOne();*/
	float           arg_a, arg_b;

	arg_a = levelTwoNodeOne(mirror(object));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeOne(float argument)
{
	float           object = argument + 4.0;
	/*float           levelThreeLeafOne();*/
	float           arg_a, arg_b;

	arg_a = levelThreeLeafOne(mirror(object));
	arg_b = 7.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return argument;
}

float 
mirror(float argument)
{
	return argument;
}
@def_
@def $macro7()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
/*float	twelve();*/

float dummy1(float (*)(float), float);
float divide4(float);
float dummy2(float (*)(float), float);
float divide2(float);
float twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a float 
 */
{
	/*float           divide4(), dummy1();*/
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, twelve());
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy1(float (*func)(float), float Float)
{
	float           i = Float;

	if ( !(TGEN_FLT_EQ((i = (*func) (twelve())), 3.0)) )
		statusFlag++;
	return i;
}

float 
divide4(float Float)
{
	/*float           divide2(), dummy2();*/

	return dummy2(divide2, Float) / 2.0;
}

float 
dummy2(float (*func)(float), float Float)
{
	float           i = Float;

	if ( !(TGEN_FLT_EQ((i = (*func) (twelve())), 6.0)) )
		statusFlag++;
	return i;
}

float 
divide2(float Float)
{
	return Float / 2.0;
}

float 
twelve(void)
{
	return 12.0;
}
@def_
@def $macro8()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
/*float           un();*/

void recursiveFunction(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, no return value, legal 
 */
{
	recursiveFunction(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(un());
}

float 
un(void)
{
	static float    un = 1.0;
	return un;
}
@def_
@def $macro9()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;
/*float           un();*/

int recursiveFunction(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, no return value, illegal 
 */
{
	result = recursiveFunction(un());
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		result = recursiveFunction(un());
	return;
}

float 
un()
{
	static float    un = 1.0;
	return un;
}
@def_
@def $macro10()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
/*float	un();*/

float recursiveFunction(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, legal, Float function declaration 
 */
{
	float           i = 0.0;
	/*float           recursiveFunction();*/

	i = recursiveFunction(un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
recursiveFunction(float argument)
{
	float           i;
	/*float           recursiveFunction();*/

	if (--counter) {
		i = recursiveFunction(un());
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return ++argument;
}

float 
un(void)
{
	static float    un = 1.0;
	return un;
}
@def_
@def $macro11()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
/*float	un();*/

float dummy(float (*)(float), float);
float increment(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning a float 
 */
{
	/*float           i, increment(), dummy();*/
	float i;

	i = dummy(increment, un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy(float (*function)(float), float argument)
{
	/*float           i, dummy();*/
	float i;

	if (--counter) {
		i = dummy(function, un());
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
un(void)
{
	float           un = 1.0;
	return un;
}
@def_
@def $macro12()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
/*float           un();*/

float recursiveFunction(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	/*float           recursiveFunction();*/
	float           arg_a, arg_b;

	arg_a = recursiveFunction(un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
recursiveFunction(float argument)
{
	/*float           recursiveFunction();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(un());
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++argument;
}

float 
un(void)
{
	static float    un = 1.0;
	return un;
}
@def_
@def $macro13()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
/*float           un();*/

float dummy(float (*)(float), float);
float increment(float);
float un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning a
 * float 
 */
{
	/*float           increment(), dummy();*/
	float           arg_a, arg_b;

	arg_a = dummy(increment, un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy(float (*function)(float), float argument)
{
	/*float           dummy();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, un());
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
un(void)
{
	static float    un = 1.0;
	return un;
}
@def_
@def $macro14()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

void castor(float);
void pollux(float);
float un(void);
float deux(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, no return value, legal 
 */
{
	/*float           un();*/

	castor(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float argument)
{
	/*float           deux();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		pollux(deux());
}

void pollux(float argument)
{
	/*float           un();*/

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	if (--counter)
		castor(un());
}

float 
un(void)
{
	float           un = 1.0;
	return un;
}

float 
deux(void)
{
	float           deux = 2.0;
	return deux;
}
@def_
@def $macro15()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;



void castor(float);
void pollux(float);
float un(void);
float deux(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, no return value, illegal 
 */
{
	/*float           un();*/

	/*result = castor(un());*/
	if ( !(TGEN_FLT_EQ(result, 0.0)) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float argument)
{
	/*float           deux();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	/*if (--counter)
		result = pollux(deux());*/
}

void pollux(float argument)
{
	/*float           un();*/

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	/*if (--counter)
		result = castor(un());*/
}

float 
un(void)
{
	float           un = 1.0;
	return un;
}

float 
deux(void)
{
	float           deux = 2.0;
	return deux;
}
@def_
@def $macro16()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

float castor(float);
float pollux(float);
float rebound(float);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return a float 
 */
{
	float i = 0.0;	
	/*float           i = 0.0, castor(), rebound();*/

	i = castor(rebound(1.0));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float argument)
{
	float i;	
	/*float           i, pollux(), rebound();*/

	if (--counter) {
		i = pollux(rebound(4.0));
		if ( !(TGEN_FLT_EQ(i, 5.0)) )
			statusFlag++;
	}
	return ++argument;
}

float 
pollux(float argument)
{
	float i;	
	/*float           i, rebound(), castor();*/

	if (--counter) {
		i = castor(rebound(1.0));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return ++argument;
}

float 
rebound(float argument)
{
	return argument;
}
@def_
@def $macro17()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

float castor(float (*)(float), float);
float pollux(float (*)(float), float);
float increment(float);
float un(void);
float trois(void);
float neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning a float 
 */
{
	/*float           i, increment(), un();*/
	float i;
	/*float           castor();*/

	i = castor(increment, un());
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float (*function)(float), float argument)
{
	float           i;
	/*float neuf(), pollux();*/
	if (--counter) {
		i = pollux(function, neuf());
		if ( !(TGEN_FLT_EQ(i, 10.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
pollux(float (*function)(float), float argument)
{
	float i;
	/*float           i, trois(), castor();*/
	if (--counter) {
		i = castor(function, trois());
		if ( !(TGEN_FLT_EQ(i, 4.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
un(void)
{
	return Un;
}

float 
trois(void)
{
	return Trois;
}

float 
neuf(void)
{
	return Neuf;
}
@def_
@def $macro18()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

float castor(float);
float pollux(float);
float numero(float);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a float 
 */
{
	/*float           castor(), numero();*/
	float           arg_a, arg_b;

	arg_a = castor(numero((float) Un));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float argument)
{
	/*float           pollux(), numero();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(numero((float) Quatre));
		arg_b = 5.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++argument;
}

float 
pollux(float argument)
{
	/*float           castor(), numero();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(numero((float) Un));
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++argument;
}

float 
numero(float questCa)
{
	return questCa;
}
@def_
@def $macro19()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

float castor(float (*)(float), float);
float pollux(float (*)(float), float);
float increment(float);
float un(void);
float trois(void);
float neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning a float 
 */
{
	/*float           increment(), un(), castor();*/
	float           arg_a, arg_b;

	arg_a = castor(increment, un());
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float (*function)(float), float argument)
{
	/*float           neuf(), pollux();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(function, neuf());
		arg_b = 10.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(argument);
}

float 
pollux(float (*function)(float), float argument)
{
	/*float           trois(), castor();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(function, trois());
		arg_b = 4.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
un(void)
{
	static float    un = 1.0;
	return un;
}

float 
trois(void)
{
	static float    trois = 3.0;
	return trois;
}

float 
neuf(void)
{
	static float    neuf = 9.0;
	return neuf;
}
@def_
@def $macro20()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

void recursiveFunction(float);
float indeterminacy(float, float, float);

int main(void)
/*
 * test class: function as argument, variable order not determined instance  : recursive call, no return value, legal 
 */
{
	float           i = 0.0, a, b, c;
	/*float indeterminacy();*/

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(indeterminacy(a, b, c));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float argument)
{
	float           i = 0.0, a, b, c;
	/*float indeterminacy();*/
	 
	if ( !(TGEN_FLT_EQ(argument, -3.0)) )
		statusFlag++;
	if (--counter) {
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(indeterminacy(a, b, c));
	}
}

float 
indeterminacy(float uno, float dos, float tres)
{
	return uno + dos + tres;
}
@def_
@def $macro21()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and legal 
 */
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	levelOneNodeOne(uno(dos(tres(1.0))));
	levelOneNodeTwo(uno(dos(tres(2.0))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	levelTwoNodeOne(uno(dos(tres(3.0))));
	levelTwoNodeTwo(uno(dos(tres(4.0))));
}

void levelOneNodeTwo(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	levelTwoNodeThree(uno(dos(tres(5.0))));
	levelTwoNodeFour(uno(dos(tres(6.0))));
}

void levelTwoNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	levelThreeLeafOne(uno(dos(tres(7.0))));
	levelThreeLeafTwo(uno(dos(tres(8.0))));
}

void levelTwoNodeTwo(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	levelThreeLeafThree(uno(dos(tres(9.0))));
	levelThreeLeafFour(uno(dos(tres(10.0))));
}

void levelTwoNodeThree(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	levelThreeLeafFive(uno(dos(tres(11.0))));
	levelThreeLeafSix(uno(dos(tres(12.0))));
}

void levelTwoNodeFour(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	levelThreeLeafSeven(uno(dos(tres(13.0))));
	levelThreeLeafEight(uno(dos(tres(14.0))));
}

void levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro22()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
/*float           uno();
float           dos();
float           tres();*/


void levelOneNodeOne(float);
void levelOneNodeTwo(float);
void levelTwoNodeOne(float);
void levelTwoNodeTwo(float);
void levelTwoNodeThree(float);
void levelTwoNodeFour(float);
void levelThreeLeafOne(float);
void levelThreeLeafTwo(float);
void levelThreeLeafThree(float);
void levelThreeLeafFour(float);
void levelThreeLeafFive(float);
void levelThreeLeafSix(float);
void levelThreeLeafSeven(float);
void levelThreeLeafEight(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	float           i = 0.0;

	/*i = levelOneNodeOne(uno(dos(tres(1.0))));
	i = levelOneNodeTwo(uno(dos(tres(2.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float argument)
{

	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	/*i = levelTwoNodeOne(uno(dos(tres(3.0))));
	i = levelTwoNodeTwo(uno(dos(tres(4.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelOneNodeTwo(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	/*i = levelTwoNodeThree(uno(dos(tres(5.0))));
	i = levelTwoNodeFour(uno(dos(tres(6.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeOne(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	/*i = levelThreeLeafOne(uno(dos(tres(7.0))));
	i = levelThreeLeafTwo(uno(dos(tres(8.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeTwo(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	/*i = levelThreeLeafThree(uno(dos(tres(9.0))));
	i = levelThreeLeafFour(uno(dos(tres(10.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeThree(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	/*i = levelThreeLeafFive(uno(dos(tres(11.0))));
	i = levelThreeLeafSix(uno(dos(tres(12.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelTwoNodeFour(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	/*i = levelThreeLeafSeven(uno(dos(tres(13.0))));
	i = levelThreeLeafEight(uno(dos(tres(14.0))));*/
	if ( TGEN_FLT_EQ(i, 0.0) )
		i++;
}

void levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro23()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

float levelOneNodeOne(float);
float levelOneNodeTwo(float);
float levelTwoNodeOne(float);
float levelTwoNodeTwo(float);
float levelTwoNodeThree(float);
float levelTwoNodeFour(float);
float levelThreeLeafOne(float);
float levelThreeLeafTwo(float);
float levelThreeLeafThree(float);
float levelThreeLeafFour(float);
float levelThreeLeafFive(float);
float levelThreeLeafSix(float);
float levelThreeLeafSeven(float);
float levelThreeLeafEight(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, Float function
 * declaration 
 */
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelOneNodeOne(), levelOneNodeTwo();*/

	i = levelOneNodeOne(uno(dos(tres(1.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelOneNodeTwo(uno(dos(tres(2.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
levelOneNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelTwoNodeOne(), levelTwoNodeTwo();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeTwo(uno(dos(tres(4.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelOneNodeTwo(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelTwoNodeThree(), levelTwoNodeFour();*/

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelTwoNodeFour(uno(dos(tres(6.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelThreeLeafOne(), levelThreeLeafTwo();*/

	if ( !(TGEN_FLT_EQ(argument, 3.0)) )
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafTwo(uno(dos(tres(8.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeTwo(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelThreeLeafThree(), levelThreeLeafFour();*/

	if ( !(TGEN_FLT_EQ(argument, 4.0)) )
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafFour(uno(dos(tres(10.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeThree(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelThreeLeafFive(), levelThreeLeafSix();*/

	if ( !(TGEN_FLT_EQ(argument, 5.0)) )
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafSix(uno(dos(tres(12.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeFour(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           i = 0.0;
	/*float           levelThreeLeafSeven(), levelThreeLeafEight();*/

	if ( !(TGEN_FLT_EQ(argument, 6.0)) )
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	i = 0.0;
	i = levelThreeLeafEight(uno(dos(tres(14.0))));
	if ( TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafTwo(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 8.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafThree(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 9.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafFour(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 10.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafFive(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 11.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafSix(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 12.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafSeven(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 13.0)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafEight(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 14.0)) )
		statusFlag++;
	return argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro24()
$LICENSE()
$FHEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;
/*float           half();*/
/*float           twoTimes();*/

float dummy1(float (*)(float), float);
float divide4(float);
float dummy2(float (*)(float), float);
float divide2(float);
float twentyFour(void);
float twoTimes(float);
float half(float);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning a float 
 */
{
	/*float           twentyFour();*/

	/*float           i, divide4(), dummy1();*/
	float i;
	
	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy1(float (*func)(float), float Float)
{
	float           i = Float;

	i = (*func) (half(twoTimes(i)));
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return i;
}

float 
divide4(float Float)
{
	/*float           divide2(), dummy2();*/

	return dummy2(divide2, Float) / 2.0;
}

float 
dummy2(float (*func)(float), float Float)
{
	float           i = Float;

	i = (*func) (twoTimes(half(i)));
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return i;
}

float 
divide2(float Float)
{
	return Float / 2.0;
}

float 
twentyFour(void)
{
	return TwoDozen;
}

float 
twoTimes(float argument)
{
	return 2.0 * argument;
}

float 
half(float argument)
{
	return argument / 2.0;
}
@def_
@def $macro25()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           object = 1.0;

float levelOneNodeOne(float);
float levelTwoNodeOne(float);
float levelThreeLeafOne(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, Float
 * function declaration 
 */
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	/*float           levelOneNodeOne();*/
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(uno(dos(tres(object))));
	arg_b = object;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
levelOneNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           object = argument + 2.0;
	/*float           levelTwoNodeOne();*/
	float           arg_a, arg_b;

	arg_a = levelTwoNodeOne(uno(dos(tres(object))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return argument;
}

float 
levelTwoNodeOne(float argument)
{
	/*float           uno();*/
	/*float           dos();*/
	/*float           tres();*/
	float           object = argument + 4.0;
	/*float           levelThreeLeafOne();*/
	float           arg_a, arg_b;

	arg_a = levelThreeLeafOne(uno(dos(tres(object))));
	arg_b = 7.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return argument;
}

float 
levelThreeLeafOne(float argument)
{
	if ( !(TGEN_FLT_EQ(argument, 7.0)) )
		statusFlag++;
	return argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro26()
$LICENSE()
$FHEAD()

#define TwoDouzen 24.0
short           statusFlag = NoMistake;
/*float           half();*/
/*float           twoTimes();*/

float dummy1(float (*)(float), float);
float divide4(float);
float dummy2(float (*)(float), float);
float divide2(float);
float twoTimes(float);
float half(float);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a float 
 */
{
	/*float           divide4(), dummy1();*/
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, half(twoTimes(half(TwoDouzen))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy1(float (*func)(float), float Float)
{
	float           i;
	float           arg_a, arg_b;

	arg_a = (i = (*func) (twoTimes(half(Float))));
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return i;
}

float 
divide4(float Float)
{
	/*float           divide2(), dummy2();*/

	return dummy2(divide2, Float) / 2.0;
}

float 
dummy2(float (*func)(float), float Float)
{
	float           i;
	float           arg_a, arg_b;

	arg_a = (i = (*func) (twoTimes(half(Float))));
	arg_b = 6.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	return i;
}

float 
divide2(float Float)
{
	return Float / 2.0;
}

float 
twoTimes(float argument)
{
	return 2.0 * argument;
}

float 
half(float argument)
{
	return argument / 2.0;
}
@def_
@def $macro27()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

void recursiveFunction(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, no return value, legal 
 */
{
	/*float           dos(), tres(), uno();*/
	recursiveFunction(uno(dos(tres(Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float argument)
{
	/*float           dos(), tres(), uno();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(uno(dos(tres(Un))));
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro28()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

int recursiveFunction(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, no return value, illegal 
 */
{
	/*float           uno(), dos(), tres();*/
	float           i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 1.0)) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(float argument)
{
	/*float           uno(), dos(), tres();*/
	float           i;

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 1.0)) )
			i++;
	}
	return;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro29()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

float recursiveFunction(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, Float function declaration 
 */
{
	/*float           uno(), dos(), tres();*/
	/*float           i, recursiveFunction();*/
	float i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
recursiveFunction(float argument)
{
	/*float           uno(), dos(), tres();*/
	/*float           i, recursiveFunction();*/
	float i;

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro30()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

float dummy(float (*)(float), float);
float increment(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning a float 
 */
{
	/*float           uno(), dos(), tres();*/
	/*float           i, increment(), dummy();*/
	float i;

	i = dummy(increment, uno(dos(tres(Un))));
	if ( !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy(float (*function)(float), float argument)
{
	/*float           uno(), dos(), tres();*/
	/*float           i, dummy();*/
	float i;
	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro31()
$LICENSE()
$FHEAD()

#define Un 1.0
short           statusFlag = NoMistake;
short           counter = 10;

float recursiveFunction(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	/*float           uno(), dos(), tres();*/
	/*float           recursiveFunction();*/
	float           arg_a, arg_b;

	arg_a = recursiveFunction(uno(dos(tres(Un))));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
recursiveFunction(float argument)
{
	/*float           uno(), dos(), tres();*/
	/*float           recursiveFunction();*/

	if (--counter)
		if ( !(TGEN_FLT_EQ(recursiveFunction(uno(dos(tres(Un)))), 2.0)) )
			statusFlag++;
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro32()
$LICENSE()
$FHEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

float dummy(float (*)(float), float);
float increment(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning a float 
 */
{
	/*float           increment(), uno(), dos(), tres(), dummy();*/
	float           arg_a, arg_b;

	arg_a = dummy(increment, uno(dos(tres((float) Un))));
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
dummy(float (*function)(float), float argument)
{
	/*float           uno(), dos(), tres(), dummy();*/

	if (--counter)
		if ( !(TGEN_FLT_EQ(dummy(function, uno(dos(tres((float) Un)))), 2.0)) )
			statusFlag++;
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro33()
$LICENSE()
$FHEAD()

#define Un   1
#define Deux 2
short           statusFlag = NoMistake;
short           counter = 10;

void castor(float);
void pollux(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, no return value, legal 
 */
{
	/*float           uno(), dos(), tres();*/

	castor(uno(dos(tres((float) Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float argument)
{
	/*float           uno(), dos(), tres();*/

	if ( !(TGEN_FLT_EQ(argument, 1.0)) )
		statusFlag++;
	if (--counter)
		pollux(uno(dos(tres((float) Deux))));
}

void pollux(float argument)
{
	/*float           uno(), dos(), tres();*/

	if ( !(TGEN_FLT_EQ(argument, 2.0)) )
		statusFlag++;
	if (--counter)
		castor(uno(dos(tres((float) Un))));
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro34()
$LICENSE()
$FHEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;
/*float           uno(), dos(), tres();*/

void castor(float);
void pollux(float);
float uno(float);
float dos(float);
float tres(void);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, no return value, illegal 
 */
{
	float           i;

	/*i = castor(uno(dos(tres())));*/
	if ( !(TGEN_FLT_EQ(i, 1.0)) )
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, Un)) )
		statusFlag++;
	if (--counter) {
		/*i = pollux(uno(dos(tres())));*/
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			i++;
	}
}

void pollux(float argument)
{
	float           i;

	if ( !(TGEN_FLT_EQ(argument, Un)) )
		statusFlag++;
	if (--counter) {
		/*i = castor(uno(dos(tres())));*/
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			i++;
	}
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(void)
{
	return Un;
}
@def_
@def $macro35()
$LICENSE()
$FHEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

float castor(float);
float pollux(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return a float 
 */
{
	float           i;
	/*float castor(), uno(), dos(), tres();*/

	i = castor(uno(dos(tres((float) Un))));
	if ( !(TGEN_FLT_EQ(i, Deux)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float argument)
{
	float           i;
	/*float pollux(), uno(), dos(), tres();*/

	if (--counter) {
		i = pollux(uno(dos(tres((float) Quatre))));
		if ( !(TGEN_FLT_EQ(i, Cinq)) )
			statusFlag++;
	}
	return ++argument;
}

float 
pollux(float argument)
{
	float           i;
	/*float uno(), dos(), tres();*/

	if (--counter) {
		i = castor(uno(dos(tres((float) Un))));
		if ( !(TGEN_FLT_EQ(i, Deux)) )
			statusFlag++;
	}
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro36()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

float castor(float (*)(float), float);
float pollux(float (*)(float), float);
float increment(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning a float 
 */
{
	/*float           i, increment(), uno(), dos(), tres(), castor();*/
	float i;

	i = castor(increment, uno(dos(tres((float) Un))));
	if ( !(TGEN_FLT_EQ(i, Un + 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float (*function)(float), float argument)
{
	/*float           i, uno(), dos(), tres(), pollux();*/
	float i;

	if (--counter) {
		i = pollux(function, uno(dos(tres((float) Neuf))));
		if ( !(TGEN_FLT_EQ(i, Neuf + 1.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
pollux(float (*function)(float), float argument)
{
	/*float           i, uno(), dos(), tres(), castor();*/
	float i;

	if (--counter) {
		i = castor(function, uno(dos(tres((float) Trois))));
		if ( !(TGEN_FLT_EQ(i, Trois + 1.0)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro37()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

float castor(float);
float pollux(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a
 * float 
 */
{
	/*float           castor(), uno(), dos(), tres();*/
	float           arg_a, arg_b;

	arg_a = castor(uno(dos(tres((float) Un))));
	arg_b = Deux;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float argument)
{
	/*float           pollux(), uno(), dos(), tres();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(uno(dos(tres((float) Quatre))));
		arg_b = Cinq;
		if ( !(TGEN_FLT_EQ(arg_a, arg_a)) )
			statusFlag++;
	}
	return ++argument;
}

float 
pollux(float argument)
{
	/*float           uno(), dos(), tres(), castor();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(uno(dos(tres((float) Un))));
		arg_b = Deux;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro38()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

float castor(float (*)(float), float);
float pollux(float (*)(float), float);
float increment(float);
float uno(float);
float dos(float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning a
 * float 
 */
{
	/*float           increment();*/
	/*float           uno(), dos(), tres(), castor();*/


	if ( !(TGEN_FLT_EQ(castor(increment, uno(dos(tres((float) Un)))), Deux)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float 
castor(float (*function)(float), float argument)
{
	/*float           uno(), dos(), tres(), pollux();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = pollux(function, uno(dos(tres((float) Neuf))));
		arg_b = Dix;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(argument);
}

float 
pollux(float (*function)(float), float argument)
{
	/*float           uno(), dos(), tres(), castor();*/
	float           arg_a, arg_b;

	if (--counter){
		arg_a = castor(function, uno(dos(tres((float) Trois))));
		arg_b = Quatre;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(argument);
}

float 
increment(float argument)
{
	return ++argument;
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float argument)
{
	return argument;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro39()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

void recursiveFunction(float);
float uno(float);
float dos(float, float, float);
float tres(float);

int main(void)
/*
 * test class: nested function as argument, random order instance  : recursive call, no return value, legal 
 */
{
	float           i = 0.0, a, b, c;
	/*float uno(), dos(), tres();*/
	

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float argument)
{
	float           i = 0.0, a, b, c;
	/*float uno(), dos(), tres();*/


	if ( !(TGEN_FLT_EQ(argument, -3.0)) )
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	}
}

float 
uno(float argument)
{
	return argument;
}

float 
dos(float uno, float dos, float tres)
{
	return uno + dos + tres;
}

float 
tres(float argument)
{
	return argument;
}
@def_
@def $macro40()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(unsigned);
void levelOneNodeTwo(unsigned);
void levelTwoNodeOne(unsigned);
void levelTwoNodeTwo(unsigned);
void levelTwoNodeThree(unsigned);
void levelTwoNodeFour(unsigned);
void levelThreeeafOne(unsigned);
void levelThreeeafTwo(unsigned);
void levelThreeeafThree(unsigned);
void levelThreeeafFour(unsigned);
void levelThreeeafFive(unsigned);
void levelThreeeafSix(unsigned);
void levelThreeeafSeven(unsigned);
void levelThreeeafEight(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, no return value and
 * legal 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;

	levelOneNodeOne((unsigned) (i - 2 * j - k));
	levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(unsigned variable)

{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(unsigned variable)

{
	unsigned        i = variable + 2;
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(unsigned variable)

{
	unsigned        i = variable * 2;
	if (variable != 3L)
		statusFlag++;
	levelThreeeafOne((i += 8) / 2);
	levelThreeeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(unsigned variable)

{
	unsigned        i = variable;
	if (variable != 4L)
		statusFlag++;
	levelThreeeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(unsigned variable)

{
	unsigned        i = variable--;
	if (variable != 4L)
		statusFlag++;
	levelThreeeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(unsigned variable)

{
	unsigned        i = variable / 2 - 1;
	if (variable != 6L)
		statusFlag++;
	levelThreeeafSeven(variable + i * (variable - i) - 1);
	levelThreeeafEight(i * (2 * variable - i) - variable);
}

void levelThreeeafOne(unsigned variable)

{
	if (variable != 7L)
		statusFlag++;
}

void levelThreeeafTwo(unsigned variable)

{
	if (variable != 8L)
		statusFlag++;
}

void levelThreeeafThree(unsigned variable)

{
	if (variable != 9L)
		statusFlag++;
}

void levelThreeeafFour(unsigned variable)

{
	if (variable != 10L)
		statusFlag++;
}

void levelThreeeafFive(unsigned variable)

{
	if (variable != 11L)
		statusFlag++;
}

void levelThreeeafSix(unsigned variable)

{
	if (variable != 12L)
		statusFlag++;
}

void levelThreeeafSeven(unsigned variable)

{
	if (variable != 13L)
		statusFlag++;
}

void levelThreeeafEight(unsigned variable)

{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro41()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

void levelOneNodeOne(unsigned);
void levelOneNodeTwo(unsigned);
void levelTwoNodeOne(unsigned);
void levelTwoNodeTwo(unsigned);
void levelTwoNodeThree(unsigned);
void levelTwoNodeFour(unsigned);
int levelThreeeafOne(unsigned);
int levelThreeeafTwo(unsigned);
int levelThreeeafThree(unsigned);
int levelThreeeafFour(unsigned);
int levelThreeeafFive(unsigned);
int levelThreeeafSix(unsigned);
int levelThreeeafSeven(unsigned);
int levelThreeeafEight(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, no return value and
 * illegal 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;

	levelOneNodeOne((unsigned) (i - 2 * j - k));
	levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(unsigned variable)

{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(unsigned variable)

{
	unsigned        i = variable + 2;

	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(unsigned variable)

{
	unsigned        i = variable * 2;

	if (variable != 3L)
		statusFlag++;
	result = levelThreeeafOne((i += 8) / 2);
	result = levelThreeeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(unsigned variable)

{
	unsigned        i = variable;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	result = levelThreeeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(unsigned variable)

{
	unsigned        i = variable--;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeeafFive((i + variable-- + 3) / 2 + 5);
	result = levelThreeeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(unsigned variable)

{
	unsigned        i = variable / 2 - 1;

	if (variable != 6L)
		statusFlag++;
	result = levelThreeeafSeven(variable + i * (variable - i) - 1);
	result = levelThreeeafEight(i * (2 * variable - i) - variable);
}

int levelThreeeafOne(unsigned variable)

{
	if (variable != 7L)
		statusFlag++;
	return;
}

int levelThreeeafTwo(unsigned variable)

{
	if (variable != 8L)
		statusFlag++;
	return;
}

int levelThreeeafThree(unsigned variable)

{
	if (variable != 9L)
		statusFlag++;
	return;
}

int levelThreeeafFour(unsigned variable)

{
	if (variable != 10L)
		statusFlag++;
	return;
}

int levelThreeeafFive(unsigned variable)

{
	if (variable != 11L)
		statusFlag++;
	return;
}

int levelThreeeafSix(unsigned variable)

{
	if (variable != 12L)
		statusFlag++;
	return;
}

int levelThreeeafSeven(unsigned variable)

{
	if (variable != 13L)
		statusFlag++;
	return;
}

int levelThreeeafEight(unsigned variable)

{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro42()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long levelOneNodeOne(unsigned);
long levelOneNodeTwo(unsigned);
long levelTwoNodeOne(unsigned);
long levelTwoNodeTwo(unsigned);
long levelTwoNodeThree(unsigned);
long levelTwoNodeFour(unsigned);
long levelThreeLeafOne(unsigned);
long levelThreeLeafTwo(unsigned);
long levelThreeLeafThree(unsigned);
long levelThreeLeafFour(unsigned);
long levelThreeLeafFive(unsigned);
long levelThreeLeafSix(unsigned);
long levelThreeLeafSeven(unsigned);
long levelThreeLeafEight(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, Long function declaration 
 */
{
	unsigned        i = 0;
	long            j = -1;
	unsigned        k = 1;
	long            result = 0;
	/*long            long            levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne((unsigned) (i - 2 * j - k));
	if (result != 1L)
		statusFlag++;
	result = levelOneNodeTwo((unsigned) ((i + j) * j + k));
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(unsigned variable)

{
	long            result = 0;
	/*long            levelTwoNodeOne(), levelTwoNodeTwo();*/
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3L)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4L)
		statusFlag++;
	return variable;
}

long 
levelOneNodeTwo(unsigned variable)

{
	unsigned        i = variable + 2;
	long            result = 0;
	/*long            levelTwoNodeThree(), levelTwoNodeFour();*/
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeOne(unsigned variable)

{
	unsigned        i = variable * 2;
	long            result = 0;
	/*long            levelThreeLeafOne(), levelThreeLeafTwo();*/
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeTwo(unsigned variable)

{
	unsigned        i = variable;
	long            result = 0;
	/*long            levelThreeLeafThree(), levelThreeLeafFour();*/
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeThree(unsigned variable)

{
	unsigned        i = variable--;
	long            result = 0;
	/*long            levelThreeLeafFive(), levelThreeLeafSix();*/
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12L)
		statusFlag++;
	return i;
}

long 
levelTwoNodeFour(unsigned variable)

{
	unsigned        i = variable / 2 - 1;
	long            result = 0;
	/*long            levelThreeLeafSeven(), levelThreeLeafEight();*/
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14L)
		statusFlag++;
	return variable;
}

long 
levelThreeLeafOne(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafTwo(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafThree(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafFour(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafFive(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafSix(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafSeven(unsigned variable)

{
	return variable;
}

long 
levelThreeLeafEight(unsigned variable)

{
	return variable;
}
@def_
@def $macro43()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

long            result;
short           statusFlag = NoMistake;

void recursiveFunction(unsigned, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, no return value, illegal 
 */
{
	unsigned        i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(unsigned variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro44()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
/*long            recursiveFunction();*/

long recursiveFunction(unsigned, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, Long function
 * declaration 
 */
{
	unsigned        i = 0;
	long            result = 0;
	long            counter = TimeLimit;
	/*long            recursiveFunction();*/

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(unsigned variable, long counter)
{
	long            result = 0;
	long            storage = variable + 1;
	/*long            recursiveFunction();*/

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro45()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

unsigned recursiveFunction(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	/*unsigned        recursiveFunction();*/
	long            i = -1;
	long            counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

unsigned 
recursiveFunction(long variable, long counter)
{
	long            storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1L)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro46()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(unsigned), unsigned);
long increment(unsigned);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * pointer to function returning a long 
 */
{
	/*long            increment(), dummy();*/
	char            i = 2, j = 1;

	if (dummy(increment, (unsigned) (j + i * j >= 10 || i - j > 0)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(unsigned), unsigned variable)
{
	unsigned        storage = variable;
	/*long            dummy();*/

	if (--counter)
		if (dummy(function, (unsigned) ((++variable - 1 == 0) + 1)) != 2L)
			statusFlag++;
	return function(storage);
}

long 
increment(unsigned variable)

{
	return ++variable;
}
@def_
@def $macro47()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;
#ifndef TimeLimit
#define TimeLimit 10
#endif

void castor(unsigned, long);
void pollux(unsigned, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, no return value, illegal 
 */
{
	unsigned        i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(unsigned variable, long counter)
{
	unsigned        i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		pollux((i & i == i) + (j == i), counter);
}

void pollux(unsigned variable, long counter)
{
	unsigned        i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		castor((i & i == i & i) + (j != i), counter);
}
@def_
@def $macro48()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

long castor(char, long);
long pollux(unsigned, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	long            counter = TimeLimit;
	long            result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(char variable, long counter)
{
	unsigned        i = 1, j = 2;
	long            result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1L)
			statusFlag++;
	}
	return variable;
}

long 
pollux(unsigned variable, long counter)
{
	char            i = 1, j = 2;
	long            result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2L)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro49()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long (*)(unsigned), unsigned);
long pollux(long (*)(unsigned), unsigned);
long increment(unsigned);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	unsigned        i = 0;
	/*long            increment(), castor();*/

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(unsigned), unsigned variable)
{
	long            ii = 0;
	/*long pollux();*/

	if (--counter) {
		ii = pollux(function, (unsigned) (variable + 2 * (ii + 2) * (variable + 1)));
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long 
pollux(long (*function)(unsigned), unsigned variable)
{
	long            iii = 0;
	/*long castor();*/

	if (--counter) {
		iii = castor(function, (unsigned) (variable - 2 * (iii + 2) * (11 - variable)));
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long 
increment(unsigned variable)

{
	return ++variable;
}
@def_
@def $macro50()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long);
long pollux(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	long            i = 0;
	/*long            castor();*/

	if (castor(++i && ++i ? --i : i + 2) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long variable)
{
	/*long            pollux();*/
	if (--counter) {
		if (pollux(2 * variable + 2L / variable) != 5L)
			statusFlag++;
	}
	return ++variable;
}

long 
pollux(long variable)
{
	/*long            castor();*/
	if (--counter) {
		if (castor(2 * variable - 7) != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro51()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, no return value and
 * legal 
 */
{
	static long     i = 0, j = -1, k = 1;

	levelOneNodeOne(i - 2 * j + (-k));
	levelOneNodeTwo((i + j) * j + k);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(long variable)
{
	long            i = variable + 2;
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(long variable)
{
	long            i = variable * 2;
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i += 8) / 2);
	levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(long variable)
{
	long            i = variable;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(long variable)
{
	long            i = variable--;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable + i * (variable - i) - 1);
	levelThreeLeafEight(i * (2 * variable - i) - variable);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro52()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
int levelThreeLeafOne(long);
int levelThreeLeafTwo(long);
int levelThreeLeafThree(long);
int levelThreeLeafFour(long);
int levelThreeLeafFive(long);
int levelThreeLeafSix(long);
int levelThreeLeafSeven(long);
int levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, no return value and
 * illegal 
 */
{
	static long     i = 0, j = -1, k = 1;

	levelOneNodeOne(i - 2 * j + (-k));
	levelOneNodeTwo((i + j) * j + k);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(long variable)
{
	long            i = variable + 2;

	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(long variable)
{
	long            i = variable * 2;

	if (variable != 3L)
		statusFlag++;
	result = levelThreeLeafOne((i += 8) / 2);
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(long variable)
{
	long            i = variable;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(long variable)
{
	long            i = variable--;

	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;

	if (variable != 6L)
		statusFlag++;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
}

int levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
	return;
}

int levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
	return;
}

int levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
	return;
}

int levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
	return;
}

int levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
	return;
}

int levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
	return;
}

int levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
	return;
}

int levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro53()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, Long function declaration 
 */
{
	static long     i = 0, j = -1, k = 1;
	long            result = 0;
	/*long            long            levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1L)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long variable)
{
	long            result = 0;
	/*long            levelTwoNodeOne(), levelTwoNodeTwo();*/
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3L)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4L)
		statusFlag++;
	return variable;
}

long 
levelOneNodeTwo(long variable)
{
	long            i = variable + 2;
	long            result = 0;
	/*long            levelTwoNodeThree(), levelTwoNodeFour();*/
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeOne(long variable)
{
	long            i = variable * 2;
	long            result = 0;
	/*long            levelThreeLeafOne(), levelThreeLeafTwo();*/
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeTwo(long variable)
{
	long            i = variable;
	long            result = 0;
	/*long            levelThreeLeafThree(), levelThreeLeafFour();*/
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeThree(long variable)
{
	long            i = variable--;
	long            result = 0;
	/*long            levelThreeLeafFive(), levelThreeLeafSix();*/
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12L)
		statusFlag++;
	return i;
}

long 
levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;
	long            result = 0;
	/*long            levelThreeLeafSeven(), levelThreeLeafEight();*/
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14L)
		statusFlag++;
	return variable;
}

long 
levelThreeLeafOne(long variable)
{
	return variable;
}

long 
levelThreeLeafTwo(long variable)
{
	return variable;
}

long 
levelThreeLeafThree(long variable)
{
	return variable;
}

long 
levelThreeLeafFour(long variable)
{
	return variable;
}

long 
levelThreeLeafFive(long variable)
{
	return variable;
}

long 
levelThreeLeafSix(long variable)
{
	return variable;
}

long 
levelThreeLeafSeven(long variable)
{
	return variable;
}

long 
levelThreeLeafEight(long variable)
{
	return variable;
}
@def_
@def $macro54()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value, legal
 * pointer to function returning a long 
 */
{
	static long     i = 3;
	/*long            divide4(), result = 0, dummy1();*/
	long result = 0; 

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i = Long--;

	i = (*func) ((-1 + ++i + ++Long) / 2);
	if (i != 3L)
		statusFlag++;
	return i;
}

long 
divide4(long Long)
{
	/*long            divide2(), dummy2();*/

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i = Long++;

	i = (*func) ((-1 - --i - --Long) / -2);
	if (i != 6L)
		statusFlag++;
	return i;
}

long 
divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro55()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	static long     i = 1;
	/*long            levelOneNodeOne();*/
	long            counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32L)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long variable)
{
	/*long            levelTwoNodeOne();*/

	return 2 * levelTwoNodeOne(2 * variable);
}

long 
levelTwoNodeOne(long variable)
{
	/*long            levelThreeLeafOne();*/

	return 2 * levelThreeLeafOne(2 * variable);
}

long 
levelThreeLeafOne(long variable)
{
	return 2 * variable;
}
@def_
@def $macro56()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, in conditional
 * expression, pointer to function returning a long 
 */
{
	static long     i = 2;
	/*long            divide4(), dummy1();*/

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i = Long % 3;

	return (*func) ((Long + i) * (2 + i) / (2 - i));
}

long 
divide4(long Long)
{
	/*long            divide2(), dummy2();*/

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i = Long + 1;

	return (*func) ((i + ++Long) / 2 - 1);
}

long 
divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro57()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

void recursiveFunction(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, no return value, legal 
 */
{
	static long     i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro58()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

long            result;
short           statusFlag = NoMistake;

void recursiveFunction(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, no return value, illegal 
 */
{
	static long     i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				   counter ? --counter : ++counter);
}
@def_
@def $macro59()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
/*long            recursiveFunction();*/

long recursiveFunction(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, Long function
 * declaration 
 */
{
	long            i = 0;
	long            result = 0;
	long            counter = TimeLimit;
	/*long            recursiveFunction();*/

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long variable, long counter)
{
	long            result = 0;
	long            storage = variable + 1;
	/*long            recursiveFunction();*/

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro60()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

long dummy(long (*)(long), long, long);
long increment(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, pointer to
 * function returning a long 
 */
{
	static long     i = 0;
	/*long            increment();*/
	long            counter = TimeLimit;
	/*long            dummy();*/

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long variable, long counter)
{
	long            result = 0;
	long            storage = variable;
	/*long dummy();*/

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2L)
			statusFlag++;
	}
	return function(storage);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro61()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

long recursiveFunction(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	/*long            recursiveFunction();*/
	static long     i = -1;
	long            counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long variable, long counter)
{
	long            storage = variable;
	/*long            recursiveFunction();*/

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1L)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro62()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * pointer to function returning a long 
 */
{
	/*long            increment(), dummy();*/
	static long     i = 2, j = 1;

	if (dummy(increment, (long) (j + i * j >= 10 || i - j > 0)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long variable)
{
	long            storage = variable;
	/*long dummy();*/

	if (--counter)
		if (dummy(function, (long) ((++variable - 1 == 0) + 1)) != 2L)
			statusFlag++;
	return function(storage);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro63()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

void castor(long, long);
void pollux(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, no return value, legal 
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	static long     i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux((i & i == i) + (j == i), counter);
	}
}

void pollux(long variable, long counter)
{
	static long     i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor((i & i == i & i) + (j != i), counter);
	}
}
@def_
@def $macro64()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            result;

void castor(long, long);
void pollux(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, no return value, illegal 
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	static long     i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		pollux((i & i == i) + (j == i), counter);
}

void pollux(long variable, long counter)
{
	static long     i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		castor((i & i == i & i) + (j != i), counter);
}
@def_
@def $macro65()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

long castor(long, long);
long pollux(long, long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static long     i = 1, j = 2;
	long            counter = TimeLimit;
	long            result = 0;
	/*long castor();*/

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long variable, long counter)
{
	static long     i = 1, j = 2;
	long            result = 0;
	/*long pollux();*/

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1L)
			statusFlag++;
	}
	return variable;
}

long 
pollux(long variable, long counter)
{
	static long     i = 1, j = 2;
	/*long            result = 0, castor();*/
	long result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2L)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro66()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	static long     i = 0;
	/*long            increment();*/
	/*long            castor();*/

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long variable)
{
	long            ii = 0;
	/*long            pollux();*/

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long 
pollux(long (*function)(long), long variable)
{
	long            iii = 0;
	/*long            castor();*/

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro67()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long);
long pollux(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	static long     i = 0;
	/*long            castor();*/

	if (castor(++i && ++i ? --i : i + 2) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long variable)
{
	/*long            pollux();*/
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5L)
			statusFlag++;
	}
	return ++variable;
}

long 
pollux(long variable)
{
	/*long            castor();*/
	if (--counter) {
		if (castor(2 * variable - 7) != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro68()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	static long     i = 1;
	/*long            increment();*/
	/*long            castor();*/

	if (castor(increment, (long) ((i << 1 | i) == i + 2)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long variable)
{
	/*long            pollux();*/
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12L)
			statusFlag++;
	}
	return function(variable);
}

long 
pollux(long (*function)(long), long variable)
{
	/*long            castor();*/
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2L)
			statusFlag++;
	}
	return function(variable);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro69()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, no return value and legal 
 */
{
	levelOneNodeOne((i >> l | j) & k >> l & i);
	levelOneNodeTwo((j >> l | i & k) & l);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne(i & j & k | l);
	levelTwoNodeTwo(~(j | l) & i >> l);
}

void levelOneNodeTwo(long variable)
{
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i >> l | j) ^ l << l);
	levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
}

void levelTwoNodeOne(long variable)
{
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i | l) & (k | l));
	levelThreeLeafTwo((i ^ k) & j);
}

void levelTwoNodeTwo(long variable)
{
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((k >> l | i << l) & j);
	levelThreeLeafFour(~i & (j | l));
}

void levelTwoNodeThree(long variable)
{
	if (variable != 5L)
		statusFlag++;
	levelThreeLeafFive(k >> l | j);
	levelThreeLeafSix((k >> l & (i | l)) << l);
}

void levelTwoNodeFour(long variable)
{
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven((i | j) & k);
	levelThreeLeafEight((i ^ k) >> l);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro70()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;
long            result;

int levelOneNodeOne(long);
int levelOneNodeTwo(long);
int levelTwoNodeOne(long);
int levelTwoNodeTwo(long);
int levelTwoNodeThree(long);
int levelTwoNodeFour(long);
int levelThreeLeafOne(long);
int levelThreeLeafTwo(long);
int levelThreeLeafThree(long);
int levelThreeLeafFour(long);
int levelThreeLeafFive(long);
int levelThreeLeafSix(long);
int levelThreeLeafSeven(long);
int levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, no return value and illegal 
 */
{
	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	result = levelTwoNodeOne(i & j & k | l);
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	return;
}

int levelOneNodeTwo(long variable)
{
	if (variable != 2L)
		statusFlag++;
	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	return;
}

int levelTwoNodeOne(long variable)
{
	if (variable != 3L)
		statusFlag++;
	result = levelThreeLeafOne((i | l) & (k | l));
	result = levelThreeLeafTwo((i ^ k) & j);
	return;
}

int levelTwoNodeTwo(long variable)
{
	if (variable != 4L)
		statusFlag++;
	result = levelThreeLeafThree((k >> l | i << l) & j);
	result = levelThreeLeafFour(~i & (j | l));
	return;
}

int levelTwoNodeThree(long variable)
{
	if (variable != 5L)
		statusFlag++;
	result = levelThreeLeafFive(k >> l | j);
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	return;
}

int levelTwoNodeFour(long variable)
{
	if (variable != 6L)
		statusFlag++;
	result = levelThreeLeafSeven((i | j) & k);
	result = levelThreeLeafEight((i ^ k) >> l);
	return;
}

int levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
	return;
}

int levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
	return;
}

int levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
	return;
}

int levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
	return;
}

int levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
	return;
}

int levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
	return;
}

int levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
	return;
}

int levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro71()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, no function declaration 
 */
{
	long            result = 0;
	/*long            long            levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1L)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long variable)
{
	long            result = 0;
	/*long            levelTwoNodeOne(), levelTwoNodeTwo();*/

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3L)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4L)
		statusFlag++;
	return variable;
}

long 
levelOneNodeTwo(long variable)
{
	long            result = 0;
	/*long            levelTwoNodeThree(), levelTwoNodeFour();*/

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeOne(long variable)
{
	long            result = 0;
	/*long            levelThreeLeafOne(), levelThreeLeafTwo();*/

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeTwo(long variable)
{
	long            result = 0;
	/*long            levelThreeLeafThree(), levelThreeLeafFour();*/

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeThree(long variable)
{
	long            result = 0;
	/*long            levelThreeLeafFive(), levelThreeLeafSix();*/

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12L)
		statusFlag++;
	return variable;
}

long 
levelTwoNodeFour(long variable)
{
	long            result = 0;
	/*long            levelThreeLeafSeven(), levelThreeLeafEight();*/

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14L)
		statusFlag++;
	return variable;
}

long 
levelThreeLeafOne(long variable)
{
	return variable;
}

long 
levelThreeLeafTwo(long variable)
{
	return variable;
}

long 
levelThreeLeafThree(long variable)
{
	return variable;
}

long 
levelThreeLeafFour(long variable)
{
	return variable;
}

long 
levelThreeLeafFive(long variable)
{
	return variable;
}

long 
levelThreeLeafSix(long variable)
{
	return variable;
}

long 
levelThreeLeafSeven(long variable)
{
	return variable;
}

long 
levelThreeLeafEight(long variable)
{
	return variable;
}
@def_
@def $macro72()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, k = 055, l = 02;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*func)(long), long);
long divide2(long);

int main(void)
/*
 * test class: bit-wise expression instance  : linear tree structure, return value, legal pointer to function returning a
 * long 
 */
{
	/*long            divide4(), result = 0, dummy1();*/
	long result = 0; 

	result = dummy1(divide4, (k >> l & (i | l)) << l);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            result = 0;

	result = (*func) (Long & k);
	if (result != 3L)
		statusFlag++;
	return result;
}

long 
divide4(long Long)
{
	/*long            divide2(), dummy2();*/

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            result = 0;

	result = (*func) (Long << l >> l);
	if (result != 6L)
		statusFlag++;
	return result;
}

long 
divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro73()
$LICENSE()
$HEAD()

long            i = 025, j = 011, k = 055;

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	/*long            levelOneNodeOne();*/
	long            counter = 0;

	while (levelOneNodeOne(i & j & k) != 32L)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long variable)
{
	/*long            levelTwoNodeOne();*/

	return levelTwoNodeOne(variable << 1) << 1;
}

long 
levelTwoNodeOne(long variable)
{
	/*long            levelThreeLeafOne();*/

	return levelThreeLeafOne(variable << 1) << 1;
}

long 
levelThreeLeafOne(long variable)
{
	return variable << 1;
}
@def_
@def $macro74()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            i = 025, k = 055, l = 02;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);

int main(void)
/*
 * test class: bit-wise expression instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{

	if (dummy1(divide4, (k >> l & (i | l)) << l) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	return (*func) (Long & k);
}

long 
divide4(long Long)
{

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	return (*func) (Long << l >> l);
}

long 
divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro75()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

void recursiveFunction(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, no return value, legal 
 */
{
	long            counter = TimeLimit;

	recursiveFunction(i & j & k, counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(++variable << l >> l, --counter);
}
@def_
@def $macro76()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;
long            result;

int recursiveFunction(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, no return value, illegal 
 */
{
	long            counter = TimeLimit;

	result = recursiveFunction(i & j & k, counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		result = recursiveFunction(++variable << l >> l, --counter);
	return;
}
@def_
@def $macro77()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            i = 025, j = 011, k = 055, l = 02;

long recursiveFunction(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return a long 
 */
{
	long            result = 0;
	long            counter = TimeLimit;
	/*long            recursiveFunction();*/

	result = recursiveFunction(i & j & k, counter);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long variable, long counter)
{
	long            result = 0;
	long            storage = variable + 1;
	/*long            recursiveFunction();*/

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro78()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

long dummy(long (*)(long), long, long);
long increment(long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            result = 0;
	long            counter = TimeLimit;

	result = dummy(increment, i & j & k, counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long variable, long counter)
{
	long            result = 0;
	long            storage = variable;

	if (--counter) {
		result = dummy(function, variable << l >> l, counter);
		if (result != 2L)
			statusFlag++;
	}
	return function(storage);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro79()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

long recursiveFunction(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, Long function declaration 
 */
{
	long            counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2L != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long variable, long counter)
{
	long            storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1L)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro80()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

long dummy(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, pointer to function returning a
 * long 
 */
{

	if (dummy(increment, i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long variable)
{
	long            storage = variable;

	if (--counter)
		if (dummy(function, variable << l >> l) != 2L)
			statusFlag++;
	return function(storage);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro81()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

void castor(long, long);
void pollux(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, no return value, legal 
 */
{
	long            counter = TimeLimit;

	castor((i & j & k) << 1, counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux(l >> 1, counter);
	}
}

void pollux(long variable, long counter)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor(~(i & j & k) & l, counter);
	}
}
@def_
@def $macro82()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;
long            result;

void castor(long, long);
void pollux(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, no return value, illegal 
 */
{
	long            counter = TimeLimit;

	castor((i & j & k) << 1, counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter)
		pollux(l >> 1, counter);
}

void pollux(long variable, long counter)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		castor(~(i & j & k) & l, counter);
}
@def_
@def $macro83()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            i = 025, j = 011, k = 055, l = 02;

long castor(long, long);
long pollux(long, long);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	long            counter = TimeLimit;
	long result = 0;

	result = castor(~(i & j & k) & l, counter);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long variable, long counter)
{
	long            result = 0;

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1L)
			statusFlag++;
	}
	return variable;
}

long 
pollux(long variable, long counter)
{
	long            result = 0;

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2L)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro84()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, pointer to function returning a long 
 */
{

	i = castor(increment, i & j & k);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long variable)
{
	long            result = 0;

	if (--counter) {
		result = pollux(function, j << l >> l);
		if (result != 10L)
			statusFlag++;
	}
	return function(variable);
}

long 
pollux(long (*function)(long), long variable)
{
	long            result = 0;

	if (--counter) {
		result = castor(function, i & j & k);
		if (result != 2L)
			statusFlag++;
	}
	return function(variable);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro85()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

long castor(long);
long pollux(long);


int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return a long 
 */
{

	if (castor(i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long variable)
{

	if (--counter) {
		if (pollux(i & j << l & k) != 5L)
			statusFlag++;
	}
	return ++variable;
}

long 
pollux(long variable)
{
	if (--counter) {
		if (castor(i & j & k) != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro86()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            i = 025, j = 011, k = 055, l = 02;

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{

	if (castor(increment, i & j & k) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long variable)
{
	if (--counter) {
		if (pollux(function, k >> l) != 12L)
			statusFlag++;
	}
	return function(variable);
}

long 
pollux(long (*function)(long), long variable)
{
	if (--counter) {
		if (castor(function, i & j & k) != 2L)
			statusFlag++;
	}
	return function(variable);
}

long 
increment(long variable)
{
	return ++variable;
}
@def_
@def $macro87()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);
long dummy(long);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and legal 
 */
{

	levelOneNodeOne(dummy(1L));
	levelOneNodeTwo(dummy(2L));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(dummy(3L));
	levelTwoNodeTwo(dummy(4L));
}

void levelOneNodeTwo(long argument)
{
	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(dummy(5L));
	levelTwoNodeFour(dummy(6L));
}

void levelTwoNodeOne(long argument)
{
	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(dummy(7L));
	levelThreeLeafTwo(dummy(8L));
}

void levelTwoNodeTwo(long argument)
{
	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(dummy(9L));
	levelThreeLeafFour(dummy(10L));
}

void levelTwoNodeThree(long argument)
{
	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(dummy(11L));
	levelThreeLeafSix(dummy(12L));
}

void levelTwoNodeFour(long argument)
{
	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(dummy(13L));
	levelThreeLeafEight(dummy(14L));
}

void levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
}

long 
dummy(long argument)
{
	return argument;
}
@def_
@def $macro88()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);
long dummy(long);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	long            i = 0;

	levelOneNodeOne(dummy(1L));
	levelOneNodeTwo(dummy(2L));
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(dummy(3L));
	levelTwoNodeTwo(dummy(4L));
	if (i == 0L)
		i++;
}

void levelOneNodeTwo(long argument)
{
	long            i;

	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(dummy(5L));
	levelTwoNodeFour(dummy(6L));
	if (i == 0L)
		i++;
}

void levelTwoNodeOne(long argument)
{
	long            i;

	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(dummy(7L));
	levelThreeLeafTwo(dummy(8L));
	if (i == 0L)
		i++;
}

void levelTwoNodeTwo(long argument)
{
	long            i;

	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(dummy(9L));
	levelThreeLeafFour(dummy(10L));
	if (i == 0L)
		i++;
}

void levelTwoNodeThree(long argument)
{
	long            i;

	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(dummy(11L));
	levelThreeLeafSix(dummy(12L));
	if (i == 0L)
		i++;
}

void levelTwoNodeFour(long argument)
{
	long            i;

	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(dummy(13L));
	levelThreeLeafEight(dummy(14L));
	if (i == 0L)
		i++;
}

void levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
}

long 
dummy(long argument)
{
	return argument;
}
@def_
@def $macro89()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);
long dummy(long);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, Long function declaration 
 */
{
	long            i = 0;

	i = levelOneNodeOne(dummy(1L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2L));
	if (i == 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long argument)
{
	long            i = 0;

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelOneNodeTwo(long argument)
{
	long            i = 0;

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeOne(long argument)
{
	long            i = 0;

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeTwo(long argument)
{
	long            i = 0;

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeThree(long argument)
{
	long            i = 0;

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeFour(long argument)
{
	long            i = 0;

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13L));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14L));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
	return argument;
}

long 
dummy(long argument)
{
	return argument;
}
@def_
@def $macro90()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*func)(long), long);
long divide2(long);
long twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning a
 * long 
 */
{
	long            i, divide4(), dummy1();

	i = dummy1(divide4, twelve());
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i = Long;

	i = (*func) (twelve());
	if (i != 3L)
		statusFlag++;
	return i;
}

long 
divide4(long Long)
{

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i = Long;

	i = (*func) (twelve());
	if (i != 6L)
		statusFlag++;
	return i;
}

long 
divide2(long Long)
{
	return Long / 2;
}

long 
twelve(void)
{
	return 12;
}
@def_
@def $macro91()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            object = 1;

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);
long mirror(long);


int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{

	if (levelOneNodeOne(mirror(object)) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long argument)
{
	long            object = argument + 2;

	if (levelTwoNodeOne(mirror(object)) != 3L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeOne(long argument)
{
	long            object = argument + 4;

	if (levelThreeLeafOne(mirror(object)) != 7L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
	return argument;
}

long 
mirror(long argument)
{
	return argument;
}
@def_
@def $macro92()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);
long twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{

	if (dummy1(divide4, twelve()) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i = Long;

	if ((i = (*func) (twelve())) != 3L)
		statusFlag++;
	return i;
}

long 
divide4(long Long)
{

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i = Long;

	if ((i = (*func) (twelve())) != 6L)
		statusFlag++;
	return i;
}

long 
divide2(long Long)
{
	return Long / 2;
}

long 
twelve(void)
{
	return 12;
}
@def_
@def $macro93()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

void recursiveFunction(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, no return value, legal 
 */
{
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long argument)
{
	if (argument != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(un());
}

long 
un(void)
{
	static long     un = 1;
	return un;
}
@def_
@def $macro94()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            result;

int recursiveFunction(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, no return value, illegal 
 */
{
	result = recursiveFunction(un());
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(long argument)
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		result = recursiveFunction(un());
	return;
}

long 
un(void)
{
	static long     un = 1;
	return un;
}
@def_
@def $macro95()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long recursiveFunction(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, legal, Long function declaration 
 */
{
	long            i = 0;

	i = recursiveFunction(un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long argument)
{
	long            i;

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2L)
			statusFlag++;
	}
	return ++argument;
}

long 
un(void)
{
	static long     un = 1;
	return un;
}
@def_
@def $macro96()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(long), long);
long increment(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            i;

	i = dummy(increment, un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long argument)
{
	long            i;

	if (--counter) {
		i = dummy(function, un());
		if (i != 2L)
			statusFlag++;
	}
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
un(void)
{
	long            un = 1;
	return un;
}
@def_
@def $macro97()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long recursiveFunction(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{

	if (!(recursiveFunction(un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long argument)
{

	if (--counter)
		if (!(recursiveFunction(un()) == 2L))
			statusFlag++;
	return ++argument;
}

long 
un(void)
{
	static long     un = 1;
	return un;
}
@def_
@def $macro98()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(long), long);
long increment(long);
long un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning a
 * long 
 */
{

	if (!(dummy(increment, un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long argument)
{
	if (--counter)
		if (!(dummy(function, un()) == 2L))
			statusFlag++;
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
un(void)
{
	static long     un = 1;
	return un;
}
@def_
@def $macro99()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;


void castor(long);
void pollux(long);
long un(void);
long deux(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, no return value, legal 
 */
{

	castor(un());
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long argument)
{

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		pollux(deux());
}

void pollux(long argument)
{

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		castor(un());
}

long 
un(void)
{
	long            un = 1;
	return un;
}

long 
deux(void)
{
	long            deux = 2;
	return deux;
}
@def_
@def $macro100()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
long            result;

void castor(long);
void pollux(long);
long un(void);
long deux(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, no return value, illegal 
 */
{
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long argument)
{

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		pollux(deux());
}

void pollux(long argument)
{

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		castor(un());
}

long 
un(void)
{
	long            un = 1;
	return un;
}

long 
deux(void)
{
	long            deux = 2;
	return deux;
}
@def_
@def $macro101()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long);
long pollux(long);
long rebound(long);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            i = 0;

	i = castor(rebound(1L));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long argument)
{
	long            i;

	if (--counter) {
		i = pollux(rebound(4L));
		if (i != 5L)
			statusFlag++;
	}
	return ++argument;
}

long 
pollux(long argument)
{
	long            i;

	if (--counter) {
		i = castor(rebound(1L));
		if (i != 2L)
			statusFlag++;
	}
	return ++argument;
}

long 
rebound(long argument)
{
	return argument;
}
@def_
@def $macro102()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);
long un(void);
long trois(void);
long neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i;

	i = castor(increment, un());
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long argument)
{
	long            i;
	if (--counter) {
		i = pollux(function, neuf());
		if (i != 10L)
			statusFlag++;
	}
	return function(argument);
}

long 
pollux(long (*function)(long), long argument)
{
	long            i;
	if (--counter) {
		i = castor(function, trois());
		if (i != 4L)
			statusFlag++;
	}
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
un(void)
{
	return Un;
}

long 
trois(void)
{
	return (Trois);
}

long 
neuf(void)
{
	return (Neuf);
}
@def_
@def $macro103()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

long castor(long);
long pollux(long);
long numero(long);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a long 
 */
{

	if (!(castor(numero((long) Un)) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long argument)
{

	if (--counter)
		if (!(pollux(numero((long) Quatre)) == 5L))
			statusFlag++;
	return ++argument;
}

long 
pollux(long argument)
{

	if (--counter)
		if (!(castor(numero((long) Un)) == 2L))
			statusFlag++;
	return ++argument;
}

long 
numero(long questCa)
{
	return questCa;
}
@def_
@def $macro104()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);
long un(void);
long trois(void);
long neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{

	if (!(castor(increment, un()) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long argument)
{

	if (--counter)
		if (!(pollux(function, neuf()) == 10L))
			statusFlag++;
	return function(argument);
}

long 
pollux(long (*function)(long), long argument)
{

	if (--counter)
		if (!(castor(function, trois()) == 4L))
			statusFlag++;
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
un(void)
{
	static long     un = 1;
	return un;
}

long 
trois(void)
{
	static long     trois = 3;
	return trois;
}

long 
neuf(void)
{
	static long     neuf = 9;
	return neuf;
}
@def_
@def $macro105()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

void recursiveFunction(long);
long indeterminacy(long, long, long);

int main(void)
/*
 * test class: function as argument, variable order not determined instance  : recursive call, no return value, legal 
 */
{
	long            i = 0, a, b, c;

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(indeterminacy(a, b, c));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long argument)
{
	long            i = 0, a, b, c;

	if (argument != -3L)
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(indeterminacy(a, b, c));
	}
}

long 
indeterminacy(long uno, long dos, long tres)
{
	return uno + dos + tres;
}
@def_
@def $macro106()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and legal 
 */
{
	levelOneNodeOne(uno(dos(tres(1L))));
	levelOneNodeTwo(uno(dos(tres(2L))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(uno(dos(tres(3L))));
	levelTwoNodeTwo(uno(dos(tres(4L))));
}

void levelOneNodeTwo(long argument)
{
	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(uno(dos(tres(5L))));
	levelTwoNodeFour(uno(dos(tres(6L))));
}

void levelTwoNodeOne(long argument)
{
	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(uno(dos(tres(7L))));
	levelThreeLeafTwo(uno(dos(tres(8L))));
}

void levelTwoNodeTwo(long argument)
{
	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(uno(dos(tres(9L))));
	levelThreeLeafFour(uno(dos(tres(10L))));
}

void levelTwoNodeThree(long argument)
{
	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(uno(dos(tres(11L))));
	levelThreeLeafSix(uno(dos(tres(12L))));
}

void levelTwoNodeFour(long argument)
{
	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(uno(dos(tres(13L))));
	levelThreeLeafEight(uno(dos(tres(14L))));
}

void levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro107()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, no return value and illegal 
 */
{
	long            i = 0;

	levelOneNodeOne(uno(dos(tres(1L))));
	levelOneNodeTwo(uno(dos(tres(2L))));
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long argument)
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	levelTwoNodeOne(uno(dos(tres(3L))));
	levelTwoNodeTwo(uno(dos(tres(4L))));
	if (i == 0L)
		i++;
}

void levelOneNodeTwo(long argument)
{
	long            i;

	if (argument != 2L)
		statusFlag++;
	levelTwoNodeThree(uno(dos(tres(5L))));
	levelTwoNodeFour(uno(dos(tres(6L))));
	if (i == 0L)
		i++;
}

void levelTwoNodeOne(long argument)
{
	long            i;

	if (argument != 3L)
		statusFlag++;
	levelThreeLeafOne(uno(dos(tres(7L))));
	levelThreeLeafTwo(uno(dos(tres(8L))));
	if (i == 0L)
		i++;
}

void levelTwoNodeTwo(long argument)
{
	long            i;

	if (argument != 4L)
		statusFlag++;
	levelThreeLeafThree(uno(dos(tres(9L))));
	levelThreeLeafFour(uno(dos(tres(10L))));
	if (i == 0L)
		i++;
}

void levelTwoNodeThree(long argument)
{
	long            i;

	if (argument != 5L)
		statusFlag++;
	levelThreeLeafFive(uno(dos(tres(11L))));
	levelThreeLeafSix(uno(dos(tres(12L))));
	if (i == 0L)
		i++;
}

void levelTwoNodeFour(long argument)
{
	long            i;

	if (argument != 6L)
		statusFlag++;
	levelThreeLeafSeven(uno(dos(tres(13L))));
	levelThreeLeafEight(uno(dos(tres(14L))));
	if (i == 0L)
		i++;
}

void levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro108()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, Long function
 * declaration 
 */
{
	long            i = 0;

	i = levelOneNodeOne(uno(dos(tres(1L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2L))));
	if (i == 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long argument)
{
	long            i = 0;

	if (argument != 1L)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelOneNodeTwo(long argument)
{
	long            i = 0;

	if (argument != 2L)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeOne(long argument)
{
	long            i = 0;

	if (argument != 3L)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeTwo(long argument)
{
	long            i = 0;

	if (argument != 4L)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeThree(long argument)
{
	long            i = 0;

	if (argument != 5L)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeFour(long argument)
{
	long            i = 0;

	if (argument != 6L)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13L))));
	if (i == 0L)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14L))));
	if (i == 0L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafTwo(long argument)
{
	if (argument != 8L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafThree(long argument)
{
	if (argument != 9L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafFour(long argument)
{
	if (argument != 10L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafFive(long argument)
{
	if (argument != 11L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafSix(long argument)
{
	if (argument != 12L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafSeven(long argument)
{
	if (argument != 13L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafEight(long argument)
{
	if (argument != 14L)
		statusFlag++;
	return argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro109()
$LICENSE()
$HEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);
long twentyFour(void);
long twoTimes(long);
long half(long);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning a long 
 */
{

	long            i;

	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i = Long;

	i = (*func) (half(twoTimes(i)));
	if (i != 3L)
		statusFlag++;
	return i;
}

long 
divide4(long Long)
{

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i = Long;

	i = (*func) (twoTimes(half(i)));
	if (i != 6L)
		statusFlag++;
	return i;
}

long 
divide2(long Long)
{
	return Long / 2;
}

long 
twentyFour(void)
{
	return TwoDozen;
}

long 
twoTimes(long argument)
{
	return 2 * argument;
}

long 
half(long argument)
{
	return argument / 2;
}
@def_
@def $macro110()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            object = 1;

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{

	if (levelOneNodeOne(uno(dos(tres(object)))) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
levelOneNodeOne(long argument)
{
	long            object = argument + 2;

	if (levelTwoNodeOne(uno(dos(tres(object)))) != 3L)
		statusFlag++;
	return argument;
}

long 
levelTwoNodeOne(long argument)
{
	long            object = argument + 4;

	if (levelThreeLeafOne(uno(dos(tres(object)))) != 7L)
		statusFlag++;
	return argument;
}

long 
levelThreeLeafOne(long argument)
{
	if (argument != 7L)
		statusFlag++;
	return argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro111()
$LICENSE()
$HEAD()

#define TwoDouzen 24L
short           statusFlag = NoMistake;

long dummy1(long (*)(long), long);
long divide4(long);
long dummy2(long (*)(long), long);
long divide2(long);
long twoTimes(long);
long half(long);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{

	if (dummy1(divide4, half(twoTimes(half(TwoDouzen)))) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy1(long (*func)(long), long Long)
{
	long            i;

	if ((i = (*func) (twoTimes(half(Long)))) != 3L)
		statusFlag++;
	return i;
}

long 
divide4(long Long)
{

	return dummy2(divide2, Long) / 2;
}

long 
dummy2(long (*func)(long), long Long)
{
	long            i;

	if ((i = (*func) (twoTimes(half(Long)))) != 6L)
		statusFlag++;
	return i;
}

long 
divide2(long Long)
{
	return Long / 2;
}

long 
twoTimes(long argument)
{
	return 2 * argument;
}

long 
half(long argument)
{
	return argument / 2;
}
@def_
@def $macro112()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;



void recursiveFunction(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, no return value, legal 
 */
{
	recursiveFunction(uno(dos(tres(Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long argument)
{

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(uno(dos(tres(Un))));
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro113()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

int recursiveFunction(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, no return value, illegal 
 */
{
	long            i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 1L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(long argument)
{
	long            i;

	if (argument != 1L)
		statusFlag++;
	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 1L)
			i++;
	}
	return;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro114()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

long recursiveFunction(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, Long function declaration 
 */
{
	long i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long argument)
{
	long i;

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2L)
			statusFlag++;
	}
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro115()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(long), long);
long increment(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            i;

	i = dummy(increment, uno(dos(tres(Un))));
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long argument)
{
	long            i;

	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if (i != 2L)
			statusFlag++;
	}
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro116()
$LICENSE()
$HEAD()

#define Un 1L
short           statusFlag = NoMistake;
long            counter = 10;

long recursiveFunction(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{

	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
recursiveFunction(long argument)
{

	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2L))
			statusFlag++;
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro117()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
long            counter = 10;

long dummy(long (*)(long), long);
long increment(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning a long 
 */
{

	if (!(dummy(increment, uno(dos(tres((long) Un)))) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
dummy(long (*function)(long), long argument)
{

	if (--counter)
		if (!(dummy(function, uno(dos(tres((long) Un)))) == 2L))
			statusFlag++;
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro118()
$LICENSE()
$HEAD()

#define Un   1
#define Deux 2
short           statusFlag = NoMistake;
long            counter = 10;

void castor(long);
void pollux(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, no return value, legal 
 */
{

	castor(uno(dos(tres((long) Un))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long argument)
{

	if (argument != 1L)
		statusFlag++;
	if (--counter)
		pollux(uno(dos(tres((long) Deux))));
}

void pollux(long argument)
{

	if (argument != 2L)
		statusFlag++;
	if (--counter)
		castor(uno(dos(tres((long) Un))));
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro119()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
long            counter = 10;
long i;

void castor(long);
void pollux(long);
long uno(long);
long dos(long);
long tres(void);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, no return value, illegal 
 */
{
	castor(uno(dos(tres())));
	if (i != 1L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long argument)
{
	if (argument != Un)
		statusFlag++;
	if (--counter) {
		pollux(uno(dos(tres())));
		if (i != 0L)
			i++;
	}
}

void pollux(long argument)
{
	long            i;

	if (argument != Un)
		statusFlag++;
	if (--counter) {
		castor(uno(dos(tres())));
		if (i != 0L)
			i++;
	}
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(void)
{
	return Un;
}
@def_
@def $macro120()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
long            counter = 10;

long castor(long);
long pollux(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            i;
	/*long castor(), uno(), dos(), tres();*/

	i = castor(uno(dos(tres((long) Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long argument)
{
	long            i;
	/*long pollux(), uno(), dos(), tres();*/

	if (--counter) {
		i = pollux(uno(dos(tres((long) Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return ++argument;
}

long 
pollux(long argument)
{
	long            i;
	/*long uno(), dos(), tres();*/

	if (--counter) {
		i = castor(uno(dos(tres((long) Un))));
		if (i != Deux)
			statusFlag++;
	}
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro121()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i;
	/*long increment(), uno(), dos(), tres(), castor();*/

	i = castor(increment, uno(dos(tres((long) Un))));
	if (i != Un + 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long argument)
{
	long            i;
	/*long uno(), dos(), tres(), pollux();*/

	if (--counter) {
		i = pollux(function, uno(dos(tres((long) Neuf))));
		if (i != Neuf + 1L)
			statusFlag++;
	}
	return function(argument);
}

long 
pollux(long (*function)(long), long argument)
{
	long            i;
	/*long uno(), dos(), tres(), castor();*/

	if (--counter) {
		i = castor(function, uno(dos(tres((long) Trois))));
		if (i != Trois + 1L)
			statusFlag++;
	}
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro122()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

long castor(long);
long pollux(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	/*long            castor(), uno(), dos(), tres();*/

	if (!(castor(uno(dos(tres((long) Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long argument)
{
	/*long            pollux(), uno(), dos(), tres();*/

	if (--counter)
		if (!(pollux(uno(dos(tres((long) Quatre)))) == Cinq))
			statusFlag++;
	return ++argument;
}

long 
pollux(long argument)
{
	/*long            uno(), dos(), tres(), castor();*/

	if (--counter)
		if (!(castor(uno(dos(tres((long) Un)))) == Deux))
			statusFlag++;
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro123()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

long castor(long (*)(long), long);
long pollux(long (*)(long), long);
long increment(long);
long uno(long);
long dos(long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning a
 * long 
 */
{
	/*long            increment();*/
	/*long            uno(), dos(), tres(), castor();*/


	if (!(castor(increment, uno(dos(tres((long) Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long 
castor(long (*function)(long), long argument)
{
	/*long            uno(), dos(), tres(), pollux();*/

	if (--counter)
		if (!(pollux(function, uno(dos(tres((long) Neuf)))) == Dix))
			statusFlag++;
	return function(argument);
}

long 
pollux(long (*function)(long), long argument)
{
	/*long            uno(), dos(), tres(), castor();*/

	if (--counter)
		if (!(castor(function, uno(dos(tres((long) Trois)))) == Quatre))
			statusFlag++;
	return function(argument);
}

long 
increment(long argument)
{
	return ++argument;
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long argument)
{
	return argument;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro124()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;



void recursiveFunction(long);
long uno(long);
long dos(long, long, long);
long tres(long);

int main(void)
/*
 * test class: nested function as argument, random order instance  : recursive call, no return value, legal 
 */
{
	long            i = 0, a, b, c;
	/*long uno(), dos(), tres();*/

	c = --i;
	b = i++;
	a = --i;
	recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long argument)
{
	long            i = 0, a, b, c;
	/*long uno(), dos(), tres();*/

	if (argument != -3L)
		statusFlag++;
	if (--counter){
		c = --i;
		b = i++;
		a = --i;
		recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	}
}

long 
uno(long argument)
{
	return argument;
}

long 
dos(long uno, long dos, long tres)
{
	return uno + dos + tres;
}

long 
tres(long argument)
{
	return argument;
}
@def_
@def $macro125()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(unsigned);
int levelOneNodeTwo(unsigned);
int levelTwoNodeOne(unsigned);
int levelTwoNodeTwo(unsigned);
int levelTwoNodeThree(unsigned);
int levelTwoNodeFour(unsigned);
int levelThreeLeafOne(unsigned);
int levelThreeLeafTwo(unsigned);
int levelThreeLeafThree(unsigned);
int levelThreeLeafFour(unsigned);
int levelThreeLeafFive(unsigned);
int levelThreeLeafSix(unsigned);
int levelThreeLeafSeven(unsigned);
int levelThreeLeafEight(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	unsigned        i = 0;
	short           j = -1;
	unsigned        k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j - k);
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(unsigned variable)

{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(unsigned variable)

{
	unsigned        i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(unsigned variable)

{
	unsigned        i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(unsigned variable)

{
	unsigned        i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(unsigned variable)

{
	unsigned        i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

int levelTwoNodeFour(unsigned variable)

{
	unsigned        i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(unsigned variable)

{
	return variable;
}

int levelThreeLeafTwo(unsigned variable)

{
	return variable;
}

int levelThreeLeafThree(unsigned variable)

{
	return variable;
}

int levelThreeLeafFour(unsigned variable)

{
	return variable;
}

int levelThreeLeafFive(unsigned variable)

{
	return variable;
}

int levelThreeLeafSix(unsigned variable)

{
	return variable;
}

int levelThreeLeafSeven(unsigned variable)

{
	return variable;
}

int levelThreeLeafEight(unsigned variable)

{
	return variable;
}
@def_
@def $macro126()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

short levelOneNodeOne(unsigned);
short levelOneNodeTwo(unsigned);
short levelTwoNodeOne(unsigned);
short levelTwoNodeTwo(unsigned);
short levelTwoNodeThree(unsigned);
short levelTwoNodeFour(unsigned);
short levelThreeLeafOne(unsigned);
short levelThreeLeafTwo(unsigned);
short levelThreeLeafThree(unsigned);
short levelThreeLeafFour(unsigned);
short levelThreeLeafFive(unsigned);
short levelThreeLeafSix(unsigned);
short levelThreeLeafSeven(unsigned);
short levelThreeLeafEight(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	unsigned        i = 0;
	short           j = -1;
	unsigned        k = 1;
	short           result = 0;
	/*short           levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne(i - 2 * j - k);
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(unsigned variable)

{
	short           result = 0;
	/*short           levelTwoNodeOne(), levelTwoNodeTwo();*/
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

short 
levelOneNodeTwo(unsigned variable)

{
	unsigned        i = variable + 2;
	short           result = 0;
	/*short           levelTwoNodeThree(), levelTwoNodeFour();*/
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeOne(unsigned variable)

{
	unsigned        i = variable * 2;
	short           result = 0;
	/*short           levelThreeLeafOne(), levelThreeLeafTwo();*/
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeTwo(unsigned variable)

{
	unsigned        i = variable;
	short           result = 0;
	/*short           levelThreeLeafThree(), levelThreeLeafFour();*/
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeThree(unsigned variable)

{
	unsigned        i = variable--;
	short           result = 0;
	/*short           levelThreeLeafFive(), levelThreeLeafSix();*/
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

short 
levelTwoNodeFour(unsigned variable)

{
	unsigned        i = variable / 2 - 1;
	short           result = 0;
	/*short           levelThreeLeafSeven(), levelThreeLeafEight();*/
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

short 
levelThreeLeafOne(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafTwo(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafThree(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafFour(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafFive(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafSix(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafSeven(unsigned variable)

{
	return variable;
}

short 
levelThreeLeafEight(unsigned variable)

{
	return variable;
}
@def_
@def $macro127()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

char *levelOne(unsigned, char*);
char *levelTwo(unsigned, char*);
char *levelThree(unsigned, char*);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	/*char           *s, *levelOne();*/
	char *s;
	unsigned        i = 0, j = 1;
	static char    *numbers = "01234567890123456789";

	s = levelOne(j, &(numbers[j * (i + 1) * (i + 2) * (i + 3) + 4 * j]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(unsigned variable, char *numbers)
{
	char           *s;
	/*char *levelTwo();*/
	unsigned        j = variable + 1;

	s = levelTwo(j, numbers - j * j * j - 2);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char           *
levelTwo(unsigned variable, char *numbers)
{
	char           *s;
	/*char *levelThree();*/
	unsigned        k = variable + 1;

	s = levelThree(k, numbers + k * k + variable - 1);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char           *
levelThree(unsigned variable, char *numbers)
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro128()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(unsigned (*)(unsigned), unsigned);
unsigned divide4(unsigned);
int dummy2(unsigned (*)(unsigned), unsigned);
unsigned divide2(unsigned);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	unsigned        i = 3;
	/*unsigned        divide4();*/
	short           result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(unsigned (*func)(unsigned), unsigned integer)
{
	unsigned        i = integer--;

	i = (*func) ((-1 + ++i + ++integer) / 2);
	if (i != 3)
		statusFlag++;
	return i;
}

unsigned 
divide4(unsigned integer)
{
	/*unsigned        divide2();*/

	return dummy2(divide2, integer) / 2;
}

int dummy2(unsigned (*func)(unsigned), unsigned integer)
{
	unsigned        i = integer++;

	i = (*func) ((1 + --i + --integer) / 2);
	if (i != 6)
		statusFlag++;
	return i;
}

unsigned 
divide2(unsigned integer)
{
	return integer / 2;
}
@def_
@def $macro129()
$LICENSE()
$HEAD()

char levelOneNodeOne(unsigned);
char levelTwoNodeOne(unsigned);
char levelThreeLeafOne(unsigned);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	unsigned        i = 1;
	/*char            levelOneNodeOne();*/
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

char 
levelOneNodeOne(unsigned variable)

{
	/*char            levelTwoNodeOne();*/

	return 2 * levelTwoNodeOne(2 * variable);
}

char 
levelTwoNodeOne(unsigned variable)

{
	/*char            levelThreeLeafOne();*/

	return 2 * levelThreeLeafOne(2 * variable);
}

char 
levelThreeLeafOne(unsigned variable)

{
	return 2 * variable;
}
@def_
@def $macro130()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

char *skip(char);
int compare(char*, char*, short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	char            i = 2, j = i;
	/*char           *skip();*/

	if (compare(skip(2 * i), &(protean[i * i]), 5)
	    == compare(skip(4 * j), &(protean[j * j * j]), 6))
		printok();
	else
		printno();
	return 0;
}

char           *
skip(char skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro131()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(char (*)(char), char);
char divide4(char);
int dummy2(unsigned (*)(char), char);
unsigned divide2(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	char            i = 2;
	/*char divide4();*/

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(char (*func)(char), char integer)
{
	short           i = integer % 3;

	return (*func) ((integer + i) * (2 + i) / (2 - i));
}

char 
divide4(char integer)
{
	/*unsigned        divide2();*/

	return dummy2(divide2, integer) / 2;
}

int dummy2(unsigned (*func)(char), char integer)
{
	short           i = integer + 1;

	return (*func) ((i + ++integer) / 2 - 1);
}

unsigned 
divide2(char integer)
{
	return integer / 2;
}
@def_
@def $macro132()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

void recursiveFunction(char, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, no return value, legal 
 */
{
	char            i = 0;
	short           counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(char variable, short counter)
{
	if (variable + counter != 11)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro133()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;

int recursiveFunction(char, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, no function
 * declaration 
 */
{
	char            i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(char variable, short counter)
{
	short           result = 0;
	char            storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro134()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
/*short           recursiveFunction();*/

short recursiveFunction(unsigned, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, integer function
 * declaration 
 */
{
	unsigned        i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(unsigned variable, short counter)
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro135()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

char *recursiveFunction(char, char*, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	/*char *recursiveFunction();*/
	char            i = 4;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(i + i / i * i - 6, &(numbers[i * i - i - i / 2]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(char variable, char *numbers, short counter)
{
	char           *s;
	unsigned        storage = (unsigned) variable;

	if (--counter) {
		s = recursiveFunction((char) ((storage + ++variable + 1) / 2 - 1),
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + storage;
}
@def_
@def $macro136()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int dummy(unsigned (*)(char), char, short);
unsigned increment(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	char            i = 0;
	/*unsigned        increment();*/
	short           counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(unsigned (*function)(char), char variable, short counter)
{
	short           result = 0;
	char            storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2)
			statusFlag++;
	}
	return function(storage);
}

unsigned 
increment(char variable)
{
	return ++variable;
}
@def_
@def $macro137()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int recursiveFunction(char, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	char            i = 1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 + i) / 2, counter) - i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(char variable, short counter)
{
	char            storage = variable;

	if (--counter)
		if (recursiveFunction((short) (storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro138()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	/*char           *recursiveFunction();*/
	char            i = 1, j = 3;

	if (*recursiveFunction((i == j + 1) * i + j) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(char variable)
{
	char            storage = variable;

	if (--counter)
		if (*recursiveFunction(++variable * 3 - storage * storage) != '3')
			statusFlag++;
	return numbers + storage;
}
@def_
@def $macro139()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short (*)(unsigned), unsigned);
short increment(unsigned);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	/*short           increment();*/
	char            i = 2, j = 1;

	if (dummy(increment, (unsigned) (j + i * j >= 10 || i - j > 0)) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(unsigned), unsigned variable)
{
	unsigned        storage = variable;

	if (--counter)
		if (dummy(function, (unsigned) ((++variable - 1 == 0) + 1)) != 2)
			statusFlag++;
	return function(storage);
}

short 
increment(unsigned variable)

{
	return ++variable;
}
@def_
@def $macro140()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

void castor(char, short);
void pollux(char, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, no return value, legal 
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(char variable, short counter)
{
	char            i = 1, j = 2;

	if (variable != 2)
		statusFlag++;
	if (--counter) {
		pollux((i & i == i) + (j == i), counter);
	}
}

void pollux(char variable, short counter)
{
	char            i = 1, j = 2;

	if (variable != 1)
		statusFlag++;
	if (--counter) {
		castor((i & i == i & i) + (j != i), counter);
	}
}
@def_
@def $macro141()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int castor(char, short);
int pollux(unsigned, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(char variable, short counter)
{
	unsigned        i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

int pollux(unsigned variable, short counter)
{
	char            i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro142()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

short castor(char, short);
short pollux(unsigned, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, no function declaration  
 */
{
	char            i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;
	/*short castor();*/

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(char variable, short counter)
{
	unsigned        i = 1, j = 2;
	short           result = 0;
	/*short pollux();*/

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

short 
pollux(unsigned variable, short counter)
{
	char            i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro143()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(unsigned short);
char *pollux(unsigned short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	/*char *castor();*/
	unsigned short  i = 1, j = 2, k = 3;

	s = castor((unsigned short) (++i == j && ++j == k) * 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(unsigned short variable)
{
	char           *s;
	/*char *pollux();*/
	unsigned short  i = 4;

	if (--counter) {
		s = pollux(i / variable + i);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(unsigned short variable)
{
	char           *s;
	static unsigned short i = 4;

	if (--counter) {
		s = castor(i * 3 / variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro144()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short (*)(unsigned), unsigned);
int pollux(short (*)(unsigned), unsigned);
short increment(unsigned);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	unsigned        i = 0;
	/*short           increment();*/

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(unsigned), unsigned variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(unsigned), unsigned variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(unsigned variable)

{
	return ++variable;
}
@def_
@def $macro145()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(char);
int pollux(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	char            i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(char variable)
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(char variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro146()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

short castor(unsigned short);
short pollux(unsigned short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	unsigned short  i = 0;
	/*short           castor();*/

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(unsigned short variable)
{
	/*short           pollux();*/
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

short 
pollux(unsigned short variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro147()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(char);
char *pollux(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	/*char           *castor();*/
	char            i = 1, j = 2;

	if (*castor((i << 1 == j) * 2) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(char variable)
{
	/*char           *pollux();*/
	if (--counter) {
		if (*pollux(variable << 1 | variable) != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(char variable)
{
	if (--counter) {
		if (*castor(variable >> 1 & variable) != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro148()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short (*)(char), register char);
int pollux(short (*)(char), register char);
short increment(char);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 2) instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	static char     i = 1;
	/*short           increment();*/

	if (castor(increment, (i << 1 | i) == i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(char), register char variable)
{
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(char), register char variable)
{
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(char variable)
{
	return ++variable;
}
@def_
@def $macro149()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(register short);
int levelOneNodeTwo(register short);
int levelTwoNodeOne(register short);
int levelTwoNodeTwo(register short);
int levelTwoNodeThree(register short);
int levelTwoNodeFour(register short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	static short    i = 0, j = -1, k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(register short variable)
{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(register short variable)
{
	short           i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(register short variable)
{
	short           i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(register short variable)
{
	short           i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(register short variable)
{
	short           i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

int levelTwoNodeFour(register short variable)
{
	short           i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro150()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

short levelOneNodeOne(register short);
short levelOneNodeTwo(register short);
short levelTwoNodeOne(register short);
short levelTwoNodeTwo(register short);
short levelTwoNodeThree(register short);
short levelTwoNodeFour(register short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	static short    i = 0, j = -1, k = 1;
	short           result = 0;
	/*short           levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(register short variable)
{
	short           result = 0;
	/*short           levelTwoNodeOne(), levelTwoNodeTwo();*/
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

short 
levelOneNodeTwo(register short variable)
{
	register short  i = variable + 2;
	short           result = 0;
	/*short           levelTwoNodeThree(), levelTwoNodeFour();*/
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeOne(register short variable)
{
	register short  i = variable * 2;
	short           result = 0;
	/*short           levelThreeLeafOne(), levelThreeLeafTwo();*/
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeTwo(register short variable)
{
	register short  i = variable;
	short           result = 0;
	/*short           levelThreeLeafThree(), levelThreeLeafFour();*/
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeThree(register short variable)
{
	register short  i = variable--;
	short           result = 0;
	/*short           levelThreeLeafFive(), levelThreeLeafSix();*/
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

short 
levelTwoNodeFour(register short variable)
{
	register short  i = variable / 2 - 1;
	short           result = 0;
	/*short           levelThreeLeafSeven(), levelThreeLeafEight();*/
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

short 
levelThreeLeafOne(short variable)
{
	return variable;
}

short 
levelThreeLeafTwo(short variable)
{
	return variable;
}

short 
levelThreeLeafThree(short variable)
{
	return variable;
}

short 
levelThreeLeafFour(short variable)
{
	return variable;
}

short 
levelThreeLeafFive(short variable)
{
	return variable;
}

short 
levelThreeLeafSix(short variable)
{
	return variable;
}

short 
levelThreeLeafSeven(short variable)
{
	return variable;
}

short 
levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro151()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

char *levelOne(register short, char*);
char *levelTwo(register short, char*);
char *levelThree(register short, char*);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s;
	/*char *levelOne();*/
	static short    i = 0, j = 1;
	static char    *numbers = "01234567890123456789";

	s = levelOne(j, &(numbers[j * (i + 1) * (i + 2) * (i + 3) + 4 * j]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(register short variable, char *numbers)
{
	char           *s;
	/*char *levelTwo();*/
	register short  j = variable + 1;

	s = levelTwo(j, numbers - j * j * j - 2);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char           *
levelTwo(register short variable, char *numbers)
{
	char           *s;
	/*char *levelThree();*/
	register short  k = variable + 1;

	s = levelThree(k, numbers + k * k + variable - 1);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char           *
levelThree(register short variable, char *numbers)
{
	char           *s;
	register short  l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro152()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(short (*)(short), register short);
short divide4(register short);
int dummy2(short (*)(short), register short);
short divide2(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	static short    i = 3;
	/*short           divide4();*/
	short result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), register short integer)
{
	register short  i = integer--;

	i = (*func) ((-1 + ++i + ++integer) / 2);
	if (i != 3)
		statusFlag++;
	return i;
}

short 
divide4(register short integer)
{
	/*short           divide2();*/

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), register short integer)
{
	register short  i = integer++;

	i = (*func) ((-1 - --i - --integer) / -2);
	if (i != 6)
		statusFlag++;
	return i;
}

short 
divide2(register short integer)
{
	return integer / 2;
}
@def_
@def $macro153()
$LICENSE()
$HEAD()

short levelOneNodeOne(register short);
short levelTwoNodeOne(register short);
short levelThreeLeafOne(register short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	static short    i = 1;
	/*short           levelOneNodeOne();*/
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(register short variable)
{
	/*short           levelTwoNodeOne();*/

	return 2 * levelTwoNodeOne(2 * variable);
}

short 
levelTwoNodeOne(register short variable)
{
	/*short           levelThreeLeafOne();*/

	return 2 * levelThreeLeafOne(2 * variable);
}

short 
levelThreeLeafOne(register short variable)
{
	return 2 * variable;
}
@def_
@def $macro154()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

char *skip(register short);
int compare(char*, char*, register short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	static short    i = 2, j = 2;
	/*char           *skip();*/

	if (compare(skip(2 * i), &(protean[i * i]), 5)
	    == compare(skip(4 * j), &(protean[j * j * j]), 6))
		printok();
	else
		printno();
	return 0;
}

char           *
skip(register short skipper)
{
	register short  i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, register short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro155()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(short (*)(short), register short);
short divide4(register short);
int dummy2(short (*)(short), register short);
short divide2(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	static short    i = 2;
	/*short           divide4();*/

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), register short integer)
{
	register short  i = integer % 3;

	return (*func) ((integer + i) * (2 + i) / (2 - i));
}

short 
divide4(register short integer)
{
	/*short           divide2();*/

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), register short integer)
{
	short           i = integer + 1;

	return (*func) ((i + ++integer) / 2 - 1);
}

short 
divide2(register short integer)
{
	return integer / 2;
}
@def_
@def $macro156()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
/*short           recursiveFunction();*/

short recursiveFunction(register short, register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, integer function
 * declaration 
 */
{
	register short  i = 0;
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(register short variable, register short counter)
{
	short           result = 0;
	register short  storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro157()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

char *recursiveFunction(register short, char*, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	/*char *recursiveFunction();*/
	static short    i = 4;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(i + i / i * i - 6, &(numbers[i * i - i - i / 2]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(register short variable, char *numbers, short counter)
{
	char           *s;
	register short  storage = variable;

	if (--counter) {
		s = recursiveFunction((storage + ++variable + 1) / 2 - 1,
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + storage;
}
@def_
@def $macro158()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int dummy(short (*)(short), register short, register short);
short increment(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	static short    i = 0;
	/*short           increment();*/
	short           counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), register short variable, register short counter)
{
	short           result = 0;
	register short  storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2)
			statusFlag++;
	}
	return function(storage);
}

short 
increment(register short variable)
{
	return ++variable;
}
@def_
@def $macro159()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int recursiveFunction(register short, register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	static short    i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(register short variable, register short counter)
{
	register short  storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro160()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

short recursiveFunction(register short, register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, function in conditional
 * expression, integer function declaration 
 */
{
	/*short           recursiveFunction();*/
	static short    i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(register short variable, register short counter)
{
	register short  storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro161()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	/*char           *recursiveFunction();*/
	static short    i = 1, j = 3;

	if (*recursiveFunction((i == j + 1) * i + j) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(register short variable)
{
	register short  storage = variable;

	if (--counter)
		if (*recursiveFunction(++variable * 3 - storage * storage) != '3')
			statusFlag++;
	return numbers + storage;
}
@def_
@def $macro162()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short (*)(short), register short);
short increment(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	/*short           increment();*/
	static short    i = 2, j = 1;

	if (dummy(increment, j + i * j >= 10 || i - j > 0) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), register short variable)
{
	register short  storage = variable;

	if (--counter)
		if (dummy(function, (++variable - 1 == 0) + 1) != 2)
			statusFlag++;
	return function(storage);
}

short 
increment(register short variable)
{
	return ++variable;
}
@def_
@def $macro163()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int castor(register short, register short);
int pollux(register short, register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static short    i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(register short variable, register short counter)
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

int pollux(register short variable, register short counter)
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro164()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

short castor(register short, register short);
short pollux(register short, register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, no function declaration  
 */
{
	static short    i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;
	/*short castor();*/

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(register short variable, register short counter)
{
	static short    i = 1, j = 2;
	short           result = 0;
	/*short pollux();*/

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

short 
pollux(register short variable, register short counter)
{
	static short    i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro165()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(register short);
char *pollux(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	/*char *castor();*/
	static short    i = 1, j = 2, k = 3;

	s = castor((++i == j && ++j == k) * 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(register short variable)
{
	char           *s;
	/*char *pollux();*/
	static short    i = 4;

	if (--counter) {
		s = pollux(i / variable + i);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(register short variable)
{
	char           *s;
	static short    i = 4;

	if (--counter) {
		s = castor(i * 3 / variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro166()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short (*)(short), register short);
int pollux(short (*)(short), register short);
short increment(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	static short    i = 0;
	/*short           increment();*/

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), register short variable)
{
	register short  ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(short), register short variable)
{
	register short  iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(register short variable)
{
	return ++variable;
}
@def_
@def $macro167()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(register short);
int pollux(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	static short    i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(register short variable)
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(register short variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro168()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

short castor(register short);
short pollux(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	static short    i = 0;
	/*short           castor();*/

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(register short variable)
{
	/*short           pollux();*/
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

short 
pollux(register short variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro169()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(register short);
char *pollux(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	/*char           *castor();*/
	static short    i = 1, j = 2;

	if (*castor((i << 1 == j) * 2) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(register short variable)
{
	/*char           *pollux();*/
	if (--counter) {
		if (*pollux(variable << 1 | variable) != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(register short variable)
{
	if (--counter) {
		if (*castor(variable >> 1 & variable) != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro170()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short (*)(short), register short);
int pollux(short (*)(short), register short);
short increment(register short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 3) instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	static short    i = 1;
	/*short           increment();*/

	if (castor(increment, (i << 1 | i) == i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), register short variable)
{
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(short), register short variable)
{
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(register short variable)
{
	return ++variable;
}
@def_
@def $macro171()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, function declared to return an integer 
 */
{
	short           result = 0;

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           result = 0;

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	short           result = 0;

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	short           result = 0;

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	short           result = 0;

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	short           result = 0;

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12)
		statusFlag++;
	return variable;
}

int levelTwoNodeFour(short variable)
{
	short           result = 0;

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro172()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, return value, no function declaration 
 */
{
	short           result = 0;
	/*short           levelOneNodeOne(), levelOneNodeTwo();*/

	result = levelOneNodeOne((i >> l | j) & k >> l & i);
	if (result != 1)
		statusFlag++;
	result = 0;
	result = levelOneNodeTwo((j >> l | i & k) & l);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short variable)
{
	short           result = 0;
	/*short           levelTwoNodeOne(), levelTwoNodeTwo();*/

	result = levelTwoNodeOne(i & j & k | l);
	if (result != 3)
		statusFlag++;
	result = 0;
	result = levelTwoNodeTwo(~(j | l) & i >> l);
	if (result != 4)
		statusFlag++;
	return variable;
}

short 
levelOneNodeTwo(short variable)
{
	short           result = 0;
	/*short           levelTwoNodeThree(), levelTwoNodeFour();*/

	result = levelTwoNodeThree((i >> l | j) ^ l << l);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour(((i | l) ^ j) & (i >> l | l));
	if (result != 6)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeOne(short variable)
{
	short           result = 0;
	/*short           levelThreeLeafOne(), levelThreeLeafTwo();*/

	result = levelThreeLeafOne((i | l) & (k | l));
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo((i ^ k) & j);
	if (result != 8)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeTwo(short variable)
{
	short           result = 0;
	/*short           levelThreeLeafThree(), levelThreeLeafFour();*/

	result = levelThreeLeafThree((k >> l | i << l) & j);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(~i & (j | l));
	if (result != 10)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeThree(short variable)
{
	short           result = 0;
	/*short           levelThreeLeafFive(), levelThreeLeafSix();*/

	result = levelThreeLeafFive(k >> l | j);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((k >> l & (i | l)) << l);
	if (result != 12)
		statusFlag++;
	return variable;
}

short 
levelTwoNodeFour(short variable)
{
	short           result = 0;
	/*short           levelThreeLeafSeven(), levelThreeLeafEight();*/

	result = levelThreeLeafSeven((i | j) & k);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight((i ^ k) >> l);
	if (result != 14)
		statusFlag++;
	return variable;
}

short 
levelThreeLeafOne(short variable)
{
	return variable;
}

short 
levelThreeLeafTwo(short variable)
{
	return variable;
}

short 
levelThreeLeafThree(short variable)
{
	return variable;
}

short 
levelThreeLeafFour(short variable)
{
	return variable;
}

short 
levelThreeLeafFive(short variable)
{
	return variable;
}

short 
levelThreeLeafSix(short variable)
{
	return variable;
}

short 
levelThreeLeafSeven(short variable)
{
	return variable;
}

short 
levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro173()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

char *levelOne(short, char*);
char *levelTwo(short, char*);
char *levelThree(short, char*);

int main(void)
/*
 * test class: bit-wise expression instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	/*lt3414char *levelOne();*/
	static char    *numbers = "01234567890123456789";

	s = levelOne(1, &(numbers[~(~(k | l) >> l) & (l | l << l)]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(short variable, char *numbers)
{
	char           *s;
	/*char *levelTwo();*/
	short           j = variable + 1;

	s = levelTwo(j, numbers - (l | l << l));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char           *
levelTwo(short variable, char *numbers)
{
	char           *s;
	/*char *levelThree();*/
	short           k = variable + 1;

	s = levelThree(k, numbers + (~(i >> l) & (l | l << l)));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char           *
levelThree(short variable, char *numbers)
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro174()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);

int main(void)
/*
 * test class: bit-wise expression instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	/*short           divide4();*/
	short result = 0;

	result = dummy1(divide4, (k >> l & (i | l)) << l);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	short           result = 0;

	result = (*func) (integer & k);
	if (result != 3)
		statusFlag++;
	return result;
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	short           result = 0;

	result = (*func) (integer << l >> l);
	if (result != 6)
		statusFlag++;
	return result;
}

short 
divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro175()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(i & j & k) + levelOneNodeTwo(~(i | j | k) & l) != 62)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	return levelTwoNodeOne(variable & 01 ? variable << 1 : variable | 01)
		+ levelTwoNodeTwo(variable & 02 ?
				  (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelOneNodeTwo(short variable)
{
	return levelTwoNodeThree(variable & 01 ? variable << 1 : variable | 01)
		+ levelTwoNodeFour(variable & 02 ?
				   (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelTwoNodeOne(short variable)
{
	return levelThreeLeafOne(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafTwo(variable & 02 ?
				    (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelTwoNodeTwo(short variable)
{
	return levelThreeLeafThree(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafFour(variable & 02 ?
				     (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelTwoNodeThree(short variable)
{
	return levelThreeLeafFive(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafSix(variable & 02 ?
				    (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelTwoNodeFour(short variable)
{
	return levelThreeLeafSeven(variable & 01 ? variable << 1 : variable | 01)
		+ levelThreeLeafEight(variable & 02 ?
				      (variable & 01 ? variable << 1 ^ 03 : variable << 1) : variable | 02);
}

int levelThreeLeafOne(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafTwo(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafThree(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafFour(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafFive(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafSix(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafSeven(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}

int levelThreeLeafEight(short variable)
{
	return variable & 01 ? variable << 1 : variable | 01;
}
@def_
@def $macro176()
$LICENSE()
$HEAD()

short           i = 025, j = 011, k = 055;

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	short           counter = 0;

	while (levelOneNodeOne(i & j & k) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short variable)
{

	return levelTwoNodeOne(variable << 1) << 1;
}

short 
levelTwoNodeOne(short variable)
{

	return levelThreeLeafOne(variable << 1) << 1;
}

short 
levelThreeLeafOne(short variable)
{
	return variable << 1;
}
@def_
@def $macro177()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";
short           i = 025, j = 011, k = 055, l = 02;

char *skip(short);
int compare(char*, char*, short);

int main(void)				/* alias root */
/*
 *  test class: bit-wise expression instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{

	if (compare(skip(i & k ^ j ^ l << l), protean + 4, 5)
	    == compare(skip((i & k ^ j) & l << l), protean + 8, 6))
		printok();
	else
		printno();
	return 0;
}

char           *
skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro178()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           i = 025, k = 055, l = 02;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);

int main(void)
/*
 * test class: bit-wise expression instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{

	if (dummy1(divide4, (k >> l & (i | l)) << l) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	return (*func) (integer & k);
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	return (*func) (integer << l >> l);
}

short 
divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro179()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

int recursiveFunction(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, no function declaration 
 */
{
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i & j & k, counter);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable, short counter)
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro180()
$LICENSE()
$HEAD()
#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
short           i = 025, j = 011, k = 055, l = 02;

short recursiveFunction(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return an integer 
 */
{
	short           result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i & j & k, counter);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short variable, short counter)
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(++variable << l >> l, --counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro181()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

char *recursiveFunction(short, char*, short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(~(i | j | k) & l, &(numbers[i >> 1]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short variable, char *numbers, short counter)
{
	char           *s;
	short           storage = variable;

	if (--counter) {
		s = recursiveFunction(((variable << l | variable) & j) >> l,
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + storage;
}
@def_
@def $macro182()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

int dummy(short (*)(short), short, short);
short increment(short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           result = 0;
	short           counter = TimeLimit;

	result = dummy(increment, i & j & k, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short variable, short counter)
{
	short           result = 0;
	short           storage = variable;

	if (--counter) {
		result = dummy(function, variable << l >> l, counter);
		if (result != 2)
			statusFlag++;
	}
	return function(storage);
}

short 
increment(short variable)
{
	return ++variable;
}
@def_
@def $macro183()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

int recursiveFunction(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	short           counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2 != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable, short counter)
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro184()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

short recursiveFunction(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           counter = TimeLimit;

	if (recursiveFunction(i & j & k, counter) - 2 != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short variable, short counter)
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction(variable << l >> l, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro185()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

char *recursiveFunction(short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{

	if (*recursiveFunction(i & j & k | l) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short variable)
{
	short           storage = variable;

	if (--counter)
		if (*recursiveFunction(variable << l >> l) != '3')
			statusFlag++;
	return numbers + storage;
}
@def_
@def $macro186()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

int dummy(short (*)(short), short);
short increment(short);

int main(void)
/*
 * test class: bit-wise expression instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{

	if (dummy(increment, i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short variable)
{
	short           storage = variable;

	if (--counter)
		if (dummy(function, variable << l >> l) != 2)
			statusFlag++;
	return function(storage);
}

short 
increment(short variable)
{
	return ++variable;
}
@def_
@def $macro187()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

int castor(short, short);
int pollux(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	short           counter = TimeLimit;
	short           result = 0;

	result = castor(~(i & j & k) & l, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable, short counter)
{
	short           result = 0;

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

int pollux(short variable, short counter)
{
	short           result = 0;

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro188()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
short           i = 025, j = 011, k = 055, l = 02;

short castor(short, short);
short pollux(short, short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, no function declaration  
 */
{
	short           counter = TimeLimit;
	short           result = 0;

	result = castor(~(i & j & k) & l, counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short variable, short counter)
{
	short           result = 0;

	if (--counter) {
		result = pollux(i & j & k, counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

short 
pollux(short variable, short counter)
{
	short           result = 0;

	if (--counter) {
		result = castor(~(i & j & k) & l, counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro189()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

char *castor(short);
char *pollux(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s;

	s = castor(~(i & j & k) & l);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short variable)
{
	char           *s;

	if (--counter) {
		s = pollux(~j & (l | l << 1));
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(short variable)
{
	char           *s;

	if (--counter) {
		s = castor(~(i & j & k) & l);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro190()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, return value, pointer to function returning an integer 
 */
{

	i = castor(increment, i & j & k);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short variable)
{
	short           result = 0;

	if (--counter) {
		result = pollux(function, j << l >> l);
		if (result != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(short), short variable)
{
	short           result = 0;

	if (--counter) {
		result = castor(function, i & j & k);
		if (result != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(short variable)
{
	return ++variable;
}
@def_
@def $macro191()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

int castor(short);
int pollux(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (castor(i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	if (--counter) {
		if (pollux(i & k & j << l) != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	if (--counter) {
		if (castor(i & j & k) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro192()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

short castor(short);
short pollux(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return an integer 
 */
{

	if (castor(i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short variable)
{

	if (--counter) {
		if (pollux(i & j << l & k) != 5)
			statusFlag++;
	}
	return ++variable;
}

short 
pollux(short variable)
{
	if (--counter) {
		if (castor(i & j & k) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro193()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 025, j = 011, k = 055, l = 02;

char *castor(short);
char *pollux(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{

	if (*castor(~(i & j & k) & l) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short variable)
{

	if (--counter) {
		if (*pollux((i >> l | j >> l) >> 1 << 1) != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char           *
pollux(short variable)
{
	if (--counter) {
		if (*castor(~(i & j & k) & l) != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro194()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 025, j = 011, k = 055, l = 02;

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);

int main(void)
/*
 * test class: bit-wise expression instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{

	if (castor(increment, i & j & k) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short variable)
{
	if (--counter) {
		if (pollux(function, k >> l) != 12)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function)(short), short variable)
{
	if (--counter) {
		if (castor(function, i & j & k) != 2)
			statusFlag++;
	}
	return function(variable);
}

short 
increment(short variable)
{
	return ++variable;
}
@def_
@def $macro195()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);
int dummy(short);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(dummy(1));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short argument)
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelOneNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeOne(short argument)
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeThree(short argument)
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeFour(short argument)
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

int levelThreeLeafTwo(short argument)
{
	if (argument != 8)
		statusFlag++;
	return argument;
}

int levelThreeLeafThree(short argument)
{
	if (argument != 9)
		statusFlag++;
	return argument;
}

int levelThreeLeafFour(short argument)
{
	if (argument != 10)
		statusFlag++;
	return argument;
}

int levelThreeLeafFive(short argument)
{
	if (argument != 11)
		statusFlag++;
	return argument;
}

int levelThreeLeafSix(short argument)
{
	if (argument != 12)
		statusFlag++;
	return argument;
}

int levelThreeLeafSeven(short argument)
{
	if (argument != 13)
		statusFlag++;
	return argument;
}

int levelThreeLeafEight(short argument)
{
	if (argument != 14)
		statusFlag++;
	return argument;
}

int dummy(short argument)
{
	return argument;
}
@def_
@def $macro196()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);
int dummy(short);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, return value and legal, integer function declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(dummy(1));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(dummy(2));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short argument)
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(dummy(3));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(dummy(4));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelOneNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(dummy(5));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(dummy(6));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeOne(short argument)
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(dummy(7));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(dummy(8));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(dummy(9));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(dummy(10));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeThree(short argument)
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(dummy(11));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(dummy(12));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeFour(short argument)
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(dummy(13));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(dummy(14));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafTwo(short argument)
{
	if (argument != 8)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafThree(short argument)
{
	if (argument != 9)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafFour(short argument)
{
	if (argument != 10)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafFive(short argument)
{
	if (argument != 11)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafSix(short argument)
{
	if (argument != 12)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafSeven(short argument)
{
	if (argument != 13)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafEight(short argument)
{
	if (argument != 14)
		statusFlag++;
	return argument;
}

int dummy(short argument)
{
	return argument;
}
@def_
@def $macro197()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;


char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);
int dummy(short);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, return value and legal, function declared to return a
 * pointer to character 
 */
{
	char           *s;

	s = levelOne(dummy(1));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(short argument)
{
	char           *s;
	short           i;

	if (argument != 1)
		statusFlag++;
	s = levelTwo(dummy(2));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelTwo(short argument)
{
	char           *s;
	short           i;

	if (argument != 2)
		statusFlag++;
	s = levelThree(dummy(3));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelThree(short argument)
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

int dummy(short argument)
{
	return argument;
}
@def_
@def $macro198()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);
int twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, return value, legal pointer to function returning an
 * integer 
 */
{
	short           i;

	i = dummy1(divide4, twelve());
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	short           i = integer;

	i = (*func) (twelve());
	if (i != 3)
		statusFlag++;
	return i;
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	short           i = integer;

	i = (*func) (twelve());
	if (i != 6)
		statusFlag++;
	return i;
}

short 
divide2(short integer)
{
	return integer / 2;
}

int twelve(void)
{
	return 12;
}
@def_
@def $macro199()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);
int mirror(short);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(mirror(1)) != 1)
		statusFlag++;
	if (levelOneNodeTwo(mirror(2)) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short argument)
{
	if (levelTwoNodeOne(mirror(3)) != 3)
		statusFlag++;
	if (levelTwoNodeTwo(mirror(4)) != 4)
		statusFlag++;
	return argument;
}

int levelOneNodeTwo(short argument)
{
	if (levelTwoNodeThree(mirror(5)) != 5)
		statusFlag++;
	if (levelTwoNodeFour(mirror(6)) != 6)
		statusFlag++;
	return argument;
}

int levelTwoNodeOne(short argument)
{
	if (levelThreeLeafOne(mirror(7)) != 7)
		statusFlag++;
	if (levelThreeLeafTwo(mirror(8)) != 8)
		statusFlag++;
	return argument;
}

int levelTwoNodeTwo(short argument)
{
	if (levelThreeLeafThree(mirror(9)) != 9)
		statusFlag++;
	if (levelThreeLeafFour(mirror(10)) != 10)
		statusFlag++;
	return argument;
}

int levelTwoNodeThree(short argument)
{
	if (levelThreeLeafFive(mirror(11)) != 11)
		statusFlag++;
	if (levelThreeLeafSix(mirror(12)) != 12)
		statusFlag++;
	return argument;
}

int levelTwoNodeFour(short argument)
{
	if (levelThreeLeafSeven(mirror(13)) != 13)
		statusFlag++;
	if (levelThreeLeafEight(mirror(14)) != 14)
		statusFlag++;
	return argument;
}

int levelThreeLeafOne(short argument)
{
	return argument;
}

int levelThreeLeafTwo(short argument)
{
	return argument;
}

int levelThreeLeafThree(short argument)
{
	return argument;
}

int levelThreeLeafFour(short argument)
{
	return argument;
}

int levelThreeLeafFive(short argument)
{
	return argument;
}

int levelThreeLeafSix(short argument)
{
	return argument;
}

int levelThreeLeafSeven(short argument)
{
	return argument;
}

int levelThreeLeafEight(short argument)
{
	return argument;
}

int mirror(short argument)
{
	return argument;
}
@def_
@def $macro200()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           object = 1;

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);
int mirror(short);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{

	if (levelOneNodeOne(mirror(object)) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short argument)
{
	short           object = argument + 2;

	if (levelTwoNodeOne(mirror(object)) != 3)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeOne(short argument)
{
	short           object = argument + 4;

	if (levelThreeLeafOne(mirror(object)) != 7)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

int mirror(short argument)
{
	return argument;
}
@def_
@def $macro201()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

char *skip(short);
int compare(char*, char*, short);
int mirror(short);

int main(void)				/* alias root */
/*
 *  test class: function as argument instance  : linear tree structure, used in conditional expression, function declared to
 * return a pointer to character 
 */
{

	if (compare(skip(mirror(4)), "andra", 5)
	    == compare(skip(mirror(8)), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char           *
skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}

int mirror(short argument)
{
	return argument;
}
@def_
@def $macro202()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);
int twelve(void);

int main(void)
/*
 * test class: function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{

	if (dummy1(divide4, twelve()) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	short           i = integer;

	if ((i = (*func) (twelve())) != 3)
		statusFlag++;
	return i;
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	short           i = integer;

	if ((i = (*func) (twelve())) != 6)
		statusFlag++;
	return i;
}

short 
divide2(short integer)
{
	return integer / 2;
}

int twelve(void)
{
	return 12;
}
@def_
@def $macro203()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int recursiveFunction(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short argument)
{
	short           i;

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int un(void)
{
	static short    un = 1;
	return un;
}
@def_
@def $macro204()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

short recursiveFunction(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, legal, integer function declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short argument)
{
	short           i;

	if (--counter) {
		i = recursiveFunction(un());
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int un(void)
{
	static short    un = 1;
	return un;
}
@def_
@def $macro205()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(short);
int numero(short);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;

	s = recursiveFunction(numero(2));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(numero(3));
		if (*s != '3')
			statusFlag++;
	}
	return numbers + argument;
}

int numero(short deuxOuTrois)
{
	return deuxOuTrois;
}
@def_
@def $macro206()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short(*)(short), short);
short increment(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           i;

	i = dummy(increment, un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = dummy(function, un());
		if (i != 2)
			statusFlag++;
	}
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int un(void)
{
	register short  un = 1;
	return un;
}
@def_
@def $macro207()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int recursiveFunction(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, no function declaration 
 */
{
	if (!(recursiveFunction(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short argument)
{
	if (--counter)
		if (!(recursiveFunction(un()) == 2))
			statusFlag++;
	return ++argument;
}

int un(void)
{
	register short  un = 1;
	return un;
}
@def_
@def $macro208()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

short recursiveFunction(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{

	if (!(recursiveFunction(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short argument)
{

	if (--counter)
		if (!(recursiveFunction(un()) == 2))
			statusFlag++;
	return ++argument;
}

int un(void)
{
	static short    un = 1;
	return un;
}
@def_
@def $macro209()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(short);
int numero(short);

int main(void)
/*
 * test class: function as argument instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{

	if (!(*recursiveFunction(numero(2)) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	if (--counter)
		if (!(*recursiveFunction(numero(3)) == '3'))
			statusFlag++;
	return numbers + argument;
}

int numero(short deuxOuTrois)
{
	return deuxOuTrois;
}
@def_
@def $macro210()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short (*)(short), short);
short increment(short);
int un(void);

int main(void)
/*
 * test class: function as argument instance  : recursive call, in conditional expression, pointer to function returning an
 * integer 
 */
{

	if (!(dummy(increment, un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short argument)
{
	if (--counter)
		if (!(dummy(function, un()) == 2))
			statusFlag++;
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int un(void)
{
	static short    un = 1;
	return un;
}
@def_
@def $macro211()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short);
int pollux(short);
int un(void);
int quatre(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = castor(un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short argument)
{
	short           i;

	if (--counter) {
		i = pollux(quatre());
		if (i != 5)
			statusFlag++;
	}
	return ++argument;
}

int pollux(short argument)
{
	short           i;

	if (--counter) {
		i = castor(un());
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int un(void)
{
	return 1;
}

int quatre(void)
{
	return 4;
}
@def_
@def $macro212()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

short castor(short);
short pollux(short);
int rebound(short);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           i = 0;
	i = castor(rebound(1));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short argument)
{
	short           i;

	if (--counter) {
		i = pollux(rebound(4));
		if (i != 5)
			statusFlag++;
	}
	return ++argument;
}

short 
pollux(short argument)
{
	short           i;

	if (--counter) {
		i = castor(rebound(1));
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int rebound(short argument)
{
	return argument;
}
@def_
@def $macro213()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(short);
char *pollux(short);
int numero(short);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s;

	s = castor(numero(2));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short argument)
{
	char           *s;

	if (--counter) {
		s = pollux(numero(6));
		if (*s != '6')
			statusFlag++;
	}
	return numbers + argument;
}

char           *
pollux(short argument)
{
	char           *s;

	if (--counter) {
		s = castor(numero(3));
		if (*s != '3')
			statusFlag++;
	}
	return numbers + argument;
}

int numero(short questCeQueCest)
{
	static short    tableauDeNumeros[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

	return tableauDeNumeros[questCeQueCest];
}
@def_
@def $macro214()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);
int un(void);
int trois(void);
int neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           i;

	i = castor(increment, un());
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = pollux(function, neuf());
		if (i != 10)
			statusFlag++;
	}
	return function(argument);
}

int pollux(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = castor(function, trois());
		if (i != 4)
			statusFlag++;
	}
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int un(void)
{
	return Un;
}

int trois(void)
{
	return Trois;
}

int neuf(void)
{
	return Neuf;
}
@def_
@def $macro215()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short);
int pollux(short);
int un(void);
int quatre(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (!(castor(un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short argument)
{
	if (--counter)
		if (!(pollux(quatre()) == 5))
			statusFlag++;
	return ++argument;
}

int pollux(short argument)
{
	if (--counter)
		if (!(castor(un()) == 2))
			statusFlag++;
	return ++argument;
}

int un(void)
{
	unsigned short  un = 1;
	return un;
}

int quatre(void)
{
	unsigned short  quatre = 4;
	return quatre;
}
@def_
@def $macro216()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Quatre 4
#endif

short castor(short);
short pollux(short);
int numero(register short);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return an integer 
 */
{

	if (!(castor(numero(Un)) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short argument)
{

	if (--counter)
		if (!(pollux(numero(Quatre)) == 5))
			statusFlag++;
	return ++argument;
}

short 
pollux(short argument)
{
	if (--counter)
		if (!(castor(numero(Un)) == 2))
			statusFlag++;
	return ++argument;
}

int numero(register short questCa)
{
	return questCa;
}
@def_
@def $macro217()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(short);
char *pollux(short);
int numero(register short);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, function declared to return a pointer to
 * character 
 */
{

	if (!(*castor(numero(2)) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short argument)
{

	if (--counter)
		if (!(*pollux(numero(6)) == '6'))
			statusFlag++;
	return numbers + argument;
}

char           *
pollux(short argument)
{
	if (--counter)
		if (!(*castor(numero(3)) == '3'))
			statusFlag++;
	return numbers + argument;
}

int numero(register short numero)
{
	return numero;
}
@def_
@def $macro218()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);
int un(void);
int trois(void);
int neuf(void);

int main(void)
/*
 * test class: function as argument instance  : gemini, in conditional expression, pointer to function returning an integer 
 */
{

	if (!(castor(increment, un()) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short argument)
{
	if (--counter)
		if (!(pollux(function, neuf()) == 10))
			statusFlag++;
	return function(argument);
}

int pollux(short (*function)(short), short argument)
{
	if (--counter)
		if (!(castor(function, trois()) == 4))
			statusFlag++;
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int un(void)
{
	static short    un = 1;
	return un;
}

int trois(void)
{
	static short    trois = 3;
	return trois;
}

int neuf(void)
{
	static short    neuf = 9;
	return neuf;
}
@def_
@def $macro219()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);
int dummy(short, short, short);

int main(void)
/*
 * test class: function as argument, variable order not determined instance  : linear tree structure, return value and
 * legal, function declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 2, a, b, c;

	c = i--;
	b = --i;
	a = ++i;
	s = levelOne(dummy(a, b, c));
	if (*s != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(short argument)
{
	char           *s;
	short           i = argument, a, b, c;

	if (argument != 3)
		statusFlag++;
	c = ++i;
	b = ++i;
	a = i--;
	s = levelTwo(dummy(a, b, c));
	if (*s != '4')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelTwo(short argument)
{
	char           *s;
	short           i = argument, a, b, c;

	if (argument != 4)
		statusFlag++;
	c = i -= 2;
	b = i += 2;
	a = i += 1;
	s = levelThree(dummy(a, b, c));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelThree(short argument)
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

int dummy(short primero, short segundo, short tercero)
{
	return primero - segundo + tercero;
}
@def_
@def $macro220()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(short);
int indeterminacy(short, short, short);

int main(void)
/*
 * test class: function as argument, variable order not determined instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 2;

	s = recursiveFunction(indeterminacy(i++, i--, ++i));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	char           *s;
	short           i = 3;

	if (--counter) {
		s = recursiveFunction(indeterminacy(i--, i++, --i));
		if (*s != '3')
			statusFlag++;
	}
	return numbers + argument;
}

int indeterminacy(short primero, short segundo, short tercero)
{
	return primero - segundo + tercero;
}
@def_
@def $macro221()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(uno(dos(tres(1))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2))));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short argument)
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelOneNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeOne(short argument)
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeThree(short argument)
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelTwoNodeFour(short argument)
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14))));
	if (i == 0)
		statusFlag++;
	return argument;
}

int levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

int levelThreeLeafTwo(short argument)
{
	if (argument != 8)
		statusFlag++;
	return argument;
}

int levelThreeLeafThree(short argument)
{
	if (argument != 9)
		statusFlag++;
	return argument;
}

int levelThreeLeafFour(short argument)
{
	if (argument != 10)
		statusFlag++;
	return argument;
}

int levelThreeLeafFive(short argument)
{
	if (argument != 11)
		statusFlag++;
	return argument;
}

int levelThreeLeafSix(short argument)
{
	if (argument != 12)
		statusFlag++;
	return argument;
}

int levelThreeLeafSeven(short argument)
{
	if (argument != 13)
		statusFlag++;
	return argument;
}

int levelThreeLeafEight(short argument)
{
	if (argument != 14)
		statusFlag++;
	return argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro222()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;


short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(uno(dos(tres(1))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelOneNodeTwo(uno(dos(tres(2))));
	if (i == 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short argument)
{
	short           i = 0;

	if (argument != 1)
		statusFlag++;
	i = levelTwoNodeOne(uno(dos(tres(3))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeTwo(uno(dos(tres(4))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelOneNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 2)
		statusFlag++;
	i = levelTwoNodeThree(uno(dos(tres(5))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelTwoNodeFour(uno(dos(tres(6))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeOne(short argument)
{
	short           i = 0;

	if (argument != 3)
		statusFlag++;
	i = levelThreeLeafOne(uno(dos(tres(7))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafTwo(uno(dos(tres(8))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeTwo(short argument)
{
	short           i = 0;

	if (argument != 4)
		statusFlag++;
	i = levelThreeLeafThree(uno(dos(tres(9))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafFour(uno(dos(tres(10))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeThree(short argument)
{
	short           i = 0;

	if (argument != 5)
		statusFlag++;
	i = levelThreeLeafFive(uno(dos(tres(11))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafSix(uno(dos(tres(12))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeFour(short argument)
{
	short           i = 0;

	if (argument != 6)
		statusFlag++;
	i = levelThreeLeafSeven(uno(dos(tres(13))));
	if (i == 0)
		statusFlag++;
	i = 0;
	i = levelThreeLeafEight(uno(dos(tres(14))));
	if (i == 0)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafTwo(short argument)
{
	if (argument != 8)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafThree(short argument)
{
	if (argument != 9)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafFour(short argument)
{
	if (argument != 10)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafFive(short argument)
{
	if (argument != 11)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafSix(short argument)
{
	if (argument != 12)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafSeven(short argument)
{
	if (argument != 13)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafEight(short argument)
{
	if (argument != 14)
		statusFlag++;
	return argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro223()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s;

	s = levelOne(uno(dos(tres(1))));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(short argument)
{
	char           *s;
	short           i;

	if (argument != 1)
		statusFlag++;
	s = levelTwo(uno(dos(tres(2))));
	if (*s != '2')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelTwo(short argument)
{
	char           *s;
	short           i;

	if (argument != 2)
		statusFlag++;
	s = levelThree(uno(dos(tres(3))));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelThree(short argument)
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro224()
$LICENSE()
$HEAD()

#ifndef TwoDozen
#define TwoDozen 24
#endif

short           statusFlag = NoMistake;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);
int twentyFour(void);
int twoTimes(short);
int half(short);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, return value, legal pointer to function
 * returning an integer 
 */
{
	short           i;

	i = dummy1(divide4, half(twoTimes(half(twentyFour()))));
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	short           i = integer;

	i = (*func) (half(twoTimes(i)));
	if (i != 3)
		statusFlag++;
	return i;
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	short           i = integer;

	i = (*func) (twoTimes(half(i)));
	if (i != 6)
		statusFlag++;
	return i;
}

short 
divide2(short integer)
{
	return integer / 2;
}

int twentyFour(void)
{
	return TwoDozen;
}

int twoTimes(short argument)
{
	return 2 * argument;
}

int half(short argument)
{
	return argument / 2;
}
@def_
@def $macro225()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	if (levelOneNodeOne(uno(dos(tres(1)))) != 1)
		statusFlag++;
	if (levelOneNodeTwo(uno(dos(tres(2)))) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short argument)
{
	if (levelTwoNodeOne(uno(dos(tres(3)))) != 3)
		statusFlag++;
	if (levelTwoNodeTwo(uno(dos(tres(4)))) != 4)
		statusFlag++;
	return argument;
}

int levelOneNodeTwo(short argument)
{
	if (levelTwoNodeThree(uno(dos(tres(5)))) != 5)
		statusFlag++;
	if (levelTwoNodeFour(uno(dos(tres(6)))) != 6)
		statusFlag++;
	return argument;
}

int levelTwoNodeOne(short argument)
{
	if (levelThreeLeafOne(uno(dos(tres(7)))) != 7)
		statusFlag++;
	if (levelThreeLeafTwo(uno(dos(tres(8)))) != 8)
		statusFlag++;
	return argument;
}

int levelTwoNodeTwo(short argument)
{
	if (levelThreeLeafThree(uno(dos(tres(9)))) != 9)
		statusFlag++;
	if (levelThreeLeafFour(uno(dos(tres(10)))) != 10)
		statusFlag++;
	return argument;
}

int levelTwoNodeThree(short argument)
{
	if (levelThreeLeafFive(uno(dos(tres(11)))) != 11)
		statusFlag++;
	if (levelThreeLeafSix(uno(dos(tres(12)))) != 12)
		statusFlag++;
	return argument;
}

int levelTwoNodeFour(short argument)
{
	if (levelThreeLeafSeven(uno(dos(tres(13)))) != 13)
		statusFlag++;
	if (levelThreeLeafEight(uno(dos(tres(14)))) != 14)
		statusFlag++;
	return argument;
}

int levelThreeLeafOne(short argument)
{
	return argument;
}

int levelThreeLeafTwo(short argument)
{
	return argument;
}

int levelThreeLeafThree(short argument)
{
	return argument;
}

int levelThreeLeafFour(short argument)
{
	return argument;
}

int levelThreeLeafFive(short argument)
{
	return argument;
}

int levelThreeLeafSix(short argument)
{
	return argument;
}

int levelThreeLeafSeven(short argument)
{
	return argument;
}

int levelThreeLeafEight(short argument)
{
	return argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro226()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           object = 1;

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, integer
 * function declaration 
 */
{

	if (levelOneNodeOne(uno(dos(tres(object)))) != object)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
levelOneNodeOne(short argument)
{
	short           object = argument + 2;

	if (levelTwoNodeOne(uno(dos(tres(object)))) != 3)
		statusFlag++;
	return argument;
}

short 
levelTwoNodeOne(short argument)
{
	short           object = argument + 4;

	if (levelThreeLeafOne(uno(dos(tres(object)))) != 7)
		statusFlag++;
	return argument;
}

short 
levelThreeLeafOne(short argument)
{
	if (argument != 7)
		statusFlag++;
	return argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro227()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

char *skip(short);
int compare(char*, char*, short);
int uno(short);
int dos(short);
int tres(short);

int main(void)				/* alias root */
/*
 *  test class: nested function as argument instance  : linear tree structure, used in conditional expression, function
 * declared to return a pointer to character 
 */
{

	if (compare(skip(uno(dos(tres(4)))), "andra", 5)
	    == compare(skip(uno(dos(tres(8)))), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char           *
skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro228()
$LICENSE()
$HEAD()

#define TwoDouzen 24
short           statusFlag = NoMistake;

int dummy1(short (*)(short), short);
short divide4(short);
int dummy2(short (*)(short), short);
short divide2(short);
int twoTimes(short);
int half(short);

int main(void)
/*
 * test class: nested function as argument instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{

	if (dummy1(divide4, half(twoTimes(half(TwoDouzen)))) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func)(short), short integer)
{
	short           i;

	if ((i = (*func) (twoTimes(half(integer)))) != 3)
		statusFlag++;
	return i;
}

short 
divide4(short integer)
{

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func)(short), short integer)
{
	short           i;

	if ((i = (*func) (twoTimes(half(integer)))) != 6)
		statusFlag++;
	return i;
}

short 
divide2(short integer)
{
	return integer / 2;
}

int twoTimes(short argument)
{
	return 2 * argument;
}

int half(short argument)
{
	return argument / 2;
}
@def_
@def $macro229()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

int recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short argument)
{
	short           i;

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro230()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

short recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, legal, integer function declaration 
 */
{
	short           i;

	i = recursiveFunction(uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short argument)
{
	short           i;

	if (--counter) {
		i = recursiveFunction(uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro231()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";


char *recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s;

	s = recursiveFunction(uno(dos(tres(Deux))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(uno(dos(tres(Trois))));
		if (*s != '3')
			statusFlag++;
	}
	return numbers + argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro232()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short (*)(short), short);
short increment(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, return value, pointer to function returning an
 * integer 
 */
{
	short           i;

	i = dummy(increment, uno(dos(tres(Un))));
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = dummy(function, uno(dos(tres(Un))));
		if (i != 2)
			statusFlag++;
	}
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro233()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

int recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short argument)
{
	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro234()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

short recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{

	if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
recursiveFunction(short argument)
{

	if (--counter)
		if (!(recursiveFunction(uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro235()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, function declared to
 * return a pointer to character 
 */
{

	if (!(*recursiveFunction(uno(dos(tres(Deux)))) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	if (--counter)
		if (!(*recursiveFunction(uno(dos(tres(Trois)))) == '3'))
			statusFlag++;
	return numbers + argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro236()
$LICENSE()
$HEAD()

#define Un 1
short           statusFlag = NoMistake;
short           counter = 10;

int dummy(short (*)(short), short);
short increment(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : recursive call, in conditional expression, pointer to function
 * returning an integer 
 */
{

	if (!(dummy(increment, uno(dos(tres(Un)))) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function)(short), short argument)
{
	if (--counter)
		if (!(dummy(function, uno(dos(tres(Un)))) == 2))
			statusFlag++;
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro237()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

int castor(short);
int pollux(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i;

	i = castor(uno(dos(tres(Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short argument)
{
	short           i;

	if (--counter) {
		i = pollux(uno(dos(tres(Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return ++argument;
}

int pollux(short argument)
{
	short           i;

	if (--counter) {
		i = castor(uno(dos(tres(Un))));
		if (i != Deux)
			statusFlag++;
	}
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro238()
$LICENSE()
$HEAD()

#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
short           statusFlag = NoMistake;
short           counter = 10;

short castor(short);
short pollux(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           i;

	i = castor(uno(dos(tres(Un))));
	if (i != Deux)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short argument)
{
	short           i;

	if (--counter) {
		i = pollux(uno(dos(tres(Quatre))));
		if (i != Cinq)
			statusFlag++;
	}
	return ++argument;
}

short 
pollux(short argument)
{
	short           i;

	if (--counter) {
		i = castor(uno(dos(tres(Un))));
		if (i != Deux)
			statusFlag++;
	}
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro239()
$LICENSE()
$HEAD()

#define Deux  2
#define Trois 3
#define Neuf  9
short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *castor(short);
char *pollux(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;

	s = castor(uno(dos(tres(Deux))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short argument)
{
	char           *s;

	if (--counter) {
		s = pollux(uno(dos(tres(Neuf))));
		if (*s != '9')
			statusFlag++;
	}
	return numbers + argument;
}

char           *
pollux(short argument)
{
	char           *s;

	if (--counter) {
		s = castor(uno(dos(tres(Trois))));
		if (*s != '3')
			statusFlag++;
	}
	return numbers + argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short numero)
{
	static short    tableauDeNumeros[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

	return tableauDeNumeros[numero];
}
@def_
@def $macro240()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un    1
#define Trois 3
#define Neuf  9
#endif

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           i;

	i = castor(increment, uno(dos(tres(Un))));
	if (i != Un + 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = pollux(function, uno(dos(tres(Neuf))));
		if (i != Neuf + 1)
			statusFlag++;
	}
	return function(argument);
}

int pollux(short (*function)(short), short argument)
{
	short           i;
	if (--counter) {
		i = castor(function, uno(dos(tres(Trois))));
		if (i != Trois + 1)
			statusFlag++;
	}
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro241()
$LICENSE()
$HEAD()

#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif
short           statusFlag = NoMistake;
short           counter = 10;

int castor(short);
int pollux(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, no function declaration 
 */
{
	if (!(castor(uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short argument)
{
	if (--counter)
		if (!(pollux(uno(dos(tres(Quatre)))) == Cinq))
			statusFlag++;
	return ++argument;
}

int pollux(short argument)
{
	if (--counter)
		if (!(castor(uno(dos(tres(Un)))) == Deux))
			statusFlag++;
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro242()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Quatre 4
#define Cinq   5
#endif

short castor(short);
short pollux(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return an
 * integer 
 */
{

	if (!(castor(uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short 
castor(short argument)
{

	if (--counter)
		if (!(pollux(uno(dos(tres(Quatre)))) == Cinq))
			statusFlag++;
	return ++argument;
}

short 
pollux(short argument)
{
	if (--counter)
		if (!(castor(uno(dos(tres(Un)))) == Deux))
			statusFlag++;
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro243()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
#ifndef Numeros
#define Deux  2
#define Trois 3
#define Six   6
#endif

char *castor(short argument);
char *pollux(short argument);
int uno(register short uno);
int dos(register short dos);
int tres(register short tres);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, function declared to return a
 * pointer to character 
 */
{

	if (!(*castor(uno(dos(tres(Deux)))) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
castor(short argument)
{

	if (--counter)
		if (!(*pollux(uno(dos(tres(Six)))) == '6'))
			statusFlag++;
	return numbers + argument;
}

char           *
pollux(short argument)
{
	if (--counter)
		if (!(*castor(uno(dos(tres(Trois)))) == '3'))
			statusFlag++;
	return numbers + argument;
}

int uno(register short uno)
{
	return uno;
}

int dos(register short dos)
{
	return dos;
}

int tres(register short tres)
{
	return tres;
}
@def_
@def $macro244()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
#ifndef Numeros
#define Un     1
#define Deux   2
#define Trois  3
#define Quatre 4
#define Neuf   9
#define Dix   10
#endif

int castor(short (*)(short), short);
int pollux(short (*)(short), short);
short increment(short);
int uno(short);
int dos(short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{

	if (!(castor(increment, uno(dos(tres(Un)))) == Deux))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function)(short), short argument)
{
	if (--counter)
		if (!(pollux(function, uno(dos(tres(Neuf)))) == Dix))
			statusFlag++;
	return function(argument);
}

int pollux(short (*function)(short), short argument)
{
	if (--counter)
		if (!(castor(function, uno(dos(tres(Trois)))) == Quatre))
			statusFlag++;
	return function(argument);
}

short 
increment(short argument)
{
	return ++argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short argument)
{
	return argument;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro245()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);
int uno(short);
int dos(short, short, short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument, random order instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 2, a, b, c;

	c = i--;
	b = --i;
	a = ++i;
	s = levelOne(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
levelOne(short argument)
{
	char           *s;
	short           i = argument, a, b, c;

	if (argument != 3)
		statusFlag++;
	c = ++i;
	b = ++i;
	a = i--;
	s = levelTwo(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '4')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelTwo(short argument)
{
	char           *s;
	short           i = argument, a, b, c;

	if (argument != 4)
		statusFlag++;
	c = i -= 2;
	b = i += 2;
	a = i += 1;
	s = levelThree(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '3')
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

char           *
levelThree(short argument)
{
	char           *s;
	short           i;

	if (argument != 3)
		statusFlag++;
	for (s = numbers, i = 0; i < argument; i++, s++);
	return s;
}

int uno(short argument)
{
	return argument;
}

int dos(short primero, short segundo, short tercero)
{
	return primero - segundo + tercero;
}

int tres(short argument)
{
	return argument;
}
@def_
@def $macro246()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

char *recursiveFunction(short);
int uno(short);
int dos(short, short, short);
int tres(short);

int main(void)
/*
 * test class: nested function as argument, random order instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	short           i = 2, a, b, c;

	c = ++i;
	b = i--;
	a = i++;
	s = recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char           *
recursiveFunction(short argument)
{
	char           *s;
	short           i = 3, a, b, c;

	if (--counter) {
		c = --i;
		b = i++;
		a = i--;
		s = recursiveFunction(uno(dos(tres(a), tres(b), tres(c))));
		if (*s != '3')
			statusFlag;
	}
	return numbers + argument;
}

int uno(short argument)
{
	return argument;
}

int dos(short primero, short segundo, short tercero)
{
	return primero - segundo + tercero;
}

int tres(short argument)
{
	return argument;
}
@def_

@def $testout()
#ifdef unix
#include<stdio.h>
#include<float.h>
#define printok() printf("@OK@\n")
#define printno() printf("@NG@\n")
#define ABS(a) ((a > 0)? (a) : (-(a)))
#define MAX(a, b) ((a > b)? (a) : (b))
#define TGEN_FLT_EQ(a, b) ( ((a)==(b)) || ABS(((a) - (b))) / MAX( ABS(a), ABS(b) ) <= FLT_EPSILON )
#endif
@def_

@dir c89.4-2-06
@file >>def.h $macro0() @file_
@file >>fdef.h $macro1() @file_
@file >>ft3401.c $macro2() @file_
@file >>ft3402.c $macro3() @file_
@file >>ft3404.c $macro4() @file_
@file >>ft3406.c $macro5() @file_
@file >>ft3408.c $macro6() @file_
@file >>ft3410.c $macro7() @file_
@file >>ft3411.c $macro8() @file_
@file >>ft3412.c $macro9() @file_
@file >>ft3414.c $macro10() @file_
@file >>ft3416.c $macro11() @file_
@file >>ft3418.c $macro12() @file_
@file >>ft3420.c $macro13() @file_
@file >>ft3421.c $macro14() @file_
@file >>ft3422.c $macro15() @file_
@file >>ft3424.c $macro16() @file_
@file >>ft3426.c $macro17() @file_
@file >>ft3428.c $macro18() @file_
@file >>ft3430.c $macro19() @file_
@file >>ft3511.c $macro20() @file_
@file >>ft3601.c $macro21() @file_
@file >>ft3602.c $macro22() @file_
@file >>ft3604.c $macro23() @file_
@file >>ft3606.c $macro24() @file_
@file >>ft3608.c $macro25() @file_
@file >>ft3610.c $macro26() @file_
@file >>ft3611.c $macro27() @file_
@file >>ft3612.c $macro28() @file_
@file >>ft3614.c $macro29() @file_
@file >>ft3616.c $macro30() @file_
@file >>ft3618.c $macro31() @file_
@file >>ft3620.c $macro32() @file_
@file >>ft3621.c $macro33() @file_
@file >>ft3622.c $macro34() @file_
@file >>ft3624.c $macro35() @file_
@file >>ft3626.c $macro36() @file_
@file >>ft3628.c $macro37() @file_
@file >>ft3630.c $macro38() @file_
@file >>ft3711.c $macro39() @file_
@file >>lt3101.c $macro40() @file_
@file >>lt3102.c $macro41() @file_
@file >>lt3104.c $macro42() @file_
@file >>lt3112.c $macro43() @file_
@file >>lt3114.c $macro44() @file_
@file >>lt3118.c $macro45() @file_
@file >>lt3120.c $macro46() @file_
@file >>lt3122.c $macro47() @file_
@file >>lt3124.c $macro48() @file_
@file >>lt3126.c $macro49() @file_
@file >>lt3128.c $macro50() @file_
@file >>lt3201.c $macro51() @file_
@file >>lt3202.c $macro52() @file_
@file >>lt3204.c $macro53() @file_
@file >>lt3206.c $macro54() @file_
@file >>lt3208.c $macro55() @file_
@file >>lt3210.c $macro56() @file_
@file >>lt3211.c $macro57() @file_
@file >>lt3212.c $macro58() @file_
@file >>lt3214.c $macro59() @file_
@file >>lt3216.c $macro60() @file_
@file >>lt3218.c $macro61() @file_
@file >>lt3220.c $macro62() @file_
@file >>lt3221.c $macro63() @file_
@file >>lt3222.c $macro64() @file_
@file >>lt3224.c $macro65() @file_
@file >>lt3226.c $macro66() @file_
@file >>lt3228.c $macro67() @file_
@file >>lt3230.c $macro68() @file_
@file >>lt3301.c $macro69() @file_
@file >>lt3302.c $macro70() @file_
@file >>lt3304.c $macro71() @file_
@file >>lt3306.c $macro72() @file_
@file >>lt3308.c $macro73() @file_
@file >>lt3310.c $macro74() @file_
@file >>lt3311.c $macro75() @file_
@file >>lt3312.c $macro76() @file_
@file >>lt3314.c $macro77() @file_
@file >>lt3316.c $macro78() @file_
@file >>lt3318.c $macro79() @file_
@file >>lt3320.c $macro80() @file_
@file >>lt3321.c $macro81() @file_
@file >>lt3322.c $macro82() @file_
@file >>lt3324.c $macro83() @file_
@file >>lt3326.c $macro84() @file_
@file >>lt3328.c $macro85() @file_
@file >>lt3330.c $macro86() @file_
@file >>lt3401.c $macro87() @file_
@file >>lt3402.c $macro88() @file_
@file >>lt3404.c $macro89() @file_
@file >>lt3406.c $macro90() @file_
@file >>lt3408.c $macro91() @file_
@file >>lt3410.c $macro92() @file_
@file >>lt3411.c $macro93() @file_
@file >>lt3412.c $macro94() @file_
@file >>lt3414.c $macro95() @file_
@file >>lt3416.c $macro96() @file_
@file >>lt3418.c $macro97() @file_
@file >>lt3420.c $macro98() @file_
@file >>lt3421.c $macro99() @file_
@file >>lt3422.c $macro100() @file_
@file >>lt3424.c $macro101() @file_
@file >>lt3426.c $macro102() @file_
@file >>lt3428.c $macro103() @file_
@file >>lt3430.c $macro104() @file_
@file >>lt3511.c $macro105() @file_
@file >>lt3601.c $macro106() @file_
@file >>lt3602.c $macro107() @file_
@file >>lt3604.c $macro108() @file_
@file >>lt3606.c $macro109() @file_
@file >>lt3608.c $macro110() @file_
@file >>lt3610.c $macro111() @file_
@file >>lt3611.c $macro112() @file_
@file >>lt3612.c $macro113() @file_
@file >>lt3614.c $macro114() @file_
@file >>lt3616.c $macro115() @file_
@file >>lt3618.c $macro116() @file_
@file >>lt3620.c $macro117() @file_
@file >>lt3621.c $macro118() @file_
@file >>lt3622.c $macro119() @file_
@file >>lt3624.c $macro120() @file_
@file >>lt3626.c $macro121() @file_
@file >>lt3628.c $macro122() @file_
@file >>lt3630.c $macro123() @file_
@file >>lt3711.c $macro124() @file_
@file >>t3103.c $macro125() @file_
@file >>t3104.c $macro126() @file_
@file >>t3105.c $macro127() @file_
@file >>t3106.c $macro128() @file_
@file >>t3108.c $macro129() @file_
@file >>t3109.c $macro130() @file_
@file >>t3110.c $macro131() @file_
@file >>t3111.c $macro132() @file_
@file >>t3113.c $macro133() @file_
@file >>t3114.c $macro134() @file_
@file >>t3115.c $macro135() @file_
@file >>t3116.c $macro136() @file_
@file >>t3117.c $macro137() @file_
@file >>t3119.c $macro138() @file_
@file >>t3120.c $macro139() @file_
@file >>t3121.c $macro140() @file_
@file >>t3123.c $macro141() @file_
@file >>t3124.c $macro142() @file_
@file >>t3125.c $macro143() @file_
@file >>t3126.c $macro144() @file_
@file >>t3127.c $macro145() @file_
@file >>t3128.c $macro146() @file_
@file >>t3129.c $macro147() @file_
@file >>t3130.c $macro148() @file_
@file >>t3203.c $macro149() @file_
@file >>t3204.c $macro150() @file_
@file >>t3205.c $macro151() @file_
@file >>t3206.c $macro152() @file_
@file >>t3208.c $macro153() @file_
@file >>t3209.c $macro154() @file_
@file >>t3210.c $macro155() @file_
@file >>t3214.c $macro156() @file_
@file >>t3215.c $macro157() @file_
@file >>t3216.c $macro158() @file_
@file >>t3217.c $macro159() @file_
@file >>t3218.c $macro160() @file_
@file >>t3219.c $macro161() @file_
@file >>t3220.c $macro162() @file_
@file >>t3223.c $macro163() @file_
@file >>t3224.c $macro164() @file_
@file >>t3225.c $macro165() @file_
@file >>t3226.c $macro166() @file_
@file >>t3227.c $macro167() @file_
@file >>t3228.c $macro168() @file_
@file >>t3229.c $macro169() @file_
@file >>t3230.c $macro170() @file_
@file >>t3303.c $macro171() @file_
@file >>t3304.c $macro172() @file_
@file >>t3305.c $macro173() @file_
@file >>t3306.c $macro174() @file_
@file >>t3307.c $macro175() @file_
@file >>t3308.c $macro176() @file_
@file >>t3309.c $macro177() @file_
@file >>t3310.c $macro178() @file_
@file >>t3313.c $macro179() @file_
@file >>t3314.c $macro180() @file_
@file >>t3315.c $macro181() @file_
@file >>t3316.c $macro182() @file_
@file >>t3317.c $macro183() @file_
@file >>t3318.c $macro184() @file_
@file >>t3319.c $macro185() @file_
@file >>t3320.c $macro186() @file_
@file >>t3323.c $macro187() @file_
@file >>t3324.c $macro188() @file_
@file >>t3325.c $macro189() @file_
@file >>t3326.c $macro190() @file_
@file >>t3327.c $macro191() @file_
@file >>t3328.c $macro192() @file_
@file >>t3329.c $macro193() @file_
@file >>t3330.c $macro194() @file_
@file >>t3403.c $macro195() @file_
@file >>t3404.c $macro196() @file_
@file >>t3405.c $macro197() @file_
@file >>t3406.c $macro198() @file_
@file >>t3407.c $macro199() @file_
@file >>t3408.c $macro200() @file_
@file >>t3409.c $macro201() @file_
@file >>t3410.c $macro202() @file_
@file >>t3413.c $macro203() @file_
@file >>t3414.c $macro204() @file_
@file >>t3415.c $macro205() @file_
@file >>t3416.c $macro206() @file_
@file >>t3417.c $macro207() @file_
@file >>t3418.c $macro208() @file_
@file >>t3419.c $macro209() @file_
@file >>t3420.c $macro210() @file_
@file >>t3423.c $macro211() @file_
@file >>t3424.c $macro212() @file_
@file >>t3425.c $macro213() @file_
@file >>t3426.c $macro214() @file_
@file >>t3427.c $macro215() @file_
@file >>t3428.c $macro216() @file_
@file >>t3429.c $macro217() @file_
@file >>t3430.c $macro218() @file_
@file >>t3505.c $macro219() @file_
@file >>t3515.c $macro220() @file_
@file >>t3603.c $macro221() @file_
@file >>t3604.c $macro222() @file_
@file >>t3605.c $macro223() @file_
@file >>t3606.c $macro224() @file_
@file >>t3607.c $macro225() @file_
@file >>t3608.c $macro226() @file_
@file >>t3609.c $macro227() @file_
@file >>t3610.c $macro228() @file_
@file >>t3613.c $macro229() @file_
@file >>t3614.c $macro230() @file_
@file >>t3615.c $macro231() @file_
@file >>t3616.c $macro232() @file_
@file >>t3617.c $macro233() @file_
@file >>t3618.c $macro234() @file_
@file >>t3619.c $macro235() @file_
@file >>t3620.c $macro236() @file_
@file >>t3623.c $macro237() @file_
@file >>t3624.c $macro238() @file_
@file >>t3625.c $macro239() @file_
@file >>t3626.c $macro240() @file_
@file >>t3627.c $macro241() @file_
@file >>t3628.c $macro242() @file_
@file >>t3629.c $macro243() @file_
@file >>t3630.c $macro244() @file_
@file >>t3705.c $macro245() @file_
@file >>t3715.c $macro246() @file_
@file >>testout.h $testout() @file_
@dir_
