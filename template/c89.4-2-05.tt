@comment
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
ishiura-gcc@ksc.kwansei.ac.jp

This file was written by Yuki Uchiyama. (ishiura-gcc@ksc.kwansei.ac.jp)
@comment_

@include
license.inc
@include_

@def $HEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "def.h"
@def_

@def $FHEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "fdef.h"
@def_

@def $macro0()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
#define NoMistake 00
@def_

@def $macro1()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
float           OK_f = 1.0;
float           NO_f = 0.0;
#define NoMistake 00
@def_

@def $macro2()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

short           statusFlag = NoMistake;
float           i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, no return value and legal 
 */
{
	extern float    i;

	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *argument)
{
	extern float    i11;

	if ( !(TGEN_FLT_EQ(*argument, 1.0)) )
		statusFlag++;
	i11 = 3.0;
	levelTwoNodeOne(&i11);
	i11 = 4.0;
	levelTwoNodeTwo(&i11);
}

void levelOneNodeTwo(float *argument)
{
	extern float    i12;

	if ( !(TGEN_FLT_EQ(*argument, 2.0)) )
		statusFlag++;
	i12 = 5.0;
	levelTwoNodeThree(&i12);
	i12 = 6.0;
	levelTwoNodeFour(&i12);
}

void levelTwoNodeOne(float *argument)
{
	extern float    i21;

	if ( !(TGEN_FLT_EQ(*argument, 3.0)) )
		statusFlag++;
	i21 = 7.0;
	levelThreeLeafOne(&i21);
	i21 = 8.0;
	levelThreeLeafTwo(&i21);
}

void levelTwoNodeTwo(float *argument)
{
	extern float    i22;

	if ( !(TGEN_FLT_EQ(*argument, 4.0)) )
		statusFlag++;
	i22 = 9.0;
	levelThreeLeafThree(&i22);
	i22 = 10.0;
	levelThreeLeafFour(&i22);
}

void levelTwoNodeThree(float *argument)
{
	extern float    i23;

	if ( !(TGEN_FLT_EQ(*argument, 5.0)) )
		statusFlag++;
	i23 = 11.0;
	levelThreeLeafFive(&i23);
	i23 = 12.0;
	levelThreeLeafSix(&i23);
}

void levelTwoNodeFour(float *argument)
{
	extern float    i24;

	if ( !(TGEN_FLT_EQ(*argument, 6.0)) )
		statusFlag++;
	i24 = 13.0;
	levelThreeLeafSeven(&i24);
	i24 = 14.0;
	levelThreeLeafEight(&i24);
}

void levelThreeLeafOne(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 7.0)) )
		statusFlag++;
}

void levelThreeLeafTwo(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 8.0)) )
		statusFlag++;
}

void levelThreeLeafThree(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 9.0)) )
		statusFlag++;
}

void levelThreeLeafFour(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 10.0)) )
		statusFlag++;
}

void levelThreeLeafFive(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 11.0)) )
		statusFlag++;
}

void levelThreeLeafSix(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 12.0)) )
		statusFlag++;
}

void levelThreeLeafSeven(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 13.0)) )
		statusFlag++;
}

void levelThreeLeafEight(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 14.0)) )
		statusFlag++;
}
@def_
@def $macro3()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

short           statusFlag = NoMistake;
float           i, i11, i12, i21, i22, i23, i24;
float           result;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, no return value and illegal 
 */
{
	extern float    i;

	i = 1.0;
/*	result = levelOneNodeOne(&i);*/
	i = 2.0;
/*	result = levelOneNodeTwo(&i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *argument)
{
	extern float    i11;

	if ( !(TGEN_FLT_EQ(*argument, 1.0)) )
		statusFlag++;
	i11 = 3.0;
/*	result = levelTwoNodeOne(&i11);*/
	i11 = 4.0;
/*	result = levelTwoNodeTwo(&i11);*/
}

void levelOneNodeTwo(float *argument)
{
	extern float    i12;

	if ( !(TGEN_FLT_EQ(*argument, 2.0)) )
		statusFlag++;
	i12 = 5.0;
/*	result = levelTwoNodeThree(&i12);*/
	i12 = 6.0;
/*	result = levelTwoNodeFour(&i12);*/
}

void levelTwoNodeOne(float *argument)
{
	extern float    i21;

	if ( !(TGEN_FLT_EQ(*argument, 3.0)) )
		statusFlag++;
	i21 = 7.0;
/*	result = levelThreeLeafOne(&i21);*/
	i21 = 8.0;
/*	result = levelThreeLeafTwo(&i21);*/
}

void levelTwoNodeTwo(float *argument)
{
	extern float    i22;

	if ( !(TGEN_FLT_EQ(*argument, 4.0)) )
		statusFlag++;
	i22 = 9.0;
/*	result = levelThreeLeafThree(&i22);*/
	i22 = 10.0;
/*	result = levelThreeLeafFour(&i22);*/
}

void levelTwoNodeThree(float *argument)
{
	extern float    i23;

	if ( !(TGEN_FLT_EQ(*argument, 5.0)) )
		statusFlag++;
	i23 = 11.0;
/*	result = levelThreeLeafFive(&i23);*/
	i23 = 12.0;
/*	result = levelThreeLeafSix(&i23);*/
}

void levelTwoNodeFour(float *argument)
{
	extern float    i24;

	if ( !(TGEN_FLT_EQ(*argument, 6.0)) )
		statusFlag++;
	i24 = 13.0;
/*	result = levelThreeLeafSeven(&i24);*/
	i24 = 14.0;
/*	result = levelThreeLeafEight(&i24);*/
}

void levelThreeLeafOne(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 7.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafTwo(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 8.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafThree(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 9.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafFour(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 10.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafFive(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 11.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafSix(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 12.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafSeven(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 13.0)) )
		statusFlag++;
	return;
}

void levelThreeLeafEight(float *argument)
{
	if ( !(TGEN_FLT_EQ(*argument, 14.0)) )
		statusFlag++;
	return;
}
@def_
@def $macro4()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelOneNodeTwo(float*);
float levelTwoNodeOne(float*);
float levelTwoNodeTwo(float*);
float levelTwoNodeThree(float*);
float levelTwoNodeFour(float*);
float levelThreeLeafOne(float*);
float levelThreeLeafTwo(float*);
float levelThreeLeafThree(float*);
float levelThreeLeafFour(float*);
float levelThreeLeafFive(float*);
float levelThreeLeafSix(float*);
float levelThreeLeafSeven(float*);
float levelThreeLeafEight(float*);

short           statusFlag = NoMistake;
float           i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, return value and legal, Float function
 * declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	i = 1.0;
	result = levelOneNodeOne(&i);
	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *argument)
{
	float           result = 0.0;
	extern float    i11;

	i11 = 3.0;
	result = levelTwoNodeOne(&i11);
	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	i11 = 4.0;
	result = levelTwoNodeTwo(&i11);
	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return *argument;
}

float levelOneNodeTwo(float *argument)
{
	float           result = 0.0;
	extern float    i12;

	i12 = 5.0;
	result = levelTwoNodeThree(&i12);
	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	i12 = 6.0;
	result = levelTwoNodeFour(&i12);
	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return *argument;
}

float levelTwoNodeOne(float *argument)
{
	float           result = 0.0;
	extern float    i21;

	i21 = 7.0;
	result = levelThreeLeafOne(&i21);
	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	i21 = 8.0;
	result = levelThreeLeafTwo(&i21);
	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return *argument;
}

float levelTwoNodeTwo(float *argument)
{
	float           result = 0.0;
	extern float    i22;

	i22 = 9.0;
	result = levelThreeLeafThree(&i22);
	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	i22 = 10.0;
	result = levelThreeLeafFour(&i22);
	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return *argument;
}

float levelTwoNodeThree(float *argument)
{
	float           result = 0.0;
	extern float    i23;

	i23 = 11.0;
	result = levelThreeLeafFive(&i23);
	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	i23 = 12.0;
	result = levelThreeLeafSix(&i23);
	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return *argument;
}

float levelTwoNodeFour(float *argument)
{
	float           result = 0.0;
	extern float    i24;

	i24 = 13.0;
	result = levelThreeLeafSeven(&i24);
	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	i24 = 14.0;
	result = levelThreeLeafEight(&i24);
	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return *argument;
}

float levelThreeLeafOne(float *argument)
{
	return *argument;
}

float levelThreeLeafTwo(float *argument)
{
	return *argument;
}

float levelThreeLeafThree(float *argument)
{
	return *argument;
}

float levelThreeLeafFour(float *argument)
{
	return *argument;
}

float levelThreeLeafFive(float *argument)
{
	return *argument;
}

float levelThreeLeafSix(float *argument)
{
	return *argument;
}

float levelThreeLeafSeven(float *argument)
{
	return *argument;
}

float levelThreeLeafEight(float *argument)
{
	return *argument;
}
@def_
@def $macro5()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

short           statusFlag = NoMistake;
float           i = 12.0;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, return value, legal pointer to function returning
 * an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = dummy1(divide4, &i);
	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return i;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return i;
}

float divide2(float *Float)
{
	return *Float / 2;
}
@def_
@def $macro6()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelTwoNodeOne(float*);
float levelThreeLeafOne(float*);

short           statusFlag = NoMistake;
float           i = 1.0, ii, iii;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *variable)
{
	extern float    ii;

	ii = 2.0 * (*variable);
	return 2 * levelTwoNodeOne(&ii);
}

float levelTwoNodeOne(float *variable)
{
	extern float    iii;

	iii = 2.0 * (*variable);
	return 2 * levelThreeLeafOne(&iii);
}

float levelThreeLeafOne(float *variable)
{
	return 2 * (*variable);
}
@def_
@def $macro7()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

short           statusFlag = NoMistake;
float           i = 12.0;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 3.0)) )
		statusFlag++;
	return ii;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 6.0)) )
		statusFlag++;
	return ii;
}

float divide2(float *Float)
{
	return *Float / 2;
}
@def_
@def $macro8()
$LICENSE()
$FHEAD()

void recursiveFunction(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, no return value, legal 
 */
{
	extern float    i;

	i = 1.0;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro9()
$LICENSE()
$FHEAD()

void recursiveFunction(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii;
float           result;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, no return value, illegal 
 */
{
/*	result = recursiveFunction(&i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float *variable)
{
	if ( !(TGEN_FLT_EQ((ii = *variable), i)) )
		statusFlag++;
/*	if (--counter)
		result = recursiveFunction(&ii);*/
	return;
}
@def_
@def $macro10()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, legal, Float function declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	result = recursiveFunction(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	extern float    i;
	float           result = 0.0;

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return i + 1;
}
@def_
@def $macro11()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, pointer to function returning an Float 
 */
{
	float           result = 0;

	result = dummy(increment, &i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	float result ;

	if (--counter) {
		result = dummy(function, variable);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(*variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro12()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 1.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	if (--counter)
		if ( !(TGEN_FLT_EQ(recursiveFunction(variable) - *variable, 1.0)) )
			statusFlag++;
	return (*variable) + 1;
}
@def_
@def $macro13()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*b);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, in conditional expression, pointer to function returning
 * an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, variable);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(*variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro14()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, no return value, legal 
 */
{
	extern float    i;

	i = 1;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	extern float    ii;

	ii = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		ii++;
		pollux(&ii);
	}
}

void pollux(float *variable)
{
	extern float    iii;

	iii = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--iii;
		castor(&iii);
	}
}
@def_
@def $macro15()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           zero = 0.0;	/* modified by m2 on Apr. 23, 1984 */
float          *i = &zero;	/* modified by m2 on Apr. 23, 1984 */
float           result;

int main(void)
/*
 * test class: extern variable address instance  : gemini, no return value, illegal 
 */
{
/*	result = castor(i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
/*	if (--counter)
		result = pollux(variable);*/
}

void pollux(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
/*	if (--counter)
		result = castor(variable);*/
}
@def_
@def $macro16()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, legal, function declared to return an Float 
 */
{
	float           result = 0;

	result = castor(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	float           result = 0.0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return *variable + 1;
}

float pollux(float *variable)
{
	float           result = 0.0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro17()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float*);
float pollux(float (*) (float), float*);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, pointer to function returning an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = castor(increment, &i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float *variable)
{
	extern float    ii;
	float           result = 0.0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return function(*variable);
}

float pollux(float (*function) (float), float *variable)
{
	extern float    iii;
	float           result = 0.0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(*variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro18()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, function declared to return an Float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	float           arg_a, arg_b;

	ii = *variable + 3;
	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 5.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return *variable + 1;
}

float pollux(float *variable)
{
	float           arg_a, arg_b;

	iii = *variable - 3;
	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro19()
$LICENSE()
$FHEAD()

float castor(float (*) (float), float*);
float pollux(float (*) (float), float*);
float increment(float);

short           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, pointer to function returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float (*function) (float), float *variable)
{
	extern float    ii;
	float           arg_a, arg_b;

	ii = *variable + 10;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 12.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(*variable);
}

float pollux(float (*function) (float), float *variable)
{
	extern float    iii;
	float           arg_a, arg_b;

	iii = *variable - 10;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(*variable);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro20()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	extern float    i;

	i = 1.0;
	levelOneNodeOne(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	levelOneNodeTwo(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *variable)
{
	(*variable) = 3.0;
	levelTwoNodeOne(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 4.0;
	levelTwoNodeTwo(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelOneNodeTwo(float *variable)
{
	(*variable) = 5.0;
	levelTwoNodeThree(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 6.0;
	levelTwoNodeFour(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeOne(float *variable)
{
	(*variable) = 7.0;
	levelThreeLeafOne(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 8.0;
	levelThreeLeafTwo(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeTwo(float *variable)
{
	(*variable) = 9.0;
	levelThreeLeafThree(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 10.0;
	levelThreeLeafFour(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeThree(float *variable)
{
	(*variable) = 11.0;
	levelThreeLeafFive(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 12.0;
	levelThreeLeafSix(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeFour(float *variable)
{
	(*variable) = 13.0;
	levelThreeLeafSeven(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 14.0;
	levelThreeLeafEight(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelThreeLeafOne(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafTwo(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafThree(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafFour(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafFive(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafSix(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafSeven(float *variable)
{
	(*variable) = 0.0;
}

void levelThreeLeafEight(float *variable)
{
	(*variable) = 0.0;
}
@def_
@def $macro21()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           i;
float           result;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	i = 1.0;
	levelOneNodeOne(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	levelOneNodeTwo(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	*variable = 3.0;
	levelTwoNodeOne(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 4.0;
	levelTwoNodeTwo(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelOneNodeTwo(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	*variable = 5.0;
	levelTwoNodeThree(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 6.0;
	levelTwoNodeFour(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeOne(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 3.0)) )
		statusFlag++;
	*variable = 7.0;
	levelThreeLeafOne(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 8.0;
	levelThreeLeafTwo(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeTwo(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 4.0)) )
		statusFlag++;
	*variable = 9.0;
	levelThreeLeafThree(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 10.0;
	levelThreeLeafFour(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeThree(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 5.0)) )
		statusFlag++;
	*variable = 11.0;
	levelThreeLeafFive(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 12.0;
	levelThreeLeafSix(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelTwoNodeFour(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, 6.0)) )
		statusFlag++;
	*variable = 13.0;
	levelThreeLeafSeven(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 14.0;
	levelThreeLeafEight(variable);
	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

void levelThreeLeafOne(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafTwo(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafThree(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafFour(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafFive(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafSix(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafSeven(float *variable)
{
	*variable = 0.0;
}

void levelThreeLeafEight(float *variable)
{
	*variable = 0.0;
}
@def_
@def $macro22()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelOneNodeTwo(float*);
float levelTwoNodeOne(float*);
float levelTwoNodeTwo(float*);
float levelTwoNodeThree(float*);
float levelTwoNodeFour(float*);
float levelThreeLeafOne(float*);
float levelThreeLeafTwo(float*);
float levelThreeLeafThree(float*);
float levelThreeLeafFour(float*);
float levelThreeLeafFive(float*);
float levelThreeLeafSix(float*);
float levelThreeLeafSeven(float*);
float levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, return value and legal,
 * Float function declaration 
 */
{
	float           result = 0.0;

	i = 1.0;
	result = levelOneNodeOne(&i);
	if ( !(TGEN_FLT_EQ(result, 1.0)) || !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) || !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 3.0;
	result = levelTwoNodeOne(variable);
	if ( !(TGEN_FLT_EQ(result, 3.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 4.0;
	result = levelTwoNodeTwo(variable);
	if ( !(TGEN_FLT_EQ(result, 4.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelOneNodeTwo(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 5.0;
	result = levelTwoNodeThree(variable);
	if ( !(TGEN_FLT_EQ(result, 5.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 6.0;
	result = levelTwoNodeFour(variable);
	if ( !(TGEN_FLT_EQ(result, 6.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeOne(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 7.0;
	result = levelThreeLeafOne(variable);
	if ( !(TGEN_FLT_EQ(result, 7.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 8.0;
	result = levelThreeLeafTwo(variable);
	if ( !(TGEN_FLT_EQ(result, 8.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeTwo(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 9.0;
	result = levelThreeLeafThree(variable);
	if ( !(TGEN_FLT_EQ(result, 9.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 10.0;
	result = levelThreeLeafFour(variable);
	if ( !(TGEN_FLT_EQ(result, 10.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeThree(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 11.0;
	result = levelThreeLeafFive(variable);
	if ( !(TGEN_FLT_EQ(result, 11.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 12.0;
	result = levelThreeLeafSix(variable);
	if ( !(TGEN_FLT_EQ(result, 12.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeFour(float *variable)
{
	float           storage = (*variable), result = 0.0;

	(*variable) = 13.0;
	result = levelThreeLeafSeven(variable);
	if ( !(TGEN_FLT_EQ(result, 13.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 14.0;
	result = levelThreeLeafEight(variable);
	if ( !(TGEN_FLT_EQ(result, 14.0)) || !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return storage;
}

float levelThreeLeafOne(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafTwo(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafThree(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafFour(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafFive(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafSix(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafSeven(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}

float levelThreeLeafEight(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return i;
}
@def_
@def $macro23()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

float           statusFlag = NoMistake;
float           i = 12.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = dummy1(divide4, &i);
	if ( !(TGEN_FLT_EQ(result, 3.0)) || !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 3.0)) || !(TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return i;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 6.0)) || !(TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return i;
}

float divide2(float *Float)
{
	float           i = *Float;

	(*Float) = 0.0;
	return i / 2.0;
}
@def_
@def $macro24()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelTwoNodeOne(float*);
float levelThreeLeafOne(float*);

float           statusFlag = NoMistake;
float           i = 1.0;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Float function declaration 
 */
{
	extern float    i;

	if ( TGEN_FLT_EQ(!levelOneNodeOne(&i), 32.0) || !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *variable)
{
	(*variable) *= 2.0;
	return 2.0 * levelTwoNodeOne(variable);
}

float levelTwoNodeOne(float *variable)
{
	(*variable) *= 2.0;
	return 2.0 * levelThreeLeafOne(variable);
}

float levelThreeLeafOne(float *variable)
{
	float           i = *variable;

	(*variable) = 0.0;
	return 2.0 * i;
}
@def_
@def $macro25()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

float           statusFlag = NoMistake;
float           i = 12.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) || !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 3.0)) || !(TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return ii;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 6.0)) || !(TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return ii;
}

float divide2(float *Float)
{
	float           i = *Float;

	(*Float) = 0.0;
	return i / 2.0;
}
@def_
@def $macro26()
$LICENSE()
$FHEAD()

void recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 10.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	extern float    i;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float *variable)
{
	if ( !(TGEN_FLT_EQ(*variable, counter)) )
		statusFlag++;
	(*variable) -= 1.0;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro27()
$LICENSE()
$FHEAD()

void recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 10.0;
float           result;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	extern float    i;

/*	result = recursiveFunction(&i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float *variable)
{
	if (--counter) {
		if ( !(TGEN_FLT_EQ(counter, --(*variable))) ){
			statusFlag++;
		}
/*		result = recursiveFunction(variable);*/
	}
	return;
}
@def_
@def $macro28()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	result = recursiveFunction(&i);
	if ( !(TGEN_FLT_EQ(result, i)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	float           result = 0.0;

	if (--counter) {
		result = recursiveFunction(variable);
		if ( !(TGEN_FLT_EQ(result, *variable)) )
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro29()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = dummy(increment, &i);
	if ( !(TGEN_FLT_EQ(result - i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	float           result;
	extern float    i;

	i = *variable;
	if (--counter) {
		result = dummy(function, &i);
		if ( !(TGEN_FLT_EQ(result - i, 2.0)) )
			statusFlag++;
	}
	return function(((*variable) -= 1.0) + 1.0);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro30()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Float function declaration 
 */
{
	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	extern float    i;
	float           arg_a, arg_b;

	i = *variable;
	if (--counter){
		arg_a = recursiveFunction(&i) - i;
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ((*variable) -= 1.0) + 2.0;
}
@def_
@def $macro31()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i) - i;
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	float           arg_a, arg_b;

	i = *variable;
	if (--counter){
		arg_a = dummy(function, &i) - i;
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(((*variable) -= 1.0) + 1.0);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro32()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	extern float    i;

	castor(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	extern float    i;

	i = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if ( !(TGEN_FLT_EQ(i, 3.0)) )
			statusFlag++;
	}
	(*variable) = 0.0;
}

void pollux(float *variable)
{
	extern float    i;

	i = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			statusFlag++;
	}
	(*variable) = 3.0;
}
@def_
@def $macro33()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0;
float           result;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	castor(&i);
	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	i = *variable;
	if (--counter) {
		pollux(&i);
		if ( !(TGEN_FLT_EQ(i, 2.0)) )
			statusFlag++;
	}
	*variable = 0.0;
}

void pollux(float *variable)
{
	i = *variable;
	if (--counter) {
		castor(&i);
		if ( !(TGEN_FLT_EQ(i, 0.0)) )
			statusFlag++;
	}
	*variable = 2.0;
}
@def_
@def $macro34()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);
float           statusFlag = NoMistake;
short           counter = 10;
float           i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an Float 
 */
{
	float           result = 0.0;

	i = 1.0;
	result = castor(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) || !(TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	float           result = 0.0;

	ii = *variable + 3.0;
	if (--counter) {
		result = pollux(&ii);
		if ( !(TGEN_FLT_EQ(result, ii + 2.0)) )
			statusFlag++;
	}
	return ++(*variable);
}

float pollux(float *variable)
{
	float           result = 0.0;

	iii = *variable - 3.0;
	if (--counter) {
		result = castor(&iii);
		if ( !(TGEN_FLT_EQ(result, iii)) )
			statusFlag++;
	}
	return --(*variable) + 2.0;
}
@def_
@def $macro35()
$LICENSE()
$FHEAD()

int castor(float (*) (float*), float*);
int pollux(float (*) (float*), float*);
float increment(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * an Float 
 */
{
	float           result = 0.0;

	result = castor(increment, &i);
	if ( !(TGEN_FLT_EQ(result, i + 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(float (*function) (float*), float *variable)
{
	float           result = 0.0;

	ii = *variable + 8.0;
	if (--counter) {
		result = pollux(function, &ii);
		if ( !(TGEN_FLT_EQ(result, ii + 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

int pollux(float (*function) (float*), float *variable)
{
	float           result = 0.0;

	iii = *variable - 8.0;
	if (--counter) {
		result = castor(function, &iii);
		if ( !(TGEN_FLT_EQ(result, iii + 2.0)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float *variable)
{
	float           i = *variable;

	(*variable) -= 1.0;
	return ++i;
}
@def_
@def $macro36()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return an Float 
 */
{
	extern float    i;
   float           arg_a, arg_b;

	i = 1.0;
	arg_a = castor(&i) - i;
	arg_b = 0.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	extern float    ii;
   float           arg_a, arg_b;

	ii = *variable + 3.0;
	if (--counter) {
		arg_a = pollux(&ii) - ii;
		arg_b = 0.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++(*variable);
}

float pollux(float *variable)
{
	extern float    iii;
	float           arg_a, arg_b;

	iii = *variable - 3.0;
	if (--counter) {
		arg_a = castor(&iii) - iii;
		arg_b = 0.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro37()
$LICENSE()
$FHEAD()

int castor(float (*) (float*), float*);
int pollux(float (*) (float*), float*);
float increment(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = i + 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(float (*function) (float*), float *variable)
{
	float           arg_a, arg_b;

	ii = *variable + 10.0;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = ii + 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(variable);
}

int pollux(float (*function) (float*), float *variable)
{
	float           arg_a, arg_b;

	iii = *variable - 10.0;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = iii + 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(variable);
}

float increment(float *variable)
{
	return --(*variable) + 2.0;
}
@def_
@def $macro38()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *variable)
{
	*variable = 3.0;
	levelTwoNodeOne(variable);
	*variable = 4.0;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(float *variable)
{
	*variable = 5.0;
	levelTwoNodeThree(variable);
	*variable = 6.0;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(float *variable)
{
	*variable = 7.0;
	levelThreeLeafOne(variable);
	*variable = 8.0;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(float *variable)
{
	*variable = 9.0;
	levelThreeLeafThree(variable);
	*variable = 10.0;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(float *variable)
{
	*variable = 11.0;
	levelThreeLeafFive(variable);
	*variable = 12.0;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(float *variable)
{
	*variable = 13.0;
	levelThreeLeafSeven(variable);
	*variable = 14.0;
	levelThreeLeafEight(variable);
}

void levelThreeLeafOne(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;

}

void levelThreeLeafTwo(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafThree(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafFour(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafFive(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafSix(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafSeven(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafEight(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro39()
$LICENSE()
$FHEAD()

void levelOneNodeOne(float*);
void levelOneNodeTwo(float*);
void levelTwoNodeOne(float*);
void levelTwoNodeTwo(float*);
void levelTwoNodeThree(float*);
void levelTwoNodeFour(float*);
void levelThreeLeafOne(float*);
void levelThreeLeafTwo(float*);
void levelThreeLeafThree(float*);
void levelThreeLeafFour(float*);
void levelThreeLeafFive(float*);
void levelThreeLeafSix(float*);
void levelThreeLeafSeven(float*);
void levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           i;
float           result;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	i = 1.0;
/*	result = levelOneNodeOne(&i);*/
	i = 2.0;
/*	result = levelOneNodeTwo(&i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(float *variable)
{
	*variable = 3.0;
/*	result = levelTwoNodeOne(variable);*/
	*variable = 4.0;
/*	result = levelTwoNodeTwo(variable);*/
}

void levelOneNodeTwo(float *variable)
{
	*variable = 5.0;
/*	result = levelTwoNodeThree(variable);*/
	*variable = 6.0;
/*	result = levelTwoNodeFour(variable);*/
}

void levelTwoNodeOne(float *variable)
{
	*variable = 7.0;
/*	result = levelThreeLeafOne(variable);*/
	*variable = 8.0;
/*	result = levelThreeLeafTwo(variable);*/
}

void levelTwoNodeTwo(float *variable)
{
	*variable = 9.0;
/*	result = levelThreeLeafThree(variable);*/
	*variable = 10.0;
/*	result = levelThreeLeafFour(variable);*/
}

void levelTwoNodeThree(float *variable)
{
	*variable = 11.0;
/*	result = levelThreeLeafFive(variable);*/
	*variable = 12.0;
/*	result = levelThreeLeafSix(variable);*/
}

void levelTwoNodeFour(float *variable)
{
	*variable = 13.0;
/*	result = levelThreeLeafSeven(variable);*/
	*variable = 14.0;
/*	result = levelThreeLeafEight(variable);*/
}

void levelThreeLeafOne(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafTwo(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafThree(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafFour(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafFive(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafSix(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafSeven(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

void levelThreeLeafEight(float *variable)
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro40()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelOneNodeTwo(float*);
float levelTwoNodeOne(float*);
float levelTwoNodeTwo(float*);
float levelTwoNodeThree(float*);
float levelTwoNodeFour(float*);
float levelThreeLeafOne(float*);
float levelThreeLeafTwo(float*);
float levelThreeLeafThree(float*);
float levelThreeLeafFour(float*);
float levelThreeLeafFive(float*);
float levelThreeLeafSix(float*);
float levelThreeLeafSeven(float*);
float levelThreeLeafEight(float*);

float           statusFlag = NoMistake;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, return value and legal, Float
 * function declaration 
 */
{
	float           result = 0.0;

	result = levelOneNodeOne(&i);
	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 3.0;
	result = levelTwoNodeOne(variable);
	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return storage;
}

float levelOneNodeTwo(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 5.0;
	result = levelTwoNodeThree(variable);
	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeOne(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 7.0;
	result = levelThreeLeafOne(variable);
	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeTwo(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 9.0;
	result = levelThreeLeafThree(variable);
	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeThree(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 11.0;
	result = levelThreeLeafFive(variable);
	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return storage;
}

float levelTwoNodeFour(float *variable)
{
	float           storage = *variable, result = 0.0;

	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return storage;
}

float levelThreeLeafOne(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafTwo(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafThree(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafFour(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafFive(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafSix(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafSeven(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}

float levelThreeLeafEight(float *variable)
{
	float           i = *variable;

	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return i;
}
@def_
@def $macro41()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

float           statusFlag = NoMistake;
float           globalInteger = 10.0;
float           i = 12.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning an Float 
 */
{
	float           result = 0.0;

	result = dummy1(divide4, &i);
	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	Float = &globalInteger;
	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return i;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           i;

	i = (*func) (Float);
	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	Float = &globalInteger;
	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return i;
}

float divide2(float *Float)
{
	float           i = *Float;

	(*Float) = 0.0;
	return i / 2.0;
}
@def_
@def $macro42()
$LICENSE()
$FHEAD()

float levelOneNodeOne(float*);
float levelTwoNodeOne(float*);
float levelThreeLeafOne(float*);

float           statusFlag = NoMistake;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * Float function declaration 
 */
{
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float levelOneNodeOne(float *variable)
{
	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return 2.0 * levelTwoNodeOne(&i);
}

float levelTwoNodeOne(float *variable)
{
	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return 2.0 * levelThreeLeafOne(&i);
}

float levelThreeLeafOne(float *variable)
{
	static float    i;

	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return 2.0 * i;
}
@def_
@def $macro43()
$LICENSE()
$FHEAD()

float dummy1(float (*) (float*), float*);
float divide4(float*);
float dummy2(float (*) (float*), float*);
float divide2(float*);

float           statusFlag = NoMistake;
float           globalInteger = 10.0;
float           i = 12.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning an Float 
 */
{
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy1(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 3.0)) )
		statusFlag++;
	return ii;
}

float divide4(float *Float)
{
	return dummy2(divide2, Float) / 2.0;
}

float dummy2(float (*func) (float*), float *Float)
{
	float           ii;

	if ( !(TGEN_FLT_EQ((ii = (*func) (Float)), 6.0)) )
		statusFlag++;
	return ii;
}

float divide2(float *Float)
{
	float           i = *Float;

	Float = &globalInteger;
	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return i / 2.0;
}
@def_
@def $macro44()
$LICENSE()
$FHEAD()

void recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 10.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	extern float    i;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(float *variable)
{
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro45()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	extern float    i;
	float           result = 0.0;

	result = recursiveFunction(&i);
	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	float           result = 0.0;
	extern float    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = recursiveFunction(&i);
		if ( !(TGEN_FLT_EQ(result, 1.0)) )
			statusFlag++;
	}
	return i;
}
@def_
@def $macro46()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, pointer to function returning
 * an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = dummy(increment, &i);
	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	float           result;
	extern float    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = dummy(function, &i);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(i);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro47()
$LICENSE()
$FHEAD()

float recursiveFunction(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, function in conditional expression, Float
 * function declaration 
 */
{
	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i);
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float recursiveFunction(float *variable)
{
	float           arg_a, arg_b;

	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = recursiveFunction(&i);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return i + 1.0;
}
@def_
@def $macro48()
$LICENSE()
$FHEAD()

float dummy(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning an Float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float dummy(float (*function) (float), float *variable)
{
	extern float    i;
	float           arg_a, arg_b;

	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = dummy(function, &i);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return function(i);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro49()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	i = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

void pollux(float *variable)
{
	i = *variable;
	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro50()
$LICENSE()
$FHEAD()

void castor(float*);
void pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0;
float           result;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	extern float    i;

/*	result = castor(&i);*/
	if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(float *variable)
{
	extern float    i;

	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
/*	if (--counter)
		result = pollux(&i);*/
}

void pollux(float *variable)
{
	extern float    i;

	i = *variable;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
/*	if (--counter)
		result = castor(&i);*/
}
@def_
@def $macro51()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 2.0, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = castor(&i);
	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	extern float    ii;
	float           result = 0.0;

	ii = *variable + 3.0;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return ii;
}

float pollux(float *variable)
{
	extern float    iii;
	float           result = 0.0;

	iii = *variable - 3.0;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return iii;
}
@def_
@def $macro52()
$LICENSE()
$FHEAD()

int castor(float (*) (float), float*);
int pollux(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, return value, pointer to function returning an
 * Float 
 */
{
	extern float    i;
	float           result = 0.0;

	result = castor(increment, &i);
	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(float (*function) (float), float *variable)
{
	extern float    ii;
	float           result = 0.0;

	ii = *variable + 8.0;
	if (--counter) {
		variable = &globalInteger;
		if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = pollux(function, &ii);
		if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return function(ii);
}

int pollux(float (*function) (float), float *variable)
{
	extern float    iii;
	float           result = 0.0;

	iii = *variable - 8.0;
	if (--counter) {
		variable = &globalInteger;
		if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = castor(function, &iii);
		if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return function(iii);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro53()
$LICENSE()
$FHEAD()

float castor(float*);
float pollux(float*);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return an Float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 5.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

float castor(float *variable)
{
	extern float    ii;
	float           arg_a, arg_b;

	ii = *variable + 3.0;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return ii + 1.0;
}

float pollux(float *variable)
{
	extern float    iii;
 	float           arg_a, arg_b;

	iii = *variable - 3.0;
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 5.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return iii + 1.0;
}
@def_
@def $macro54()
$LICENSE()
$FHEAD()

int castor(float (*) (float), float*);
int pollux(float (*) (float), float*);
float increment(float);

float           statusFlag = NoMistake;
short           counter = 10;
float           globalInteger = 10.0;
float           i = 1.0, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning an Float 
 */
{
	extern float    i;
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 12.0;
	if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(float (*function) (float), float *variable)
{
	extern float    ii;
	float           arg_a, arg_b;

	ii = *variable + 10.0;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 2.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return function(ii);
}

int pollux(float (*function) (float), float *variable)
{
	extern float    iii;
	float           arg_a, arg_b;

	iii = *variable - 10.0;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 12.0;
		if ( !(TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	variable = &globalInteger;
	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return function(iii);
}

float increment(float variable)
{
	return ++variable;
}
@def_
@def $macro55()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, no return value and legal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long *argument)
{
	extern long     i11;

	if (*argument != 1L)
		statusFlag++;
	i11 = 3;
	levelTwoNodeOne(&i11);
	i11 = 4;
	levelTwoNodeTwo(&i11);
}

void levelOneNodeTwo(long *argument)
{
	extern long     i12;

	if (*argument != 2L)
		statusFlag++;
	i12 = 5;
	levelTwoNodeThree(&i12);
	i12 = 6;
	levelTwoNodeFour(&i12);
}

void levelTwoNodeOne(long *argument)
{
	extern long     i21;

	if (*argument != 3L)
		statusFlag++;
	i21 = 7;
	levelThreeLeafOne(&i21);
	i21 = 8;
	levelThreeLeafTwo(&i21);
}

void levelTwoNodeTwo(long *argument)
{
	extern long     i22;

	if (*argument != 4L)
		statusFlag++;
	i22 = 9;
	levelThreeLeafThree(&i22);
	i22 = 10;
	levelThreeLeafFour(&i22);
}

void levelTwoNodeThree(long *argument)
{
	extern long     i23;

	if (*argument != 5L)
		statusFlag++;
	i23 = 11;
	levelThreeLeafFive(&i23);
	i23 = 12;
	levelThreeLeafSix(&i23);
}

void levelTwoNodeFour(long *argument)
{
	extern long     i24;

	if (*argument != 6L)
		statusFlag++;
	i24 = 13;
	levelThreeLeafSeven(&i24);
	i24 = 14;
	levelThreeLeafEight(&i24);
}

void levelThreeLeafOne(long *argument)
{
	if (*argument != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long *argument)
{
	if (*argument != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long *argument)
{
	if (*argument != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long *argument)
{
	if (*argument != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long *argument)
{
	if (*argument != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long *argument)
{
	if (*argument != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long *argument)
{
	if (*argument != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long *argument)
{
	if (*argument != 14L)
		statusFlag++;
}
@def_
@def $macro56()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i, i11, i12, i21, i22, i23, i24;
long            result;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, no return value and illegal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long *argument)
{
	extern long     i11;

	if (*argument != 1L)
		statusFlag++;
	i11 = 3;
	levelTwoNodeOne(&i11);
	i11 = 4;
	levelTwoNodeTwo(&i11);
}

void levelOneNodeTwo(long *argument)
{
	extern long     i12;

	if (*argument != 2L)
		statusFlag++;
	i12 = 5;
	levelTwoNodeThree(&i12);
	i12 = 6;
	levelTwoNodeFour(&i12);
}

void levelTwoNodeOne(long *argument)
{
	extern long     i21;

	if (*argument != 3L)
		statusFlag++;
	i21 = 7;
	levelThreeLeafOne(&i21);
	i21 = 8;
	levelThreeLeafTwo(&i21);
}

void levelTwoNodeTwo(long *argument)
{
	extern long     i22;

	if (*argument != 4L)
		statusFlag++;
	i22 = 9;
	levelThreeLeafThree(&i22);
	i22 = 10;
	levelThreeLeafFour(&i22);
}

void levelTwoNodeThree(long *argument)
{
	extern long     i23;

	if (*argument != 5L)
		statusFlag++;
	i23 = 11;
	levelThreeLeafFive(&i23);
	i23 = 12;
	levelThreeLeafSix(&i23);
}

void levelTwoNodeFour(long *argument)
{
	extern long     i24;

	if (*argument != 6L)
		statusFlag++;
	i24 = 13;
	levelThreeLeafSeven(&i24);
	i24 = 14;
	levelThreeLeafEight(&i24);
}

void levelThreeLeafOne(long *argument)
{
	if (*argument != 7L)
		statusFlag++;
	return;
}

void levelThreeLeafTwo(long *argument)
{
	if (*argument != 8L)
		statusFlag++;
	return;
}

void levelThreeLeafThree(long *argument)
{
	if (*argument != 9L)
		statusFlag++;
	return;
}

void levelThreeLeafFour(long *argument)
{
	if (*argument != 10L)
		statusFlag++;
	return;
}

void levelThreeLeafFive(long *argument)
{
	if (*argument != 11L)
		statusFlag++;
	return;
}

void levelThreeLeafSix(long *argument)
{
	if (*argument != 12L)
		statusFlag++;
	return;
}

void levelThreeLeafSeven(long *argument)
{
	if (*argument != 13L)
		statusFlag++;
	return;
}

void levelThreeLeafEight(long *argument)
{
	if (*argument != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro57()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelOneNodeTwo(long*);
long levelTwoNodeOne(long*);
long levelTwoNodeTwo(long*);
long levelTwoNodeThree(long*);
long levelTwoNodeFour(long*);
long levelThreeLeafOne(long*);
long levelThreeLeafTwo(long*);
long levelThreeLeafThree(long*);
long levelThreeLeafFour(long*);
long levelThreeLeafFive(long*);
long levelThreeLeafSix(long*);
long levelThreeLeafSeven(long*);
long levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, return value and legal, Long function declaration 
 */
{
	extern long     i;
	long            result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *argument)
{
	long            result = 0;
	extern long     i11;

	i11 = 3;
	result = levelTwoNodeOne(&i11);
	if (result != 3L)
		statusFlag++;
	i11 = 4;
	result = levelTwoNodeTwo(&i11);
	if (result != 4L)
		statusFlag++;
	return *argument;
}

long levelOneNodeTwo(long *argument)
{
	long            result = 0;
	extern long     i12;

	i12 = 5;
	result = levelTwoNodeThree(&i12);
	if (result != 5L)
		statusFlag++;
	i12 = 6;
	result = levelTwoNodeFour(&i12);
	if (result != 6L)
		statusFlag++;
	return *argument;
}

long levelTwoNodeOne(long *argument)
{
	long            result = 0;
	extern long     i21;

	i21 = 7;
	result = levelThreeLeafOne(&i21);
	if (result != 7L)
		statusFlag++;
	i21 = 8;
	result = levelThreeLeafTwo(&i21);
	if (result != 8L)
		statusFlag++;
	return *argument;
}

long levelTwoNodeTwo(long *argument)
{
	long            result = 0;
	extern long     i22;

	i22 = 9;
	result = levelThreeLeafThree(&i22);
	if (result != 9L)
		statusFlag++;
	i22 = 10;
	result = levelThreeLeafFour(&i22);
	if (result != 10L)
		statusFlag++;
	return *argument;
}

long levelTwoNodeThree(long *argument)
{
	long            result = 0;
	extern long     i23;

	i23 = 11;
	result = levelThreeLeafFive(&i23);
	if (result != 11L)
		statusFlag++;
	i23 = 12;
	result = levelThreeLeafSix(&i23);
	if (result != 12L)
		statusFlag++;
	return *argument;
}

long levelTwoNodeFour(long *argument)
{
	long            result = 0;
	extern long     i24;

	i24 = 13;
	result = levelThreeLeafSeven(&i24);
	if (result != 13L)
		statusFlag++;
	i24 = 14;
	result = levelThreeLeafEight(&i24);
	if (result != 14L)
		statusFlag++;
	return *argument;
}

long levelThreeLeafOne(long *argument)
{
	return *argument;
}

long levelThreeLeafTwo(long *argument)
{
	return *argument;
}

long levelThreeLeafThree(long *argument)
{
	return *argument;
}

long levelThreeLeafFour(long *argument)
{
	return *argument;
}

long levelThreeLeafFive(long *argument)
{
	return *argument;
}

long levelThreeLeafSix(long *argument)
{
	return *argument;
}

long levelThreeLeafSeven(long *argument)
{
	return *argument;
}

long levelThreeLeafEight(long *argument)
{
	return *argument;
}
@def_
@def $macro58()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            i = 12;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, return value, legal pointer to function returning
 * a long 
 */
{
	extern long     i;
	long            result = 0;

	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return i;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return i;
}

long divide2(long *Long)
{
	return *Long / 2;
}
@def_
@def $macro59()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelTwoNodeOne(long*);
long levelThreeLeafOne(long*);

short           statusFlag = NoMistake;
long            i = 1, ii, iii;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	extern long     i;

	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *variable)
{
	extern long     ii;

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

long levelTwoNodeOne(long *variable)
{
	extern long     iii;

	iii = 2 * (*variable);
	return 2 * levelThreeLeafOne(&iii);
}

long levelThreeLeafOne(long *variable)
{
	return 2 * (*variable);
}
@def_
@def $macro60()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            i = 12;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return ii;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return ii;
}

long divide2(long *Long)
{
	return *Long / 2;
}
@def_
@def $macro61()
$LICENSE()
$HEAD()

void recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, no return value, legal 
 */
{
	extern long     i;

	i = 1;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long *variable)
{
	if (*variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro62()
$LICENSE()
$HEAD()

void recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii;
long            result;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, no return value, illegal 
 */
{
	recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long *variable)
{
	if ((ii = *variable) != i)
		statusFlag++;
	if (--counter)
		recursiveFunction(&ii);
	return;
}
@def_
@def $macro63()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, legal, Long function declaration 
 */
{
	extern long     i;
	long            result = 0;

	result = recursiveFunction(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	extern long     i;
	long            result = 0;

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2L)
			statusFlag++;
	}
	return i + 1;
}
@def_
@def $macro64()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            result = 0;

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	long            result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2L)
			statusFlag++;
	}
	return function(*variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro65()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{
	extern long     i;

	if (!(recursiveFunction(&i) - i == 1L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1L))
			statusFlag++;
	return (*variable) + 1;
}
@def_
@def $macro66()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, in conditional expression, pointer to function returning
 * a long 
 */
{
	if (!(dummy(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	if (--counter)
		if (!(dummy(function, variable) == 2L))
			statusFlag++;
	return function(*variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro67()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, no return value, legal 
 */
{
	extern long     i;

	i = 1;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	extern long     ii;

	ii = *variable;
	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		ii++;
		pollux(&ii);
	}
}

void pollux(long *variable)
{
	extern long     iii;

	iii = *variable;
	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--iii;
		castor(&iii);
	}
}
@def_
@def $macro68()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            zero = 0;	/* modified by m2 on Apr. 23, 1984 */
long           *i = &zero;	/* modified by m2 on Apr. 23, 1984 */
long            result;

int main(void)
/*
 * test class: extern variable address instance  : gemini, no return value, illegal 
 */
{
	castor(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	if (*variable != 0L)
		statusFlag++;
	if (--counter)
		pollux(variable);
}

void pollux(long *variable)
{
	if (*variable != 0L)
		statusFlag++;
	if (--counter)
		castor(variable);
}
@def_
@def $macro69()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            result = 0;

	result = castor(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long *variable)
{
	long            result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5L)
			statusFlag++;
	}
	return *variable + 1;
}

long pollux(long *variable)
{
	long            result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2L)
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro70()
$LICENSE()
$HEAD()

long castor(long (*) (long), long*);
long pollux(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, pointer to function returning a long 
 */
{
	extern long     i;
	long            result = 0;

	result = castor(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long *variable)
{
	extern long     ii;
	long            result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10L)
			statusFlag++;
	}
	return function(*variable);
}

long pollux(long (*function) (long), long *variable)
{
	extern long     iii;
	long            result = 0, castor();

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2L)
			statusFlag++;
	}
	return function(*variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro71()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	extern long     i;

	if (!(castor(&i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long *variable)
{
	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5L))
			statusFlag++;
	}
	return *variable + 1;
}

long pollux(long *variable)
{
	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2L))
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro72()
$LICENSE()
$HEAD()

long castor(long (*) (long), long*);
long pollux(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{
	if (!(castor(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long *variable)
{
	extern long     ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12L))
			statusFlag++;
	}
	return function(*variable);
}

long pollux(long (*function) (long), long *variable)
{
	extern long     iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2L))
			statusFlag++;
	}
	return function(*variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro73()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	extern long     i;

	i = 1;
	levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long *variable)
{
	(*variable) = 3;
	levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 4;
	levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelOneNodeTwo(long *variable)
{
	(*variable) = 5;
	levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 6;
	levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeOne(long *variable)
{
	(*variable) = 7;
	levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 8;
	levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeTwo(long *variable)
{
	(*variable) = 9;
	levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 10;
	levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeThree(long *variable)
{
	(*variable) = 11;
	levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 12;
	levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeFour(long *variable)
{
	(*variable) = 13;
	levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 14;
	levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelThreeLeafOne(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafTwo(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafThree(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafFour(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafFive(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafSix(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafSeven(long *variable)
{
	(*variable) = 0;
}

void levelThreeLeafEight(long *variable)
{
	(*variable) = 0;
}
@def_
@def $macro74()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i;
long            result;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	i = 1;
	levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long *variable)
{
	if (*variable != 1L)
		statusFlag++;
	*variable = 3;
	levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 4;
	levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelOneNodeTwo(long *variable)
{
	if (*variable != 2L)
		statusFlag++;
	*variable = 5;
	levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 6;
	levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeOne(long *variable)
{
	if (*variable != 3L)
		statusFlag++;
	*variable = 7;
	levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 8;
	levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeTwo(long *variable)
{
	if (*variable != 4L)
		statusFlag++;
	*variable = 9;
	levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 10;
	levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeThree(long *variable)
{
	if (*variable != 5L)
		statusFlag++;
	*variable = 11;
	levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 12;
	levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelTwoNodeFour(long *variable)
{
	if (*variable != 6L)
		statusFlag++;
	*variable = 13;
	levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 14;
	levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

void levelThreeLeafOne(long *variable)
{
	*variable = 0;
}

void levelThreeLeafTwo(long *variable)
{
	*variable = 0;
}

void levelThreeLeafThree(long *variable)
{
	*variable = 0;
}

void levelThreeLeafFour(long *variable)
{
	*variable = 0;
}

void levelThreeLeafFive(long *variable)
{
	*variable = 0;
}

void levelThreeLeafSix(long *variable)
{
	*variable = 0;
}

void levelThreeLeafSeven(long *variable)
{
	*variable = 0;
}

void levelThreeLeafEight(long *variable)
{
	*variable = 0;
}
@def_
@def $macro75()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelOneNodeTwo(long*);
long levelTwoNodeOne(long*);
long levelTwoNodeTwo(long*);
long levelTwoNodeThree(long*);
long levelTwoNodeFour(long*);
long levelThreeLeafOne(long*);
long levelThreeLeafTwo(long*);
long levelThreeLeafThree(long*);
long levelThreeLeafFour(long*);
long levelThreeLeafFive(long*);
long levelThreeLeafSix(long*);
long levelThreeLeafSeven(long*);
long levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, return value and legal, Long
 * function declaration 
 */
{
	long            result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1L || i != 0L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L || *variable != 0L)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L || *variable != 0L)
		statusFlag++;
	return storage;
}

long levelOneNodeTwo(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L || *variable != 0L)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long levelTwoNodeOne(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L || *variable != 0L)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L || *variable != 0L)
		statusFlag++;
	return storage;
}

long levelTwoNodeTwo(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L || *variable != 0L)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L || *variable != 0L)
		statusFlag++;
	return storage;
}

long levelTwoNodeThree(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L || *variable != 0L)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L || *variable != 0L)
		statusFlag++;
	return storage;
}

long levelTwoNodeFour(long *variable)
{
	long            storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L || *variable != 0L)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L || *variable != 0L)
		statusFlag++;
	return storage;
}

long levelThreeLeafOne(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafTwo(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafThree(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafFour(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafFive(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafSix(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafSeven(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}

long levelThreeLeafEight(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return i;
}
@def_
@def $macro76()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            i = 12;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning a long 
 */
{
	extern long     i;
	long            result = 0;

	result = dummy1(divide4, &i);
	if (result != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 3L || *Long != 0L)
		statusFlag++;
	return i;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 6L || *Long != 0L)
		statusFlag++;
	return i;
}

long divide2(long *Long)
{
	long            i = *Long;

	(*Long) = 0;
	return i / 2;
}
@def_
@def $macro77()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelTwoNodeOne(long*);
long levelThreeLeafOne(long*);

short           statusFlag = NoMistake;
long            i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	extern long     i;

	if (!(levelOneNodeOne(&i) == 32L) || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *variable)
{
	(*variable) *= 2;
	return 2 * levelTwoNodeOne(variable);
}

long levelTwoNodeOne(long *variable)
{
	(*variable) *= 2;
	return 2 * levelThreeLeafOne(variable);
}

long levelThreeLeafOne(long *variable)
{
	long            i = *variable;

	(*variable) = 0;
	return 2 * i;
}
@def_
@def $macro78()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            i = 12;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning a long 
 */
{
	if (dummy1(divide4, &i) != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L || *Long != 0L)
		statusFlag++;
	return ii;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L || *Long != 0L)
		statusFlag++;
	return ii;
}

long divide2(long *Long)
{
	long            i = *Long;

	(*Long) = 0;
	return i / 2;
}
@def_
@def $macro79()
$LICENSE()
$HEAD()

void recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 10;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	extern long     i;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long *variable)
{
	if (*variable != counter)
		statusFlag++;
	(*variable)--;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro80()
$LICENSE()
$HEAD()

void recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 10;
long            result;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	extern long     i;

	recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long *variable)
{
	if (--counter) {
		if (counter != --(*variable))
			statusFlag++;
		recursiveFunction(variable);
	}
	return;
}
@def_
@def $macro81()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	extern long     i;
	long            result = 0;

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	long            result = 0;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro82()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	extern long     i;
	long            result = 0;

	result = dummy(increment, &i);
	if (result - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	long            result;
	extern long     i;

	i = *variable;
	if (--counter) {
		result = dummy(function, &i);
		if (result - i != 2L)
			statusFlag++;
	}
	return function((*variable)--);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro83()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Long function declaration 
 */
{
	if (recursiveFunction(&i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	extern long     i;

	i = *variable;
	if (--counter)
		if (recursiveFunction(&i) - i != 2L)
			statusFlag++;
	return (*variable)-- + 1;
}
@def_
@def $macro84()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning a long 
 */
{
	if (dummy(increment, &i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	i = *variable;
	if (--counter)
		if (dummy(function, &i) - i != 2L)
			statusFlag++;
	return function((*variable)--);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro85()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	extern long     i;

	castor(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	extern long     i;

	i = *variable;
	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if (i != 3L)
			statusFlag++;
	}
	(*variable) = 0;
}

void pollux(long *variable)
{
	extern long     i;

	i = *variable;
	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	(*variable) = 3;
}
@def_
@def $macro86()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1;
long            result;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	castor(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	i = *variable;
	if (--counter) {
		pollux(&i);
		if (i != 2L)
			statusFlag++;
	}
	*variable = 0;
}

void pollux(long *variable)
{
	i = *variable;
	if (--counter) {
		castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	*variable = 2;
}
@def_
@def $macro87()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	long            result = 0;

	i = 1;
	result = castor(&i);
	if (result != 2L || i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long *variable)
{
	long            result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2L)
			statusFlag++;
	}
	return ++(*variable);
}

long pollux(long *variable)
{
	long            result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return --(*variable) + 2;
}
@def_
@def $macro88()
$LICENSE()
$HEAD()

long castor(long (*) (long*), long*);
long pollux(long (*) (long*), long*);
long increment(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * a long 
 */
{
	long            result = 0;

	result = castor(increment, &i);
	if (result != i + 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long*), long *variable)
{
	long            result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != ii + 2L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long*), long *variable)
{
	long            result = 0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != iii + 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long *variable)
{
	long            i = *variable;

	(*variable)--;
	return ++i;
}
@def_
@def $macro89()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return a long 
 */
{
	extern long     i;

	i = 1;
	if (castor(&i) - i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long *variable)
{
	extern long     ii;
	long            pollux();

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0L)
			statusFlag++;
	}
	return ++(*variable);
}

long pollux(long *variable)
{
	extern long     iii;

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0L)
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro90()
$LICENSE()
$HEAD()

long castor(long (*) (long*), long*);
long pollux(long (*) (long*), long*);
long increment(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	if (castor(increment, &i) != i + 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long*), long *variable)
{
	ii = *variable + 10;
	if (--counter) {
		if (pollux(function, &ii) != ii + 2L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long*), long *variable)
{
	iii = *variable - 10;
	if (--counter) {
		if (castor(function, &iii) != iii + 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long *variable)
{
	return --(*variable) + 2;
}
@def_
@def $macro91()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

void levelOneNodeOne(long *variable)
{
	*variable = 3;
	levelTwoNodeOne(variable);
	*variable = 4;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(long *variable)
{
	*variable = 5;
	levelTwoNodeThree(variable);
	*variable = 6;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(long *variable)
{
	*variable = 7;
	levelThreeLeafOne(variable);
	*variable = 8;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(long *variable)
{
	*variable = 9;
	levelThreeLeafThree(variable);
	*variable = 10;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(long *variable)
{
	*variable = 11;
	levelThreeLeafFive(variable);
	*variable = 12;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(long *variable)
{
	*variable = 13;
	levelThreeLeafSeven(variable);
	*variable = 14;
	levelThreeLeafEight(variable);
}

void levelThreeLeafOne(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;

}

void levelThreeLeafTwo(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafThree(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafFour(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafFive(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafSix(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafSeven(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafEight(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro92()
$LICENSE()
$HEAD()

void levelOneNodeOne(long*);
void levelOneNodeTwo(long*);
void levelTwoNodeOne(long*);
void levelTwoNodeTwo(long*);
void levelTwoNodeThree(long*);
void levelTwoNodeFour(long*);
void levelThreeLeafOne(long*);
void levelThreeLeafTwo(long*);
void levelThreeLeafThree(long*);
void levelThreeLeafFour(long*);
void levelThreeLeafFive(long*);
void levelThreeLeafSix(long*);
void levelThreeLeafSeven(long*);
void levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            i;
long            result;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long *variable)
{
	*variable = 3;
	levelTwoNodeOne(variable);
	*variable = 4;
	levelTwoNodeTwo(variable);
}

void levelOneNodeTwo(long *variable)
{
	*variable = 5;
	levelTwoNodeThree(variable);
	*variable = 6;
	levelTwoNodeFour(variable);
}

void levelTwoNodeOne(long *variable)
{
	*variable = 7;
	levelThreeLeafOne(variable);
	*variable = 8;
	levelThreeLeafTwo(variable);
}

void levelTwoNodeTwo(long *variable)
{
	*variable = 9;
	levelThreeLeafThree(variable);
	*variable = 10;
	levelThreeLeafFour(variable);
}

void levelTwoNodeThree(long *variable)
{
	*variable = 11;
	levelThreeLeafFive(variable);
	*variable = 12;
	levelThreeLeafSix(variable);
}

void levelTwoNodeFour(long *variable)
{
	*variable = 13;
	levelThreeLeafSeven(variable);
	*variable = 14;
	levelThreeLeafEight(variable);
}
void levelThreeLeafOne(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafTwo(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafThree(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafFour(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafFive(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafSix(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafSeven(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

void levelThreeLeafEight(long *variable)
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro93()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelOneNodeTwo(long*);
long levelTwoNodeOne(long*);
long levelTwoNodeTwo(long*);
long levelTwoNodeThree(long*);
long levelTwoNodeFour(long*);
long levelThreeLeafOne(long*);
long levelThreeLeafTwo(long*);
long levelThreeLeafThree(long*);
long levelThreeLeafFour(long*);
long levelThreeLeafFive(long*);
long levelThreeLeafSix(long*);
long levelThreeLeafSeven(long*);
long levelThreeLeafEight(long*);

short           statusFlag = NoMistake;
long            globalLong = 10;
long            i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, return value and legal, Long
 * function declaration 
 */
{
	long            result = 0;

	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L)
		statusFlag++;
	return storage;
}

long levelOneNodeTwo(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L)
		statusFlag++;
	return storage;
}

long levelTwoNodeOne(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L)
		statusFlag++;
	return storage;
}

long levelTwoNodeTwo(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L)
		statusFlag++;
	return storage;
}

long levelTwoNodeThree(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L)
		statusFlag++;
	return storage;
}

long levelTwoNodeFour(long *variable)
{
	long            storage = *variable, result = 0;

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L)
		statusFlag++;
	return storage;
}

long levelThreeLeafOne(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafTwo(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafThree(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafFour(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafFive(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafSix(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafSeven(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}

long levelThreeLeafEight(long *variable)
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return i;
}
@def_
@def $macro94()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            globalLong = 10;
long            i = 12;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	long            result = 0;

	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return i;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return i;
}

long divide2(long *Long)
{
	long            i = *Long;

	(*Long) = 0;
	return i / 2;
}
@def_
@def $macro95()
$LICENSE()
$HEAD()

long levelOneNodeOne(long*);
long levelTwoNodeOne(long*);
long levelThreeLeafOne(long*);

short           statusFlag = NoMistake;
long            globalLong = 10;
long            i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * Long function declaration 
 */
{
	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long *variable)
{
	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return 2 * levelTwoNodeOne(&i);
}

long levelTwoNodeOne(long *variable)
{
	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return 2 * levelThreeLeafOne(&i);
}

long levelThreeLeafOne(long *variable)
{
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return 2 * i;
}
@def_
@def $macro96()
$LICENSE()
$HEAD()

long dummy1(long (*) (long*), long*);
long divide4(long*);
long dummy2(long (*) (long*), long*);
long divide2(long*);

short           statusFlag = NoMistake;
long            globalLong = 10;
long            i = 12;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning a long 
 */
{
	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return ii;
}

long divide4(long *Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long*), long *Long)
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return ii;
}

long divide2(long *Long)
{
	long            i = *Long;

	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return i / 2;
}
@def_
@def $macro97()
$LICENSE()
$HEAD()

void recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 10;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	extern long     i;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long *variable)
{
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro98()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	extern long     i;
	long            result = 0;

	result = recursiveFunction(&i);
	if (result != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	long            result = 0;
	extern long     i;

	i = *variable;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1L)
			statusFlag++;
	}
	return i;
}
@def_
@def $macro99()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, pointer to function returning
 * a long 
 */
{
	extern long     i;
	long            result = 0;

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	long            result;
	extern long     i;

	i = *variable;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2L)
			statusFlag++;
	}
	return function(i);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro100()
$LICENSE()
$HEAD()

long recursiveFunction(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	if (recursiveFunction(&i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long *variable)
{
	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2L)
			statusFlag++;
	return i + 1;
}
@def_
@def $macro101()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	extern long     i;

	if (dummy(increment, &i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long *variable)
{
	extern long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2L)
			statusFlag++;
	return function(i);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro102()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	i = *variable;
	if (*variable != 1L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

void pollux(long *variable)
{
	i = *variable;
	if (*variable != 2L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro103()
$LICENSE()
$HEAD()

void castor(long*);
void pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1;
long            result;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	extern long     i;

	castor(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long *variable)
{
	extern long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		pollux(&i);
}

void pollux(long *variable)
{
	extern long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		castor(&i);
}
@def_
@def $macro104()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	extern long     i;
	long            result = 0;

	result = castor(&i);
	if (result != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long *variable)
{
	extern long     ii;
	long            result = 0;

	ii = *variable + 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2L)
			statusFlag++;
	}
	return ii;
}

long pollux(long *variable)
{
	extern long     iii;
	long            result = 0;

	iii = *variable - 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5L)
			statusFlag++;
	}
	return iii;
}
@def_
@def $macro105()
$LICENSE()
$HEAD()

long castor(long (*) (long), long*);
long pollux(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, return value, pointer to function returning a long 
 */
{
	extern long     i;
	long            result = 0;

	result = castor(increment, &i);
	if (result != 10L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long *variable)
{
	extern long     ii;
	long            result = 0;

	ii = *variable + 8;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2L)
			statusFlag++;
	}
	return function(ii);
}

long pollux(long (*function) (long), long *variable)
{
	extern long     iii;
	long            result = 0;

	iii = *variable - 8;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10L)
			statusFlag++;
	}
	return function(iii);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro106()
$LICENSE()
$HEAD()

long castor(long*);
long pollux(long*);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	extern long     i;

	if (castor(&i) != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long castor(long *variable)
{
	extern long     ii;

	ii = *variable + 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2L)
			statusFlag++;
	}
	return ii + 1;
}

long pollux(long *variable)
{
	extern long     iii;

	iii = *variable - 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5L)
			statusFlag++;
	}
	return iii + 1;
}
@def_
@def $macro107()
$LICENSE()
$HEAD()

long castor(long (*) (long), long*);
long pollux(long (*) (long), long*);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	extern long     i;

	if (!(castor(increment, &i) == 12L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long *variable)
{
	extern long     ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 2L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return function(ii);
}

long pollux(long (*function) (long), long *variable)
{
	extern long     iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 12L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return function(iii);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro108()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, no return value and legal 
 */
{
	long            i = 0;

	levelOneNodeOne(++i);
	levelOneNodeTwo(++i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne(variable += 2);
	levelTwoNodeTwo(++variable);
}

void levelOneNodeTwo(long variable)
{
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree(variable += 3);
	levelTwoNodeFour(++variable);
}

void levelTwoNodeOne(long variable)
{
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne(variable += 4);
	levelThreeLeafTwo(++variable);
}

void levelTwoNodeTwo(long variable)
{
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree(variable += 5);
	levelThreeLeafFour(++variable);
}

void levelTwoNodeThree(long variable)
{
	if (variable != 5L)
		statusFlag++;
	levelThreeLeafFive(variable += 6);
	levelThreeLeafSix(++variable);
}

void levelTwoNodeFour(long variable)
{
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable += 7);
	levelThreeLeafEight(++variable);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro109()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            result;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, no return value and illegal 
 */
{
	long            i = 0;

	levelOneNodeOne(++i);
	levelOneNodeTwo(++i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne(variable += 2);
	levelTwoNodeTwo(++variable);
}

void levelOneNodeTwo(long variable)
{
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree(variable += 3);
	levelTwoNodeFour(++variable);
}

void levelTwoNodeOne(long variable)
{
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne(variable += 4);
	levelThreeLeafTwo(++variable);
}

void levelTwoNodeTwo(long variable)
{
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree(variable += 5);
	levelThreeLeafFour(++variable);
}

void levelTwoNodeThree(long variable)
{
	if (variable != 5L)
		statusFlag++;
	levelThreeLeafFive(variable += 6);
	levelThreeLeafSix(++variable);
}

void levelTwoNodeFour(long variable)
{
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable += 7);
	levelThreeLeafEight(++variable);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
	return;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
	return;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
	return;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
	return;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
	return;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
	return;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
	return;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro110()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	long            i = 3;

	i = dummy1(divide4, i *= 4);
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return i;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return (i);
}

long divide2(long Long)
{
	return (Long / 2);
}
@def_
@def $macro111()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, used in conditional expression,
 * Long function declaration 
 */
{
	long            i = 0;

	if (!(levelOneNodeOne(++i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

long levelTwoNodeOne(long variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

long levelThreeLeafOne(long variable)
{
	return 2 * variable;
}
@def_
@def $macro112()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : linear tree structure, in conditional expression, pointer
 * to function returning a long 
 */
{
	long            i = 3;

	if (dummy1(divide4, 4 * i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long * 2 / 2)) != 3L)
		statusFlag++;
	return ii;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            ii;

	if ((ii = (*func) (Long * 2 / 2)) != 6L)
		statusFlag++;
	return ii;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro113()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, no return value, legal 
 */
{
	long            i = 0;

	recursiveFunction(++i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable * 3 / 3);
}
@def_
@def $macro114()
$LICENSE()
$HEAD()

void recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, no return value, illegal 
 */
{
	long            i = 1;

	recursiveFunction(i % 10);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable % 100);
	return;
}
@def_
@def $macro115()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	long            i = 0;

	i = recursiveFunction(i + 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	long            result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2);
		if (result != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro116()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, pointer to function returning
 * a long 
 */
{
	long            i = 0;

	i = dummy(increment, ++i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            result;

	if (--counter) {
		result = dummy(function, 1 * variable);
		if (result != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro117()
$LICENSE()
$HEAD()

long recursiveFunction(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	long            i = 0;

	if (recursiveFunction(i + 1) - i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable)
{
	if (--counter)
		if (recursiveFunction(variable + 1) - variable != 0L)
			statusFlag++;
	return --variable;
}
@def_
@def $macro118()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            i = 1;

	if (!(dummy(increment, 2 * i / 2) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	if (--counter)
		if (!(dummy(function, 2 * variable / 2) == 2L))
			statusFlag++;
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro119()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, no return value, legal 
 */
{
	long            i = 1;

	castor(++i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux(--variable);
	}
}

void pollux(long variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor(++variable);
	}
}
@def_
@def $macro120()
$LICENSE()
$HEAD()

void castor(long);
void pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, no return value, illegal 
 */
{
	long            i = 0;

	castor(++i);
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable)
{
	long            ii;

	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		pollux(--variable);
		if (ii == 0L)
			ii++;
	}
}

void pollux(long variable)
{
	long            iii;

	if (variable != 0L)
		statusFlag++;
	if (--counter) {
		castor(++variable);
		if (iii == 0L)
			iii++;
	}
}
@def_
@def $macro121()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, legal, function declared to return a
 * long 
 */
{
	long            i = 0;

	i = castor(++i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	long            ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	long            iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro122()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i = 0;

	i = castor(increment, ++i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            ii = 0;
	if (--counter) {
		ii = pollux(function, variable + 8);
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            iii = 0;
	if (--counter) {
		iii = castor(function, variable - 8);
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro123()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	long            i = 0;

	if (!(castor(++i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	if (--counter) {
		if (!(pollux(variable + 3) == 5L))
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	if (--counter) {
		if (!(castor(variable - 3) == 2L))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro124()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            i = 100;

	if (!(castor(increment, i - 99) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	if (--counter) {
		if (!(pollux(function, variable + 10) == 12L))
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	if (--counter) {
		if (!(castor(function, variable - 10) == 2L))
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro125()
$LICENSE()
$HEAD()

void levelOneNodeOne(unsigned);
void levelOneNodeTwo(unsigned);
void levelTwoNodeOne(unsigned);
void levelTwoNodeTwo(unsigned);
void levelTwoNodeThree(unsigned);
void levelTwoNodeFour(unsigned);
void levelThreeLeafOne(unsigned);
void levelThreeLeafTwo(unsigned);
void levelThreeLeafThree(unsigned);
void levelThreeLeafFour(unsigned);
void levelThreeLeafFive(unsigned);
void levelThreeLeafSix(unsigned);
void levelThreeLeafSeven(unsigned);
void levelThreeLeafEight(unsigned);

short           statusFlag = NoMistake;
long            result;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, no return value and illegal 
 */
{
	unsigned        i = 0;

	levelOneNodeOne(++i);
	levelOneNodeTwo(++i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(unsigned variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne(variable += 2);
	levelTwoNodeTwo(++variable);
}

void levelOneNodeTwo(unsigned variable)
{
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree(variable += 3);
	levelTwoNodeFour(++variable);
}

void levelTwoNodeOne(unsigned variable)
{
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne(variable += 4);
	levelThreeLeafTwo(++variable);
}

void levelTwoNodeTwo(unsigned variable)
{
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree(variable += 5);
	levelThreeLeafFour(++variable);
}

void levelTwoNodeThree(unsigned variable)
{
	if (variable != 5L)
		statusFlag++;
	levelThreeLeafFive(variable += 6);
	levelThreeLeafSix(++variable);
}

void levelTwoNodeFour(unsigned variable)
{
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable += 7);
	levelThreeLeafEight(++variable);
}

void levelThreeLeafOne(unsigned variable)
{
	if (variable != 7L)
		statusFlag++;
	return;
}

void levelThreeLeafTwo(unsigned variable)
{
	if (variable != 8L)
		statusFlag++;
	return;
}

void levelThreeLeafThree(unsigned variable)
{
	if (variable != 9L)
		statusFlag++;
	return;
}

void levelThreeLeafFour(unsigned variable)
{
	if (variable != 10L)
		statusFlag++;
	return;
}

void levelThreeLeafFive(unsigned variable)
{
	if (variable != 11L)
		statusFlag++;
	return;
}

void levelThreeLeafSix(unsigned variable)
{
	if (variable != 12L)
		statusFlag++;
	return;
}

void levelThreeLeafSeven(unsigned variable)
{
	if (variable != 13L)
		statusFlag++;
	return;
}

void levelThreeLeafEight(unsigned variable)
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro126()
$LICENSE()
$HEAD()

long dummy1(unsigned (*) (unsigned), unsigned);
unsigned divide4(long);
long dummy2(long (*) (long), unsigned);
long divide2(long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	unsigned        i = 3;

	i = dummy1(divide4, i *= 4);
	if (i != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(unsigned (*func) (unsigned), unsigned Long)
{
	long            i = (long) Long;

	i = (*func) (i % 100);
	if (i != 3L)
		statusFlag++;
	return i;
}

unsigned divide4(long Long)
{
	return dummy2(divide2, (unsigned) Long) / 2;
}

long dummy2(long (*func) (long), unsigned Long)
{
	long            i;

	i = (*func) ((long) Long);
	if (i != 6L)
		statusFlag++;
	return i;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro127()
$LICENSE()
$HEAD()

long levelOneNodeOne(unsigned);
long levelTwoNodeOne(unsigned);
long levelThreeLeafOne(unsigned);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, used in conditional expression,
 * Long function declaration 
 */
{
	unsigned        i = 0;

	if (!(levelOneNodeOne(++i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(unsigned variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

long levelTwoNodeOne(unsigned variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

long levelThreeLeafOne(unsigned variable)
{
	return 2 * variable;
}
@def_
@def $macro128()
$LICENSE()
$HEAD()

long dummy1(long (*) (unsigned), unsigned);
long divide4(unsigned);
long dummy2(long (*) (unsigned), unsigned);
long divide2(unsigned);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, in conditional expression, pointer
 * to function returning a long 
 */
{
	unsigned        i = 3;

	if (dummy1(divide4, 4 * i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (unsigned), unsigned Long)
{
	long            ii;

	if ((ii = (*func) (Long * 2 / 2)) != 3L)
		statusFlag++;
	return ii;
}

long divide4(unsigned Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (unsigned), unsigned Long)
{
	long            ii;

	if ((ii = (*func) (Long * 2 / 2)) != 6L)
		statusFlag++;
	return ii;
}

long divide2(unsigned Long)
{
	return Long / 2;
}
@def_
@def $macro129()
$LICENSE()
$HEAD()

void recursiveFunction(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, no return value, illegal 
 */
{
	unsigned        i = 1;

	recursiveFunction(i % 10);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(unsigned variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable % 100);
	return;
}
@def_
@def $macro130()
$LICENSE()
$HEAD()

long recursiveFunction(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	unsigned        i = 0;

	i = recursiveFunction(i + 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(unsigned variable)
{
	long            result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2);
		if (result != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro131()
$LICENSE()
$HEAD()

long dummy(unsigned (*) (unsigned), unsigned);
unsigned increment(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	unsigned        i = 0;

	i = dummy(increment, ++i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(unsigned (*function) (unsigned), unsigned variable)
{
	long            result;

	if (--counter) {
		result = dummy(function, 1 * variable);
		if (result != 2L)
			statusFlag++;
	}
	return function(variable);
}

unsigned increment(unsigned variable)
{
	return ++variable;
}
@def_
@def $macro132()
$LICENSE()
$HEAD()

long recursiveFunction(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	unsigned        i = 0;

	if (recursiveFunction(i + 1) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(unsigned variable)
{
	if (--counter)
		if (recursiveFunction(variable + 1) - variable != 2L)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro133()
$LICENSE()
$HEAD()

long dummy(long (*) (char), long);
long increment(char);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	char            i = 1;

	if (!(dummy(increment, 2 * i / 2) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (char), long variable)
{
	if (--counter)
		if (!(dummy(function, 2 * variable / 2) == 2L))
			statusFlag++;
	return function(variable);
}

long increment(char variable)
{
	return ++variable;
}
@def_
@def $macro134()
$LICENSE()
$HEAD()

void castor(unsigned);
void pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, no return value, legal 
 */
{
	unsigned        i = 1;

	castor(++i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(unsigned variable)
{
	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux(--variable);
	}
}

void pollux(unsigned variable)
{
	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor(++variable);
	}
}
@def_
@def $macro135()
$LICENSE()
$HEAD()

void castor(unsigned);
void pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, no return value, illegal 
 */
{
	unsigned        i = 0;

	castor(++i);
	if (i == 0L)
		i++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(unsigned variable)
{
	long            ii;

	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		pollux(--variable);
		if (ii == 0L)
			ii++;
	}
}

void pollux(unsigned variable)
{
	long            iii;

	if (variable != 0L)
		statusFlag++;
	if (--counter) {
		castor(++variable);
		if (iii == 0L)
			iii++;
	}
}
@def_
@def $macro136()
$LICENSE()
$HEAD()

long castor(unsigned);
long pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, return value, legal, function declared to return
 * a long 
 */
{
	long            i = 0;

	i = castor((unsigned) ++i);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(unsigned variable)
{
	long            ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(unsigned variable)
{
	long            iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro137()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	long            i = 0;

	if (!(castor(++i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	if (--counter) {
		if (!(pollux(variable + 3) == 5L))
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	if (--counter) {
		if (!(castor(variable - 3) == 2L))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro138()
$LICENSE()
$HEAD()

long castor(unsigned (*) (unsigned), unsigned);
long pollux(unsigned (*) (unsigned), unsigned);
unsigned increment(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	unsigned        i = 100;

	if (!(castor(increment, i - 99) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(unsigned (*function) (unsigned), unsigned variable)
{
	if (--counter) {
		if (!(pollux(function, variable + 10) == 12L))
			statusFlag++;
	}
	return function(variable);
}

long pollux(unsigned (*function) (unsigned), unsigned variable)
{
	if (--counter) {
		if (!(castor(function, variable - 10) == 2L))
			statusFlag++;
	}
	return function(variable);
}

unsigned increment(unsigned variable)
{
	return ++variable;
}
@def_
@def $macro139()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, no return value and
 * legal 
 */
{
	long            i = 0, j = -1, k = 1;

	levelOneNodeOne(i - 2 * j + (-k));
	levelOneNodeTwo((i + j) * j + k);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(long variable)
{
	long            i = variable + 2;
	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(long variable)
{
	long            i = variable * 2;
	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i += 8) / 2);
	levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(long variable)
{
	long            i = variable;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(long variable)
{
	long            i = variable--;
	if (variable != 4L)
		statusFlag++;
	levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;
	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable + i * (variable - i) - 1);
	levelThreeLeafEight(i * (2 * variable - i) - variable);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
}
@def_
@def $macro140()
$LICENSE()
$HEAD()

void levelOneNodeOne(long);
void levelOneNodeTwo(long);
void levelTwoNodeOne(long);
void levelTwoNodeTwo(long);
void levelTwoNodeThree(long);
void levelTwoNodeFour(long);
void levelThreeLeafOne(long);
void levelThreeLeafTwo(long);
void levelThreeLeafThree(long);
void levelThreeLeafFour(long);
void levelThreeLeafFive(long);
void levelThreeLeafSix(long);
void levelThreeLeafSeven(long);
void levelThreeLeafEight(long);

short           statusFlag = NoMistake;
long            result;

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, no return value and
 * illegal 
 */
{
	long            i = 0, j = -1, k = 1;

	levelOneNodeOne(i - 2 * j + (-k));
	levelOneNodeTwo((i + j) * j + k);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(long variable)
{
	if (variable != 1L)
		statusFlag++;
	levelTwoNodeOne((variable == variable) * 2 + variable);
	levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
}

void levelOneNodeTwo(long variable)
{
	long            i = variable + 2;

	if (variable != 2L)
		statusFlag++;
	levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
}

void levelTwoNodeOne(long variable)
{
	long            i = variable * 2;

	if (variable != 3L)
		statusFlag++;
	levelThreeLeafOne((i += 8) / 2);
	levelThreeLeafTwo(variable + (i - 8) / variable + 3);
}

void levelTwoNodeTwo(long variable)
{
	long            i = variable;

	if (variable != 4L)
		statusFlag++;
	levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	levelThreeLeafFour(2 * (variable + 3) - i + 1);
}

void levelTwoNodeThree(long variable)
{
	long            i = variable--;

	if (variable != 4L)
		statusFlag++;
	levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
}

void levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;

	if (variable != 6L)
		statusFlag++;
	levelThreeLeafSeven(variable + i * (variable - i) - 1);
	levelThreeLeafEight(i * (2 * variable - i) - variable);
}

void levelThreeLeafOne(long variable)
{
	if (variable != 7L)
		statusFlag++;
	return;
}

void levelThreeLeafTwo(long variable)
{
	if (variable != 8L)
		statusFlag++;
	return;
}

void levelThreeLeafThree(long variable)
{
	if (variable != 9L)
		statusFlag++;
	return;
}

void levelThreeLeafFour(long variable)
{
	if (variable != 10L)
		statusFlag++;
	return;
}

void levelThreeLeafFive(long variable)
{
	if (variable != 11L)
		statusFlag++;
	return;
}

void levelThreeLeafSix(long variable)
{
	if (variable != 12L)
		statusFlag++;
	return;
}

void levelThreeLeafSeven(long variable)
{
	if (variable != 13L)
		statusFlag++;
	return;
}

void levelThreeLeafEight(long variable)
{
	if (variable != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro141()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelOneNodeTwo(long);
long levelTwoNodeOne(long);
long levelTwoNodeTwo(long);
long levelTwoNodeThree(long);
long levelTwoNodeFour(long);
long levelThreeLeafOne(long);
long levelThreeLeafTwo(long);
long levelThreeLeafThree(long);
long levelThreeLeafFour(long);
long levelThreeLeafFive(long);
long levelThreeLeafSix(long);
long levelThreeLeafSeven(long);
long levelThreeLeafEight(long);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value and
 * legal, Long function declaration 
 */
{
	long            i = 0, j = -1, k = 1;
	long            result = 0;

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1L)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	long            result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3L)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4L)
		statusFlag++;
	return variable;
}

long levelOneNodeTwo(long variable)
{
	long            i = variable + 2;
	long            result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5L)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6L)
		statusFlag++;
	return variable;
}

long levelTwoNodeOne(long variable)
{
	long            i = variable * 2;
	long            result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7L)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8L)
		statusFlag++;
	return variable;
}

long levelTwoNodeTwo(long variable)
{
	long            i = variable;
	long            result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9L)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10L)
		statusFlag++;
	return variable;
}

long levelTwoNodeThree(long variable)
{
	long            i = variable--;
	long            result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11L)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12L)
		statusFlag++;
	return i;
}

long levelTwoNodeFour(long variable)
{
	long            i = variable / 2 - 1;
	long            result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13L)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14L)
		statusFlag++;
	return variable;
}

long levelThreeLeafOne(long variable)
{
	return variable;
}

long levelThreeLeafTwo(long variable)
{
	return variable;
}

long levelThreeLeafThree(long variable)
{
	return variable;
}

long levelThreeLeafFour(long variable)
{
	return variable;
}

long levelThreeLeafFive(long variable)
{
	return variable;
}

long levelThreeLeafSix(long variable)
{
	return variable;
}

long levelThreeLeafSeven(long variable)
{
	return variable;
}

long levelThreeLeafEight(long variable)
{
	return variable;
}
@def_
@def $macro142()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value, legal
 * pointer to function returning a long 
 */
{
	long            i = 3;
	long            result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            i = Long--;

	i = (*func) ((-1 + ++i + ++Long) / 2);
	if (i != 3L)
		statusFlag++;
	return i;
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            i = Long++;

	i = (*func) ((-1 - --i - --Long) / -2);
	if (i != 6L)
		statusFlag++;
	return i;
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro143()
$LICENSE()
$HEAD()

long levelOneNodeOne(long);
long levelTwoNodeOne(long);
long levelThreeLeafOne(long);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	long            i = 1;
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32L)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

long levelOneNodeOne(long variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

long levelTwoNodeOne(long variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

long levelThreeLeafOne(long variable)
{
	return 2 * variable;
}
@def_
@def $macro144()
$LICENSE()
$HEAD()

long dummy1(long (*) (long), long);
long divide4(long);
long dummy2(long (*) (long), long);
long divide2(long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, in conditional
 * expression, pointer to function returning a long 
 */
{
	long            i = 2;

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy1(long (*func) (long), long Long)
{
	long            i = Long % 3;

	return (*func) ((Long + i) * (2 + i) / (2 - i));
}

long divide4(long Long)
{
	return dummy2(divide2, Long) / 2;
}

long dummy2(long (*func) (long), long Long)
{
	long            i = Long + 1;

	return (*func) ((i + ++Long) / 2 - 1);
}

long divide2(long Long)
{
	return Long / 2;
}
@def_
@def $macro145()
$LICENSE()
$HEAD()

#ifndef TimeLimit
#define TimeLimit 10
#endif

void recursiveFunction(long, long);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, no return value, legal 
 */
{
	long            i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
				  counter ? --counter : ++counter);
}
@def_
@def $macro146()
$LICENSE()
$HEAD()

#ifndef TimeLimit
#define TimeLimit 10
#endif

void recursiveFunction(long, long);

short           statusFlag = NoMistake;
long            result;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, no return value, illegal 
 */
{
	long            i = 0;
	long            counter = TimeLimit;

	recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void recursiveFunction(long variable, long counter)
{
	if (variable + counter != 11L)
		statusFlag++;
	if (counter)
		recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
}
@def_
@def $macro147()
$LICENSE()
$HEAD()

#ifndef TimeLimit
#define TimeLimit 10
#endif

short           statusFlag = NoMistake;
long            recursiveFunction();

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, Long function
 * declaration 
 */
{
	long            i = 0, result = 0;
	long            counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12L - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable, long counter)
{
	long            result = 0;
	long            storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12L - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro148()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

long dummy(long (*) (long), long, long);
long increment(long);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, pointer to
 * function returning a long 
 */
{
	long            i = 0;
	long            counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable, long counter)
{
	long            result = 0;
	long            storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2L)
			statusFlag++;
	}
	return function(storage);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro149()
$LICENSE()
$HEAD()

long recursiveFunction(long, long);

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, function in conditional
 * expression, Long function declaration 
 */
{
	long            i = -1;
	long            counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long recursiveFunction(long variable, long counter)
{
	long            storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1L)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro150()
$LICENSE()
$HEAD()

long dummy(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, in conditional expression,
 * pointer to function returning a long 
 */
{
	long            i = 2, j = 1;

	if (dummy(increment, (long) (j + i * j >= 10 || i - j > 0)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long dummy(long (*function) (long), long variable)
{
	long            storage = variable;

	if (--counter)
		if (dummy(function, (long) ((++variable - 1 == 0) + 1)) != 2L)
			statusFlag++;
	return function(storage);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro151()
$LICENSE()
$HEAD()

void castor(long, long);
void pollux(long, long);

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, no return value, legal 
 */
{
	long            i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	long            i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter) {
		pollux((i & i == i) + (j == i), counter);
	}
}

void pollux(long variable, long counter)
{
	long            i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter) {
		castor((i & i == i & i) + (j != i), counter);
	}
}
@def_
@def $macro152()
$LICENSE()
$HEAD()

void castor(long, long);
void pollux(long, long);

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif
long            result;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, no return value, illegal 
 */
{
	long            i = 1, j = 2;
	long            counter = TimeLimit;

	castor((i & i == i | i) + (j != i), counter);
	if (result != 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void castor(long variable, long counter)
{
	long            i = 1, j = 2;

	if (variable != 2L)
		statusFlag++;
	if (--counter)
		pollux((i & i == i) + (j == i), counter);
}

void pollux(long variable, long counter)
{
	long            i = 1, j = 2;

	if (variable != 1L)
		statusFlag++;
	if (--counter)
		castor((i & i == i & i) + (j != i), counter);
}
@def_
@def $macro153()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, return value, pointer to function
 * returning a long 
 */
{
	long            i = 0;

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	long            iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro154()
$LICENSE()
$HEAD()

long castor(long);
long pollux(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	long            i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long variable)
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5L)
			statusFlag++;
	}
	return ++variable;
}

long pollux(long variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2L)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro155()
$LICENSE()
$HEAD()

long castor(long (*) (long), long);
long pollux(long (*) (long), long);
long increment(long);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            i = 1;

	if (castor(increment, (long) ((i << 1 | i) == i + 2)) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

long castor(long (*function) (long), long variable)
{
	long            pollux();
	if (--counter) {
		if (pollux(function, (long) ((variable + 2) * 3 + variable * 2)) != 12L)
			statusFlag++;
	}
	return function(variable);
}

long pollux(long (*function) (long), long variable)
{
	if (--counter) {
		if (castor(function, (long) ((variable - 1) / 5 >> 1)) != 2L)
			statusFlag++;
	}
	return function(variable);
}

long increment(long variable)
{
	return ++variable;
}
@def_
@def $macro156()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *argument)
{
	short           result = 0;
	extern short    i11;

	i11 = 3;
	result = levelTwoNodeOne(&i11);
	if (result != 3)
		statusFlag++;
	i11 = 4;
	result = levelTwoNodeTwo(&i11);
	if (result != 4)
		statusFlag++;
	return *argument;
}

int levelOneNodeTwo(short *argument)
{
	short           result = 0;
	extern short    i12;

	i12 = 5;
	result = levelTwoNodeThree(&i12);
	if (result != 5)
		statusFlag++;
	i12 = 6;
	result = levelTwoNodeFour(&i12);
	if (result != 6)
		statusFlag++;
	return *argument;
}

int levelTwoNodeOne(short *argument)
{
	short           result = 0;
	extern short    i21;

	i21 = 7;
	result = levelThreeLeafOne(&i21);
	if (result != 7)
		statusFlag++;
	i21 = 8;
	result = levelThreeLeafTwo(&i21);
	if (result != 8)
		statusFlag++;
	return *argument;
}

int levelTwoNodeTwo(short *argument)
{
	short           result = 0;
	extern short    i22;

	i22 = 9;
	result = levelThreeLeafThree(&i22);
	if (result != 9)
		statusFlag++;
	i22 = 10;
	result = levelThreeLeafFour(&i22);
	if (result != 10)
		statusFlag++;
	return *argument;
}

int levelTwoNodeThree(short *argument)
{
	short           result = 0;
	extern short    i23;

	i23 = 11;
	result = levelThreeLeafFive(&i23);
	if (result != 11)
		statusFlag++;
	i23 = 12;
	result = levelThreeLeafSix(&i23);
	if (result != 12)
		statusFlag++;
	return *argument;
}

int levelTwoNodeFour(short *argument)
{
	short           result = 0;
	extern short    i24;

	i24 = 13;
	result = levelThreeLeafSeven(&i24);
	if (result != 13)
		statusFlag++;
	i24 = 14;
	result = levelThreeLeafEight(&i24);
	if (result != 14)
		statusFlag++;
	return *argument;
}

int levelThreeLeafOne(short *argument)
{
	return *argument;
}

int levelThreeLeafTwo(short *argument)
{
	return *argument;
}

int levelThreeLeafThree(short *argument)
{
	return *argument;
}

int levelThreeLeafFour(short *argument)
{
	return *argument;
}

int levelThreeLeafFive(short *argument)
{
	return *argument;
}

int levelThreeLeafSix(short *argument)
{
	return *argument;
}

int levelThreeLeafSeven(short *argument)
{
	return *argument;
}

int levelThreeLeafEight(short *argument)
{
	return *argument;
}
@def_
@def $macro157()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelOneNodeTwo(short*);
short levelTwoNodeOne(short*);
short levelTwoNodeTwo(short*);
short levelTwoNodeThree(short*);
short levelTwoNodeFour(short*);
short levelThreeLeafOne(short*);
short levelThreeLeafTwo(short*);
short levelThreeLeafThree(short*);
short levelThreeLeafFour(short*);
short levelThreeLeafFive(short*);
short levelThreeLeafSix(short*);
short levelThreeLeafSeven(short*);
short levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           i, i11, i12, i21, i22, i23, i24;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *argument)
{
	short           result = 0;
	extern short    i11;

	i11 = 3;
	result = levelTwoNodeOne(&i11);
	if (result != 3)
		statusFlag++;
	i11 = 4;
	result = levelTwoNodeTwo(&i11);
	if (result != 4)
		statusFlag++;
	return *argument;
}

short levelOneNodeTwo(short *argument)
{
	short           result = 0;
	extern short    i12;

	i12 = 5;
	result = levelTwoNodeThree(&i12);
	if (result != 5)
		statusFlag++;
	i12 = 6;
	result = levelTwoNodeFour(&i12);
	if (result != 6)
		statusFlag++;
	return *argument;
}

short levelTwoNodeOne(short *argument)
{
	short           result = 0;
	extern short    i21;

	i21 = 7;
	result = levelThreeLeafOne(&i21);
	if (result != 7)
		statusFlag++;
	i21 = 8;
	result = levelThreeLeafTwo(&i21);
	if (result != 8)
		statusFlag++;
	return *argument;
}

short levelTwoNodeTwo(short *argument)
{
	short           result = 0;
	extern short    i22;

	i22 = 9;
	result = levelThreeLeafThree(&i22);
	if (result != 9)
		statusFlag++;
	i22 = 10;
	result = levelThreeLeafFour(&i22);
	if (result != 10)
		statusFlag++;
	return *argument;
}

short levelTwoNodeThree(short *argument)
{
	short           result = 0;
	extern short    i23;

	i23 = 11;
	result = levelThreeLeafFive(&i23);
	if (result != 11)
		statusFlag++;
	i23 = 12;
	result = levelThreeLeafSix(&i23);
	if (result != 12)
		statusFlag++;
	return *argument;
}

short levelTwoNodeFour(short *argument)
{
	short           result = 0;
	extern short    i24;

	i24 = 13;
	result = levelThreeLeafSeven(&i24);
	if (result != 13)
		statusFlag++;
	i24 = 14;
	result = levelThreeLeafEight(&i24);
	if (result != 14)
		statusFlag++;
	return *argument;
}

short levelThreeLeafOne(short *argument)
{
	return *argument;
}

short levelThreeLeafTwo(short *argument)
{
	return *argument;
}

short levelThreeLeafThree(short *argument)
{
	return *argument;
}

short levelThreeLeafFour(short *argument)
{
	return *argument;
}

short levelThreeLeafFive(short *argument)
{
	return *argument;
}

short levelThreeLeafSix(short *argument)
{
	return *argument;
}

short levelThreeLeafSeven(short *argument)
{
	return *argument;
}

short levelThreeLeafEight(short *argument)
{
	return *argument;
}
@def_
@def $macro158()
$LICENSE()
$HEAD()

char *levelOne(short*);
char *levelTwo(short*);
char *levelThree(short*);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           i;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short *variable)
{
	char           *s1, *s2;
	short           j;

	if (*variable != 1)
		statusFlag++;
	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	return s1;
}

char *levelTwo(short *variable)
{
	char           *s1, *s2;
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	return s1;
}

char *levelThree(short *variable)
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	return s;
}
@def_
@def $macro159()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           i = 12;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, return value, legal pointer to function returning
 * an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short *integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short *integer)
{
	return *integer / 2;
}
@def_
@def $macro160()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           i, j, ii, jj, iii, jjj, iiii, jjjj, iiiii, jjjjj, iiiiii, jjjjjj, iiiiiii, jjjjjjj;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	extern short    i, j;

	i = 1;
	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *variable)
{
	extern short    ii, jj;
	jj = (ii = (*variable) + 1) + 1;
	return levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
}

int levelOneNodeTwo(short *variable)
{
	extern short    iii, jjj;
	jjj = (iii = (*variable) + 1) + 1;
	return levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
}

int levelTwoNodeOne(short *variable)
{
	extern short    iiii, jjjj;
	jjjj = (iiii = (*variable) + 1) + 1;
	return levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
}

int levelTwoNodeTwo(short *variable)
{
	extern short    iiiii, jjjjj;
	jjjjj = (iiiii = (*variable) + 1) + 1;
	return levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
}

int levelTwoNodeThree(short *variable)
{
	extern short    iiiiii, jjjjjj;
	jjjjjj = (iiiiii = (*variable) + 1) + 1;
	return levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
}

int levelTwoNodeFour(short *variable)
{
	extern short    iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = (*variable) + 1) + 1;
	return levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
}

int levelThreeLeafOne(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafTwo(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafThree(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafFour(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafFive(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafSix(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafSeven(short *variable)
{
	return (*variable) + 1;
}

int levelThreeLeafEight(short *variable)
{
	return (*variable) + 1;
}
@def_
@def $macro161()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelTwoNodeOne(short*);
short levelThreeLeafOne(short*);

short           statusFlag = NoMistake;
short           i = 1, ii, iii;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	extern short    i;

	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *variable)
{
	extern short    ii;

	ii = 2 * (*variable);
	return 2 * levelTwoNodeOne(&ii);
}

short levelTwoNodeOne(short *variable)
{
	extern short    iii;

	iii = 2 * (*variable);
	return 2 * levelThreeLeafOne(&iii);
}

short levelThreeLeafOne(short *variable)
{
	return 2 * (*variable);
}
@def_
@def $macro162()
$LICENSE()
$HEAD()

char *skip(char*);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            i = 4, j;

int main(void)				/* alias root */
/*
 *  test class: extern variable address instance  : linear tree structure, used in conditional expression, function declared
 * to return a pointer to character 
 */
{
	extern char     i, j;

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) == compare(skip(&j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(char *skipper)
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < *skipper; ii++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro163()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           i = 12;

int main(void)
/*
 * test class: extern variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return ii;
}

short divide4(short *integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return ii;
}

short divide2(short *integer)
{
	return *integer / 2;
}
@def_
@def $macro164()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           result;

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	short           result = 0;

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return i + 1;
}
@def_
@def $macro165()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, legal, integer function declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	extern short    i;
	short           result = 0;

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return i + 1;
}
@def_
@def $macro166()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s;
	extern short    i;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + (*variable);
}
@def_
@def $macro167()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           result = 0;

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	short           result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return function(*variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro168()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - (*variable) == 1))
			statusFlag++;
	return (*variable) + 1;
}
@def_
@def $macro169()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1))
			statusFlag++;
	return (*variable) + 1;
}
@def_
@def $macro170()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	extern short    i;

	if (!(*recursiveFunction(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	if (--counter)
		if (!(*recursiveFunction(variable) == '2'))
			statusFlag++;
	return numbers + *variable;
}
@def_
@def $macro171()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: extern variable address instance  : recursive call, in conditional expression, pointer to function returning
 * an integer 
 */
{
	if (!(dummy(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	if (--counter)
		if (!(dummy(function, variable) == 2))
			statusFlag++;
	return function(*variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro172()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, legal, no function declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return *variable + 1;
}

int pollux(short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro173()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           result = 0;

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return *variable + 1;
}

short pollux(short *variable)
{
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro174()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	s = castor(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	extern short    ii;
	char           *s;

	ii = *variable + 4;
	if (--counter) {
		s = pollux(&ii);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + *variable;
}

char *pollux(short *variable)
{
	extern short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		s = castor(&iii);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + *variable;
}
@def_
@def $macro175()
$LICENSE()
$HEAD()

int castor(short (*) (short), short*);
int pollux(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, return value, pointer to function returning an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = castor(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10)
			statusFlag++;
	}
	return function(*variable);
}

int pollux(short (*function) (short), short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2)
			statusFlag++;
	}
	return function(*variable);
}

short increment(short variable)
{
	return ++variable;
}

@def_
@def $macro176()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, no function declaration 
 */
{
	i = 1;
	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;

	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return *variable + 1;
}

int pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro177()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	extern short    i;

	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return *variable + 1;
}

short pollux(short *variable)
{
	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return *variable + 1;
}
@def_
@def $macro178()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           i = 2, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, function declared to return a pointer
 * to character 
 */
{
	extern short    i;

	if (!(*castor(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	extern short    ii;

	ii = *variable + 4;
	if (--counter) {
		if (!(*pollux(&ii) == '6'))
			statusFlag++;
	}
	return numbers + *variable;
}

char *pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 4;
	if (--counter) {
		if (!(*castor(&iii) == '2'))
			statusFlag++;
	}
	return numbers + *variable;
}
@def_
@def $macro179()
$LICENSE()
$HEAD()

int castor(short (*) (short), short*);
int pollux(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: extern variable address instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{
	if (!(castor(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short *variable)
{
	extern short    ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12))
			statusFlag++;
	}
	return function(*variable);
}

int pollux(short (*function) (short), short *variable)
{
	extern short    iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2))
			statusFlag++;
	}
	return function(*variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro180()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafTwo(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafThree(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafFour(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafFive(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafSix(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafSeven(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

int levelThreeLeafEight(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}
@def_
@def $macro181()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelOneNodeTwo(short*);
short levelTwoNodeOne(short*);
short levelTwoNodeTwo(short*);
short levelTwoNodeThree(short*);
short levelTwoNodeFour(short*);
short levelThreeLeafOne(short*);
short levelThreeLeafTwo(short*);
short levelThreeLeafThree(short*);
short levelThreeLeafFour(short*);
short levelThreeLeafFive(short *variable);
short levelThreeLeafSix(short *variable);
short levelThreeLeafSeven(short *variable);
short levelThreeLeafEight(short *variable);

short           statusFlag = NoMistake;
short           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, return value and legal,
 * integer function declaration 
 */
{
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(short *variable)
{
	short           storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafTwo(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafThree(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafFour(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafFive(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafSix(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafSeven(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}

short levelThreeLeafEight(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return i;
}
@def_
@def $macro182()
$LICENSE()
$HEAD()

char *levelOne(short*);
char *levelTwo(short*);
char *levelThree(short*);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s;
	extern short    i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1' || i != 4)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short *variable)
{
	char           *s1, *s2;
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2' || *variable != 4)
		statusFlag++;
	return s1;
}

char *levelTwo(short *variable)
{
	char           *s1, *s2;
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3' || *variable != 4)
		statusFlag++;
	return s1;
}

char *levelThree(short *variable)
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	(*variable)++;
	return s;
}
@def_
@def $macro183()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           i = 12;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = dummy1(divide4, &i);
	if (result != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3 || *integer != 0)
		statusFlag++;
	return i;
}

short divide4(short *integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6 || *integer != 0)
		statusFlag++;
	return i;
}

short divide2(short *integer)
{
	short           i = *integer;

	(*integer) = 0;
	return i / 2;
}
@def_
@def $macro184()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           i, j, ii, jj, iii, jjj, iiii, jjjj, iiiii, jjjjj, iiiiii, jjjjjj, iiiiiii, jjjjjjj;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, no function declaration 
 */
{
	extern short    i, j;

	i = 1;
	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (i != 3 || j != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *variable)
{
	extern short    ii, jj;
	short           storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	if (ii != 3 || jj != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(short *variable)
{
	extern short    iii, jjj;
	short           storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	if (iii != 4 || jjj != 5)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(short *variable)
{
	extern short    iiii, jjjj;
	short           storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	if (iiii != 4 || jjjj != 5)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(short *variable)
{
	extern short    iiiii, jjjjj;
	short           storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	if (iiiii != 5 || jjjjj != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(short *variable)
{
	extern short    iiiiii, jjjjjj;
	short           storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	if (iiiiii != 5 || jjjjjj != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(short *variable)
{
	extern short    iiiiiii, jjjjjjj;
	short           storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	if (iiiiiii != 6 || jjjjjjj != 7)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafTwo(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafThree(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafFour(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafFive(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafSix(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafSeven(short *variable)
{
	return ++(*variable);
}

int levelThreeLeafEight(short *variable)
{
	return ++(*variable);
}
@def_
@def $macro185()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelTwoNodeOne(short*);
short levelThreeLeafOne(short*);

short           statusFlag = NoMistake;
short           i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	extern short    i;

	if (!(levelOneNodeOne(&i) == 32) || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *variable)
{
	(*variable) *= 2;
	return 2 * levelTwoNodeOne(variable);
}

short levelTwoNodeOne(short *variable)
{
	(*variable) *= 2;
	return 2 * levelThreeLeafOne(variable);
}

short levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	(*variable) = 0;
	return 2 * i;
}
@def_
@def $macro186()
$LICENSE()
$HEAD()

char *skip(char*);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            i, j;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	short           statusFlag = NoMistake;

	i = 4;
	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (i != 0 || j != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *skip(char *skipper)
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return 0;
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro187()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           i = 12;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning an integer 
 */
{
	if (dummy1(divide4, &i) != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3 || *integer != 0)
		statusFlag++;
	return ii;
}

short divide4(short *integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6 || *integer != 0)
		statusFlag++;
	return ii;
}

short divide2(short *integer)
{
	short           i = *integer;

	(*integer) = 0;
	return i / 2;
}
@def_
@def $macro188()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	short           result;

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	short           result = 0;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != (*variable))
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro189()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, legal, integer
 * function declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	short           result = 0;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro190()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890";
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;

	s = recursiveFunction(&i);
	if (*s != '0' + (i - 1) % 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	char           *s;

	i = *variable;
	if (--counter) {
		s = recursiveFunction(&i);
		if (*s != '0' + (i - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}
@def_
@def $macro191()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = dummy(increment, &i);
	if (result - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	short           result;
	extern short    i;

	i = *variable;
	if (--counter) {
		result = dummy(function, &i);
		if (result - i != 2)
			statusFlag++;
	}
	return function((*variable)--);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro192()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, function in conditional expression,
 * no function declaration 
 */
{
	extern short    i;

	if (!(recursiveFunction(&i) - i == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	extern short    i;

	i = *variable;
	if (--counter)
		if (!(recursiveFunction(&i) - i == 2))
			statusFlag++;
	return (*variable)-- + 1;
}
@def_
@def $macro193()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	if (recursiveFunction(&i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	extern short    i;

	i = *variable;
	if (--counter)
		if (recursiveFunction(&i) - i != 2)
			statusFlag++;
	return (*variable)-- + 1;
}
@def_
@def $macro194()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "012345678901234";
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	extern short    i;
	char            c;

	c = *recursiveFunction(&i);
	if (c != '0' + (i - 1) % 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	extern short    i;
	char            c;

	i = *variable;
	if (--counter) {
		c = *recursiveFunction(&i);
		if (c != '0' + (i - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}
@def_
@def $macro195()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning an integer 
 */
{
	if (dummy(increment, &i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	i = *variable;
	if (--counter)
		if (dummy(function, &i) - i != 2)
			statusFlag++;
	return function((*variable)--);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro196()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, no function declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return ++(*variable);
}

int pollux(short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return --(*variable) + 2;
}
@def_
@def $macro197()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	short           result = 0;

	i = 1;
	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return ++(*variable);
}

short pollux(short *variable)
{
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return --(*variable) + 2;
}
@def_
@def $macro198()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890123456";
short           i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	extern short    i;

	s = castor(&i);
	if (*s != '0' + i - 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	extern short    ii;
	char           *s;

	ii = *variable + 4;
	if (--counter) {
		s = pollux(&ii);
		if (*s != '0' + (ii - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}

char *pollux(short *variable)
{
	extern short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		s = castor(&iii);
		if (*s != '0' + (iii - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}
@def_
@def $macro199()
$LICENSE()
$HEAD()

int castor(short (*) (short*), short*);
int pollux(short (*) (short*), short*);
short increment(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * an integer 
 */
{
	short           result = 0;

	result = castor(increment, &i);
	if (result != i + 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short*), short *variable)
{
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short*), short *variable)
{
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != iii + 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short *variable)
{
	short           i = *variable;

	(*variable)--;
	return ++i;
}
@def_
@def $macro200()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	extern short    i;

	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return ++(*variable);
}

int pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro201()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return an integer 
 */
{
	extern short    i;

	i = 1;
	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	extern short    ii;

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return ++(*variable);
}

short pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return ++(*variable);
}
@def_
@def $macro202()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890123456789012345";
short           i = 13, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return a pointer to character 
 */
{
	char            c;

	c = *castor(&i);
	if (c != '0' + (i - 1) % 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	char            c;

	ii = *variable + 2;
	if (--counter) {
		c = *pollux(&ii);
		if (c != '0' + (ii - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}

char *pollux(short *variable)
{
	char            c;

	iii = *variable - 2;
	if (--counter) {
		c = *castor(&iii);
		if (c != '0' + (iii - 1) % 10)
			statusFlag++;
	}
	return numbers + (*variable)++;
}
@def_
@def $macro203()
$LICENSE()
$HEAD()

int castor(short (*) (short*), short*);
int pollux(short (*) (short*), short*);
short increment(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	if (castor(increment, &i) != i + 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short*), short *variable)
{

	ii = *variable + 10;
	if (--counter) {
		if (pollux(function, &ii) != ii + 2)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short*), short *variable)
{
	iii = *variable - 10;
	if (--counter) {
		if (castor(function, &iii) != iii + 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short *variable)
{
	return --(*variable) + 2;
}
@def_
@def $macro204()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	extern short    i;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafTwo(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafThree(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafFour(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafFive(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafSix(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafSeven(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

int levelThreeLeafEight(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}
@def_
@def $macro205()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelOneNodeTwo(short*);
short levelTwoNodeOne(short*);
short levelTwoNodeTwo(short*);
short levelTwoNodeThree(short*);
short levelTwoNodeFour(short*);
short levelThreeLeafOne(short*);
short levelThreeLeafTwo(short*);
short levelThreeLeafThree(short*);
short levelThreeLeafFour(short*);
short levelThreeLeafFive(short*);
short levelThreeLeafSix(short*);
short levelThreeLeafSeven(short*);
short levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	short           result = 0;

	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(short *variable)
{
	short           storage = *variable, result = 0;

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafTwo(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafThree(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafFour(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafFive(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafSix(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafSeven(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}

short levelThreeLeafEight(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return i;
}
@def_
@def $macro206()
$LICENSE()
$HEAD()

char *levelOne(short*);
char *levelTwo(short*);
char *levelThree(short*);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short *variable)
{
	char           *s1, *s2;
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return s1;
}

char *levelTwo(short *variable)
{
	char           *s1, *s2;
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return s1;
}

char *levelThree(short *variable)
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return s;
}
@def_
@def $macro207()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i = 12;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	short           result = 0;

	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return i;
}

short divide4(short *integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return i;
}

short divide2(short *integer)
{
	short           i = *integer;

	(*integer) = 0;
	return i / 2;
}
@def_
@def $macro208()
$LICENSE()
$HEAD()

int levelOneNodeOne(short*);
int levelOneNodeTwo(short*);
int levelTwoNodeOne(short*);
int levelTwoNodeTwo(short*);
int levelTwoNodeThree(short*);
int levelTwoNodeFour(short*);
int levelThreeLeafOne(short*);
int levelThreeLeafTwo(short*);
int levelThreeLeafThree(short*);
int levelThreeLeafFour(short*);
int levelThreeLeafFive(short*);
int levelThreeLeafSix(short*);
int levelThreeLeafSeven(short*);
int levelThreeLeafEight(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i, j, ii, jj, iii, jjj, iiii, jjjj, iiiii, jjjjj, iiiiii, jjjjjj, iiiiiii, jjjjjjj;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, used in conditional expression, no
 * function declaration 
 */
{
	i = 1;
	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short *variable)
{
	extern short    ii, jj;
	short           storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	return storage;
}

int levelOneNodeTwo(short *variable)
{
	extern short    iii, jjj;
	short           storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	return storage;
}

int levelTwoNodeOne(short *variable)
{
	extern short    iiii, jjjj;
	short           storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	return storage;
}

int levelTwoNodeTwo(short *variable)
{
	extern short    iiiii, jjjjj;
	short           storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	return storage;
}

int levelTwoNodeThree(short *variable)
{
	extern short    iiiiii, jjjjjj;
	short           storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	return storage;
}

int levelTwoNodeFour(short *variable)
{
	extern short    iiiiiii, jjjjjjj;
	short           storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	return storage;
}

int levelThreeLeafOne(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafTwo(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafThree(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafFour(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafFive(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafSix(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafSeven(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}

int levelThreeLeafEight(short *variable)
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return ++i;
}
@def_
@def $macro209()
$LICENSE()
$HEAD()

short levelOneNodeOne(short*);
short levelTwoNodeOne(short*);
short levelThreeLeafOne(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i = 1;

int main(void)				/* alias root */
/*
 *  test class: external variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short *variable)
{
	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return 2 * levelTwoNodeOne(&i);
}

short levelTwoNodeOne(short *variable)
{
	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return 2 * levelThreeLeafOne(&i);
}

short levelThreeLeafOne(short *variable)
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return 2 * i;
}
@def_
@def $macro210()
$LICENSE()
$HEAD()

char *skip(char*);
int compare(char*, char*, short);

char           *protean = "cassandracross";
char            globalCharacter = 10;
short           statusFlag = NoMistake;
char            i, j;

int main(void)				/* alias root */
/*
 *  test class: external variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	extern char     i, j;

	i = 4;
	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *skip(char *skipper)
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	skipper = &globalCharacter;
	if (*skipper != 10)
		statusFlag++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro211()
$LICENSE()
$HEAD()

int dummy1(short (*) (short*), short*);
short divide4(short*);
int dummy2(short (*) (short*), short*);
short divide2(short*);

short           statusFlag = NoMistake;
short           globalInteger = 10;
short           i = 12;

int main(void)
/*
 * test class: external variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning an integer 
 */
{
	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return ii;
}

short divide4(short *integer)
{
	short           divide2();

	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short*), short *integer)
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return ii;
}

short divide2(short *integer)
{
	short           i = *integer;

	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return i / 2;
}
@def_
@def $macro212()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	extern short    i;
	short           result;

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	short           result = 0;
	extern short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return i;
}
@def_
@def $macro213()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	extern short    i;
	short           result = 0;

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	short           result = 0;
	extern short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return i;
}
@def_
@def $macro214()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;
short           i = 2;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	char           *s;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = recursiveFunction(&i);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + i;
}
@def_
@def $macro215()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, return value, pointer to function returning
 * an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	short           result;
	extern short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2)
			statusFlag++;
	}
	return function(i);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro216()
$LICENSE()
$HEAD()

int recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	i = 1;
	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short *variable)
{
	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return i + 1;
}
@def_
@def $macro217()
$LICENSE()
$HEAD()

short recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, function in conditional expression, integer
 * function declaration 
 */
{
	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short *variable)
{
	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return i + 1;
}
@def_
@def $macro218()
$LICENSE()
$HEAD()

char *recursiveFunction(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
char           *numbers = "0123456789";
short           i = 2;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	extern short    i;

	if (*recursiveFunction(&i) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short *variable)
{
	extern short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (!(*recursiveFunction(&i) == '2'))
			statusFlag++;
	return numbers + i;
}
@def_
@def $macro219()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1;

int main(void)
/*
 * test class: external variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	extern short    i;

	if (dummy(increment, &i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short *variable)
{
	extern short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2)
			statusFlag++;
	return function(i);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro220()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, no function declaration 
 */
{
	short           result = 0;

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return ii;
}

int pollux(short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return iii;
}
@def_
@def $macro221()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	extern short    i;
	short           result = 0;

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return ii;
}

short pollux(short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return iii;
}
@def_
@def $macro222()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;
short           i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s;
	extern short    i;

	s = castor(&i);
	if (*s != '6')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	extern short    ii;
	char           *s;

	ii = *variable + 4;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = pollux(&ii);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + ii;
}

char *pollux(short *variable)
{
	extern short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = castor(&iii);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + iii;
}
@def_
@def $macro223()
$LICENSE()
$HEAD()

int castor(short (*) (short), short*);
int pollux(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	extern short    i;
	short           result = 0;

	result = castor(increment, &i);
	if (result != 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short *variable)
{
	extern short    ii;
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2)
			statusFlag++;
	}
	return function(ii);
}

int pollux(short (*function) (short), short *variable)
{
	extern short    iii;
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10)
			statusFlag++;
	}
	return function(iii);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro224()
$LICENSE()
$HEAD()

int castor(short*);
int pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, no function declaration 
 */
{
	extern short    i;

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short *variable)
{
	extern short    ii;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return ii + 1;
}

int pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return iii + 1;
}
@def_
@def $macro225()
$LICENSE()
$HEAD()

short castor(short*);
short pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	extern short    i;

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short *variable)
{
	extern short    ii;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return ii + 1;
}

short pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return iii + 1;
}
@def_
@def $macro226()
$LICENSE()
$HEAD()

char *castor(short*);
char *pollux(short*);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;
short           i = 2, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	extern short    i;

	if (!(*castor(&i) == '6'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short *variable)
{
	extern short    ii;

	ii = *variable + 4;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*pollux(&ii) == '2'))
			statusFlag++;
	}
	return numbers + ii;
}

char *pollux(short *variable)
{
	extern short    iii;

	iii = *variable - 4;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*castor(&iii) == '6'))
			statusFlag++;
	}
	return numbers + iii;
}
@def_
@def $macro227()
$LICENSE()
$HEAD()

int castor(short (*) (short), short*);
int pollux(short (*) (short), short*);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
short           i = 1, ii, iii;

int main(void)
/*
 * test class: external variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	extern short    i;

	if (!(castor(increment, &i) == 12))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short *variable)
{
	extern short    ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 2))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return function(ii);
}

int pollux(short (*function) (short), short *variable)
{
	extern short    iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 12))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return function(iii);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro228()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(++i);
	if (i != 1)
		statusFlag++;
	i = levelOneNodeTwo(++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           storage = variable;

	variable = levelTwoNodeOne(variable += 2);
	if (variable != 3)
		statusFlag++;
	variable = levelTwoNodeTwo(++variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

int levelOneNodeTwo(short variable)
{
	short           storage = variable;

	variable = levelTwoNodeThree(variable += 3);
	if (variable != 5)
		statusFlag++;
	variable = levelTwoNodeFour(++variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafOne(variable += 4);
	if (variable != 7)
		statusFlag++;
	variable = levelThreeLeafTwo(++variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafThree(variable += 5);
	if (variable != 9)
		statusFlag++;
	variable = levelThreeLeafFour(++variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafFive(variable += 6);
	if (variable != 11)
		statusFlag++;
	variable = levelThreeLeafSix(++variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafSeven(variable += 7);
	if (variable != 13)
		statusFlag++;
	variable = levelThreeLeafEight(++variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro229()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne(++i);
	if (i != 1)
		statusFlag++;
	i = levelOneNodeTwo(++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           storage = variable;

	variable = levelTwoNodeOne(variable += 2);
	if (variable != 3)
		statusFlag++;
	variable = levelTwoNodeTwo(++variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(short variable)
{
	short           storage = variable;

	variable = levelTwoNodeThree(variable += 3);
	if (variable != 5)
		statusFlag++;
	variable = levelTwoNodeFour(++variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafOne(variable += 4);
	if (variable != 7)
		statusFlag++;
	variable = levelThreeLeafTwo(++variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafThree(variable += 5);
	if (variable != 9)
		statusFlag++;
	variable = levelThreeLeafFour(++variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafFive(variable += 6);
	if (variable != 11)
		statusFlag++;
	variable = levelThreeLeafSix(++variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(short variable)
{
	short           storage = variable;

	variable = levelThreeLeafSeven(variable += 7);
	if (variable != 13)
		statusFlag++;
	variable = levelThreeLeafEight(++variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(short variable)
{
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	return variable;
}

short levelThreeLeafThree(short variable)
{
	return variable;
}

short levelThreeLeafFour(short variable)
{
	return variable;
}

short levelThreeLeafFive(short variable)
{
	return variable;
}

short levelThreeLeafSix(short variable)
{
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro230()
$LICENSE()
$HEAD()

char *levelOne(short);
char *levelTwo(short);
char *levelThree(short);

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 0;

	s = levelOne(++i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable)
{
	char           *s;
	short           j = variable;

	if (variable != 1)
		statusFlag++;
	s = levelTwo(++j);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char *levelTwo(short variable)
{
	char           *s;
	short           k = variable;

	if (variable != 2)
		statusFlag++;
	s = levelThree(++k);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char *levelThree(short variable)
{
	char           *s;
	short           l;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro231()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	short           i = 3;

	i = dummy1(divide4, i *= 4);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro232()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, used in conditional expression, no
 * function declaration 
 */
{
	short           i = 0, j = 0;

	if (levelOneNodeOne(i += 1) + levelOneNodeTwo(j += 2) != 44)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           i = 1, j = 2;
	return levelTwoNodeOne(i += variable) + levelTwoNodeTwo(j += variable);
}

int levelOneNodeTwo(short variable)
{
	short           i = 1, j = 2;
	return levelTwoNodeThree(i += variable) + levelTwoNodeFour(j += variable);
}

int levelTwoNodeOne(short variable)
{
	short           i = 1, j = 2;
	return levelThreeLeafOne(i += variable) + levelThreeLeafTwo(j += variable);
}

int levelTwoNodeTwo(short variable)
{
	short           i = 1, j = 2;
	return levelThreeLeafThree(i += variable) + levelThreeLeafFour(j += variable);
}

int levelTwoNodeThree(short variable)
{
	short           i = 1, j = 2;
	return levelThreeLeafFive(i += variable) + levelThreeLeafSix(j += variable);
}

int levelTwoNodeFour(short variable)
{
	short           i = 1, j = 2;
	return levelThreeLeafSeven(i += variable) + levelThreeLeafEight(j += variable);
}

int levelThreeLeafOne(short variable)
{
	return ++variable;
}

int levelThreeLeafTwo(short variable)
{
	return ++variable;
}

int levelThreeLeafThree(short variable)
{
	return ++variable;
}

int levelThreeLeafFour(short variable)
{
	return ++variable;
}

int levelThreeLeafFive(short variable)
{
	return ++variable;
}

int levelThreeLeafSix(short variable)
{
	return ++variable;
}

int levelThreeLeafSeven(short variable)
{
	return ++variable;
}

int levelThreeLeafEight(short variable)
{
	return ++variable;
}
@def_
@def $macro233()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	short           i = 0;

	if (!(levelOneNodeOne(++i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

short levelTwoNodeOne(short variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro234()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression (case 1) instance  : linear tree structure, used in conditional expression,
 * function declared to return a pointer to character 
 */
{
	short           i = 2, j = i;

	if (compare(skip(2 * i), "andra", 5) == compare(skip(4 * j), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro235()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : linear tree structure, in conditional expression, pointer
 * to function returning an integer 
 */
{
	short           i = 3;

	if (dummy1(divide4, 4 * i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer * 2 / 2)) != 3)
		statusFlag++;
	return ii;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           ii;

	if ((ii = (*func) (integer * 2 / 2)) != 6)
		statusFlag++;
	return ii;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro236()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	short           i = 1;

	i = recursiveFunction(i + 0 - 0);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro237()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	short           i = 0;

	i = recursiveFunction(i + 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro238()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	short           i = 4;

	s = recursiveFunction(i / 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable * 2 / 2);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro239()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, return value, pointer to function returning
 * an integer 
 */
{
	short           i = 0;

	i = dummy(increment, ++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           result;

	if (--counter) {
		result = dummy(function, 1 * variable);
		if (result != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro240()
$LICENSE()
$HEAD()

int recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	short           i = -1;

	if (!(recursiveFunction(i + 2) + i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable)
{
	if (--counter)
		if (!(recursiveFunction(1 + variable - 1) - variable == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro241()
$LICENSE()
$HEAD()

short recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, function in conditional expression, integer
 * function declaration 
 */
{
	short           i = 0;

	if (recursiveFunction(i + 1) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable)
{
	if (--counter)
		if (recursiveFunction(variable + 1) - variable != 0)
			statusFlag++;
	return --variable;
}
@def_
@def $macro242()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	short           i = 2;

	if (!(*recursiveFunction(i + 1) == '3'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	if (--counter)
		if (!(*recursiveFunction(variable - 1 + 1) == '3'))
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro243()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           i = 1;

	if (!(dummy(increment, 2 * i / 2) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	if (--counter)
		if (!(dummy(function, 2 * variable / 2) == 2))
			statusFlag++;
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro244()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i = 0;

	i = castor(++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro245()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, legal, function declared to return an
 * integer 
 */
{
	short           i = 0;

	i = castor(++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro246()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s;
	short           i = 200;

	s = castor(i % 3);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	char           *s;

	if (--counter) {
		s = pollux(variable + 4);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	char           *s;

	if (--counter) {
		s = castor(variable - 4);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro247()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	short           i = 0;

	i = castor(increment, ++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           ii = 0;
	if (--counter) {
		ii = pollux(function, variable + 8);
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	short           iii = 0;
	if (--counter) {
		iii = castor(function, variable - 8);
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro248()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, no function declaration 
 */
{
	short           i = 0;

	if (!(castor(++i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	if (--counter) {
		if (!(pollux(variable + 3) == 5))
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	if (--counter) {
		if (!(castor(variable - 3) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro249()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	short           i = 0;

	if (!(castor(++i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	if (--counter) {
		if (!(pollux(variable + 3) == 5))
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	if (--counter) {
		if (!(castor(variable - 3) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro250()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	short           i = 0;

	if (!(*castor(i += 2) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	if (--counter) {
		if (!(*pollux(variable + 4) == '6'))
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	if (--counter) {
		if (!(*castor(variable - 4) == '2'))
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro251()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression (case 1) instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           i = 100;

	if (!(castor(increment, i - 99) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	if (--counter) {
		if (!(pollux(function, variable + 10) == 12))
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	if (--counter) {
		if (!(castor(function, variable - 10) == 2))
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro252()
$LICENSE()
$HEAD()

void levelOneNodeOne(char);
void levelOneNodeTwo(char);
void levelTwoNodeOne(char);
void levelTwoNodeTwo(char);
void levelTwoNodeThree(char);
void levelTwoNodeFour(char);
void levelThreeLeafOne(char);
void levelThreeLeafTwo(char);
void levelThreeLeafThree(char);
void levelThreeLeafFour(char);
void levelThreeLeafFive(char);
void levelThreeLeafSix(char);
void levelThreeLeafSeven(char);
void levelThreeLeafEight(char);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, no return value and legal 
 */
{
	char            i = 'a', j = 'b';

	levelOneNodeOne(++i);
	levelOneNodeTwo(++j);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

void levelOneNodeOne(char variable)
{
	if (variable != 'b')
		statusFlag++;
	levelTwoNodeOne(variable += 2);
	levelTwoNodeTwo(++variable);
}

void levelOneNodeTwo(char variable)
{
	if (variable != 'c')
		statusFlag++;
	levelTwoNodeThree(variable += 3);
	levelTwoNodeFour(++variable);
}

void levelTwoNodeOne(char variable)
{
	if (variable != 'd')
		statusFlag++;
	levelThreeLeafOne(variable += 4);
	levelThreeLeafTwo(++variable);
}

void levelTwoNodeTwo(char variable)
{
	if (variable != 'e')
		statusFlag++;
	levelThreeLeafThree(variable += 5);
	levelThreeLeafFour(++variable);
}

void levelTwoNodeThree(char variable)
{
	if (variable != 'f')
		statusFlag++;
	levelThreeLeafFive(variable += 6);
	levelThreeLeafSix(++variable);
}

void levelTwoNodeFour(char variable)
{
	if (variable != 'g')
		statusFlag++;
	levelThreeLeafSeven(variable += 7);
	levelThreeLeafEight(++variable);
}

void levelThreeLeafOne(char variable)
{
	if (variable != 'h')
		statusFlag++;
}

void levelThreeLeafTwo(char variable)
{
	if (variable != 'i')
		statusFlag++;
}

void levelThreeLeafThree(char variable)
{
	if (variable != 'j')
		statusFlag++;
}

void levelThreeLeafFour(char variable)
{
	if (variable != 'k')
		statusFlag++;
}

void levelThreeLeafFive(char variable)
{
	if (variable != 'l')
		statusFlag++;
}

void levelThreeLeafSix(char variable)
{
	if (variable != 'm')
		statusFlag++;
}

void levelThreeLeafSeven(char variable)
{
	if (variable != 'n')
		statusFlag++;
}

void levelThreeLeafEight(char variable)
{
	if (variable != 'o')
		statusFlag++;
}
@def_
@def $macro253()
$LICENSE()
$HEAD()

int levelOneNodeOne(char);
int levelOneNodeTwo(char);
int levelTwoNodeOne(char);
int levelTwoNodeTwo(unsigned);
int levelTwoNodeThree(char);
int levelTwoNodeFour(unsigned);
int levelThreeLeafOne(char);
int levelThreeLeafTwo(char);
int levelThreeLeafThree(char);
int levelThreeLeafFour(unsigned);
int levelThreeLeafFive(char);
int levelThreeLeafSix(char);
int levelThreeLeafSeven(char);
int levelThreeLeafEight(unsigned);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	char            i = 0;

	i = levelOneNodeOne(++i);
	if (i != 1)
		statusFlag++;
	i = levelOneNodeTwo(++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(char variable)
{
	char            storage = variable;

	variable = levelTwoNodeOne(variable += 2);
	if (variable != 3)
		statusFlag++;
	variable = levelTwoNodeTwo((unsigned) ++variable);
	if (variable != 4)
		statusFlag++;
	return (short) storage;
}

int levelOneNodeTwo(char variable)
{
	char            storage = variable;

	variable = levelTwoNodeThree(variable += 3);
	if (variable != 5)
		statusFlag++;
	variable = levelTwoNodeFour((unsigned) ++variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

int levelTwoNodeOne(char variable)
{
	char            storage = variable;

	variable = levelThreeLeafOne(variable += 4);
	if (variable != 7)
		statusFlag++;
	variable = levelThreeLeafTwo(++variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

int levelTwoNodeTwo(unsigned variable)
{
	unsigned        storage = variable;

	variable = levelThreeLeafThree((char) (variable += 5));
	if (variable != 9)
		statusFlag++;
	variable = levelThreeLeafFour(++variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

int levelTwoNodeThree(char variable)
{
	char            storage = variable;

	variable = levelThreeLeafFive(variable += 6);
	if (variable != 11)
		statusFlag++;
	variable = levelThreeLeafSix(++variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

int levelTwoNodeFour(unsigned variable)
{
	unsigned        storage = variable;

	variable = levelThreeLeafSeven((char) (variable += 7));
	if (variable != 13)
		statusFlag++;
	variable = levelThreeLeafEight(++variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

int levelThreeLeafOne(char variable)
{
	return variable;
}

int levelThreeLeafTwo(char variable)
{
	return variable;
}

int levelThreeLeafThree(char variable)
{
	return variable;
}

int levelThreeLeafFour(unsigned variable)
{
	return variable;
}

int levelThreeLeafFive(char variable)
{
	return variable;
}

int levelThreeLeafSix(char variable)
{
	return variable;
}

int levelThreeLeafSeven(char variable)
{
	return variable;
}

int levelThreeLeafEight(unsigned variable)
{
	return variable;
}
@def_
@def $macro254()
$LICENSE()
$HEAD()

short levelOneNodeOne(char);
short levelOneNodeTwo(char);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(char);
short levelThreeLeafTwo(char);
short levelThreeLeafThree(char);
short levelThreeLeafFour(char);
short levelThreeLeafFive(char);
short levelThreeLeafSix(char);
short levelThreeLeafSeven(char);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	short           i = 0;

	i = levelOneNodeOne((char) ++i);
	if (i != 1)
		statusFlag++;
	i = levelOneNodeTwo((char) ++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(char variable)
{
	short           storage = (short) variable;

	variable = levelTwoNodeOne(variable += 2);
	if (variable != 3)
		statusFlag++;
	variable = levelTwoNodeTwo(++variable);
	if (variable != 4)
		statusFlag++;
	return storage;
}

short levelOneNodeTwo(char variable)
{
	short           storage = (short) variable;

	variable = levelTwoNodeThree(variable += 3);
	if (variable != 5)
		statusFlag++;
	variable = levelTwoNodeFour(++variable);
	if (variable != 6)
		statusFlag++;
	return storage;
}

short levelTwoNodeOne(short variable)
{
	char            storage = (char) variable;

	variable = levelThreeLeafOne(variable += 4);
	if (variable != 7)
		statusFlag++;
	variable = levelThreeLeafTwo(++variable);
	if (variable != 8)
		statusFlag++;
	return storage;
}

short levelTwoNodeTwo(short variable)
{
	char            storage = (char) variable;

	variable = levelThreeLeafThree(variable += 5);
	if (variable != 9)
		statusFlag++;
	variable = levelThreeLeafFour(++variable);
	if (variable != 10)
		statusFlag++;
	return storage;
}

short levelTwoNodeThree(short variable)
{
	char            storage = (char) variable;

	variable = levelThreeLeafFive(variable += 6);
	if (variable != 11)
		statusFlag++;
	variable = levelThreeLeafSix(++variable);
	if (variable != 12)
		statusFlag++;
	return storage;
}

short levelTwoNodeFour(short variable)
{
	char            storage = (char) variable;

	variable = levelThreeLeafSeven(variable += 7);
	if (variable != 13)
		statusFlag++;
	variable = levelThreeLeafEight(++variable);
	if (variable != 14)
		statusFlag++;
	return storage;
}

short levelThreeLeafOne(char variable)
{
	return variable;
}

short levelThreeLeafTwo(char variable)
{
	return variable;
}

short levelThreeLeafThree(char variable)
{
	return variable;
}

short levelThreeLeafFour(char variable)
{
	return variable;
}

short levelThreeLeafFive(char variable)
{
	return variable;
}

short levelThreeLeafSix(char variable)
{
	return variable;
}

short levelThreeLeafSeven(char variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro255()
$LICENSE()
$HEAD()

char *levelOne(char, char*);
char *levelTwo(char, char*);
char *levelThree(char, char*);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	static char    *numbers = "0123456789";
	char            i = 0;

	s = levelOne(++i, numbers);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(char variable, char *numbers)
{
	char           *s;
	short           j = variable;

	if (variable != 1)
		statusFlag++;
	s = levelTwo(++j, numbers);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char *levelTwo(char variable, char *numbers)
{
	char           *s;
	short           k = variable;

	if (variable != 2)
		statusFlag++;
	s = levelThree(++k, numbers);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char *levelThree(char variable, char *numbers)
{
	char           *s;
	short           l;

	if (variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro256()
$LICENSE()
$HEAD()

int dummy1(unsigned (*) (short), unsigned);
unsigned divide4(short);
int dummy2(short (*) (short), unsigned);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	unsigned        i = 3;

	i = dummy1(divide4, i *= 4);
	if (i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(unsigned (*func) (short), unsigned integer)
{
	short           i = (short) integer;

	i = (*func) (i % 100);
	if (i != 3)
		statusFlag++;
	return i;
}

unsigned divide4(short integer)
{
	return dummy2(divide2, (unsigned) integer) / 2;
}

int dummy2(short (*func) (short), unsigned integer)
{
	short           i;

	i = (*func) ((short) integer);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro257()
$LICENSE()
$HEAD()

int levelOneNodeOne(char);
int levelOneNodeTwo(char);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(char);
int levelThreeLeafTwo(char);
int levelThreeLeafThree(char);
int levelThreeLeafFour(char);
int levelThreeLeafFive(char);
int levelThreeLeafSix(char);
int levelThreeLeafSeven(char);
int levelThreeLeafEight(char);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, used in conditional expression,
 * no function declaration 
 */
{
	char            i = 0, j = 0;

	if (levelOneNodeOne(i += 1) + levelOneNodeTwo(j += 2) != 44)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(char variable)
{
	short           i = 1, j = 2;
	return levelTwoNodeOne(i += variable) + levelTwoNodeTwo(j += variable);
}

int levelOneNodeTwo(char variable)
{
	short           i = 1, j = 2;
	return levelTwoNodeThree(i += variable) + levelTwoNodeFour(j += variable);
}

int levelTwoNodeOne(short variable)
{
	char            i = 1, j = 2;
	return levelThreeLeafOne(i += variable) + levelThreeLeafTwo(j += variable);
}

int levelTwoNodeTwo(short variable)
{
	char            i = 1, j = 2;
	return levelThreeLeafThree(i += variable) + levelThreeLeafFour(j += variable);
}

int levelTwoNodeThree(short variable)
{
	char            i = 1, j = 2;
	return levelThreeLeafFive(i += variable) + levelThreeLeafSix(j += variable);
}

int levelTwoNodeFour(short variable)
{
	char            i = 1, j = 2;
	return levelThreeLeafSeven(i += variable) + levelThreeLeafEight(j += variable);
}

int levelThreeLeafOne(char variable)
{
	return ++variable;
}

int levelThreeLeafTwo(char variable)
{
	return ++variable;
}

int levelThreeLeafThree(char variable)
{
	return ++variable;
}

int levelThreeLeafFour(char variable)
{
	return ++variable;
}

int levelThreeLeafFive(char variable)
{
	return ++variable;
}

int levelThreeLeafSix(char variable)
{
	return ++variable;
}

int levelThreeLeafSeven(char variable)
{
	return ++variable;
}

int levelThreeLeafEight(char variable)
{
	return ++variable;
}
@def_
@def $macro258()
$LICENSE()
$HEAD()

short levelOneNodeOne(unsigned);
short levelTwoNodeOne(unsigned);
short levelThreeLeafOne(unsigned);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	unsigned        i = 0;

	if (!(levelOneNodeOne(++i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(unsigned variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

short levelTwoNodeOne(unsigned variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

short levelThreeLeafOne(unsigned variable)
{
	return 2 * variable;
}
@def_
@def $macro259()
$LICENSE()
$HEAD()

char *skip(char, char*);
int compare(char*, char*, short);

int main(void)				/* alias root */
/*
 *  test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, used in conditional expression,
 * function declared to return a pointer to character 
 */
{
	static char    *protean = "cassandracross";
	char            i = 2, j = i;

	if (compare(skip(2 * i, protean), "andra", 5)
	    == compare(skip(4 * j, protean), "across", 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(char skipper, char *protean)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro260()
$LICENSE()
$HEAD()

int dummy1(short (*) (unsigned), unsigned);
short divide4(unsigned);
int dummy2(short (*) (unsigned), unsigned);
short divide2(unsigned);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : linear tree structure, in conditional expression, pointer
 * to function returning an integer 
 */
{
	unsigned        i = 3;

	if (dummy1(divide4, 4 * i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (unsigned), unsigned integer)
{
	short           ii;

	if ((ii = (*func) (integer * 2 / 2)) != 3)
		statusFlag++;
	return ii;
}

short divide4(unsigned integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (unsigned), unsigned integer)
{
	short           ii;

	if ((ii = (*func) (integer * 2 / 2)) != 6)
		statusFlag++;
	return ii;
}

short divide2(unsigned integer)
{
	return integer / 2;
}
@def_
@def $macro261()
$LICENSE()
$HEAD()

int recursiveFunction(char, short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, no return value, legal 
 */
{
	char            i = 'a';
	short           counter = 0;

	recursiveFunction(++i, counter += 10);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(char variable, short counter)
{
	if (variable != 'l' - counter)
		statusFlag++;
	if (--counter)
		recursiveFunction(++variable * 3 / 3, counter);
}
@def_
@def $macro262()
$LICENSE()
$HEAD()

int recursiveFunction(char, short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	char            i = 1;
	short           counter = 10;

	i = recursiveFunction(i + 0 - 0, counter);
	if (i != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(char variable, short counter)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2 + 1, counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro263()
$LICENSE()
$HEAD()

short recursiveFunction(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	unsigned        i = 0;

	i = recursiveFunction(i + 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(unsigned variable)
{
	short           result;

	if (--counter) {
		result = recursiveFunction(variable * 2 / 2);
		if (result != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro264()
$LICENSE()
$HEAD()

char *recursiveFunction(char, char*, short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, return value, function declared to return
 * a pointer to character 
 */
{
	char           *s;
	static char    *numbers = "0123456789";
	short           counter = 10;
	char            i = 4;

	s = recursiveFunction(i - 4, numbers, counter);
	if (*s != '0')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(char variable, char *numbers, short counter)
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable * 2 / 2 + 1, numbers, counter);
		if (*s != '0' + 10 - counter)
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro265()
$LICENSE()
$HEAD()

int recursiveFunction(char);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	char            i = 1;

	if (recursiveFunction(i) - i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(char variable)
{
	if (--counter)
		if (!(recursiveFunction(1 + variable - 1) - variable == 1))
			statusFlag++;
	return ++variable;
}
@def_
@def $macro266()
$LICENSE()
$HEAD()

short recursiveFunction(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	unsigned        i = 0;

	if (recursiveFunction(i + 1) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(unsigned variable)
{
	if (--counter)
		if (recursiveFunction(variable + 1) - variable != 2)
			statusFlag++;
	return ++variable;
}
@def_
@def $macro267()
$LICENSE()
$HEAD()

char *recursiveFunction(char, short);

short           statusFlag = NoMistake;
char           *numbers = "01234567890123456789";

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	short           counter = 10;
	char            i = 0;

	if (*recursiveFunction(i + 1, counter) != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(char variable, short counter)
{
	if (--counter)
		if (*recursiveFunction(2 * variable / 2, counter % 100) != '1')
			statusFlag++;
	return numbers + variable;
}
@def_
@def $macro268()
$LICENSE()
$HEAD()

int dummy(short (*) (char), char);
short increment(char);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	char            i = 1;

	if (!(dummy(increment, 2 * i / 2) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (char), char variable)
{
	if (--counter)
		if (!(dummy(function, 2 * variable / 2) == 2))
			statusFlag++;
	return function(variable);
}

short increment(char variable)
{
	return ++variable;
}
@def_
@def $macro269()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, return value, legal, no function declaration 
 */
{
	char            i = 0;

	i = castor(++i);
	if (i != 'B')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 'E')
			statusFlag++;
	}
	return 'A' + variable;
}

int pollux(short variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 'B')
			statusFlag++;
	}
	return 'A' + variable;
}
@def_
@def $macro270()
$LICENSE()
$HEAD()

short castor(unsigned);
short pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, return value, legal, function declared to return
 * an integer 
 */
{
	short           i = 0;

	i = castor((unsigned) ++i);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(unsigned variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(variable + 3);
		if (ii != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(unsigned variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(variable - 3);
		if (iii != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro271()
$LICENSE()
$HEAD()

char *castor(unsigned);
char *pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s;
	unsigned        i = 200;

	s = castor(i % 3);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(unsigned variable)
{
	char           *s;

	if (--counter) {
		s = pollux(variable + 4);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(unsigned variable)
{
	char           *s;

	if (--counter) {
		s = castor(variable - 4);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro272()
$LICENSE()
$HEAD()

int castor(char (*) (char), char, short);
int pollux(char (*) (char), char, short);
char increment(char);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	char            i = 0;
	short           counter = 10;

	i = castor(increment, ++i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(char (*function) (char), char variable, short counter)
{
	short           ii = 0;
	if (--counter) {
		ii = pollux(function, variable + 8, counter);
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(char (*function) (char), char variable, short counter)
{
	short           iii = 0;
	if (--counter) {
		iii = castor(function, variable - 8, counter);
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

char increment(char variable)
{
	return ++variable;
}
@def_
@def $macro273()
$LICENSE()
$HEAD()

int castor(short);
int pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	unsigned        i = 0;

	if (!!!(castor((short) ++i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	if (--counter) {
		if (!(pollux((unsigned) (variable + 3)) == 5))
			statusFlag++;
	}
	return ++variable;
}

int pollux(unsigned variable)
{
	if (--counter) {
		if (!(castor((short) (variable - 3)) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro274()
$LICENSE()
$HEAD()

short castor(unsigned);
short pollux(unsigned);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	unsigned short  i = 0;

	if (!(castor(++i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(unsigned variable)
{
	if (--counter) {
		if (!(pollux(variable + 3) == 5))
			statusFlag++;
	}
	return ++variable;
}

short pollux(unsigned variable)
{
	if (--counter) {
		if (!(castor(variable - 3) == 2))
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro275()
$LICENSE()
$HEAD()

char *castor(char, char*);
char *pollux(char, char*);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: simple arithmatic expression ( case 2 ) instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	static char    *numbers = "0123456789";
	char            i = '0';

	if (*castor(i += 2, numbers) - *numbers != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(char variable, char *numbers)
{
	short           i;
	char           *s = numbers;

	if (--counter) {
		if (*pollux(variable + 4, numbers) - *numbers != 6)
			statusFlag++;
	}
	for (i = 0; i < 10 && *s != variable; i++)
		s++;
	return numbers + i;
}

char *pollux(char variable, char *numbers)
{
	short           i;
	char           *s = numbers;

	if (--counter) {
		if (*castor(variable - 4, numbers) - *numbers != 2)
			statusFlag++;
	}
	for (i = 0; i < 10 && *s != variable; i++)
		s++;
	return numbers + i;
}
@def_
@def $macro276()
$LICENSE()
$HEAD()

int levelOneNodeOne(short);
int levelOneNodeTwo(short);
int levelTwoNodeOne(short);
int levelTwoNodeTwo(short);
int levelTwoNodeThree(short);
int levelTwoNodeFour(short);
int levelThreeLeafOne(short);
int levelThreeLeafTwo(short);
int levelThreeLeafThree(short);
int levelThreeLeafFour(short);
int levelThreeLeafFive(short);
int levelThreeLeafSix(short);
int levelThreeLeafSeven(short);
int levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value and
 * legal, no function declaration 
 */
{
	short           i = 0, j = -1, k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int levelOneNodeOne(short variable)
{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

int levelOneNodeTwo(short variable)
{
	short           i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

int levelTwoNodeOne(short variable)
{
	short           i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

int levelTwoNodeTwo(short variable)
{
	short           i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

int levelTwoNodeThree(short variable)
{
	short           i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

int levelTwoNodeFour(short variable)
{
	short           i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

int levelThreeLeafOne(short variable)
{
	return variable;
}

int levelThreeLeafTwo(short variable)
{
	return variable;
}

int levelThreeLeafThree(short variable)
{
	return variable;
}

int levelThreeLeafFour(short variable)
{
	return variable;
}

int levelThreeLeafFive(short variable)
{
	return variable;
}

int levelThreeLeafSix(short variable)
{
	return variable;
}

int levelThreeLeafSeven(short variable)
{
	return variable;
}

int levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro277()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelOneNodeTwo(short);
short levelTwoNodeOne(short);
short levelTwoNodeTwo(short);
short levelTwoNodeThree(short);
short levelTwoNodeFour(short);
short levelThreeLeafOne(short);
short levelThreeLeafTwo(short);
short levelThreeLeafThree(short);
short levelThreeLeafFour(short);
short levelThreeLeafFive(short);
short levelThreeLeafSix(short);
short levelThreeLeafSeven(short);
short levelThreeLeafEight(short);

short           statusFlag = NoMistake;

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value and
 * legal, integer function declaration 
 */
{
	short           i = 0, j = -1, k = 1;
	short           result = 0;

	result = levelOneNodeOne(i - 2 * j + (-k));
	if (result != 1)
		statusFlag++;
	result = levelOneNodeTwo((i + j) * j + k);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	short           result = 0;
	result = levelTwoNodeOne((variable == variable) * 2 + variable);
	if (result != 3)
		statusFlag++;
	result = levelTwoNodeTwo((variable != 2 * variable) * 3 + variable);
	if (result != 4)
		statusFlag++;
	return variable;
}

short levelOneNodeTwo(short variable)
{
	short           i = variable + 2;
	short           result = 0;
	result = levelTwoNodeThree((i + variable) / 2 + (!i != i) * 2);
	if (result != 5)
		statusFlag++;
	result = levelTwoNodeFour((i + variable + 2) / 2 - variable + i);
	if (result != 6)
		statusFlag++;
	return variable;
}

short levelTwoNodeOne(short variable)
{
	short           i = variable * 2;
	short           result = 0;
	result = levelThreeLeafOne((i += 8) / 2);
	if (result != 7)
		statusFlag++;
	result = levelThreeLeafTwo(variable + (i - 8) / variable + 3);
	if (result != 8)
		statusFlag++;
	return variable;
}

short levelTwoNodeTwo(short variable)
{
	short           i = variable;
	short           result = 0;
	result = levelThreeLeafThree((i++ + 2 * variable) / variable + 2 * (variable + 2) / 2);
	if (result != 9)
		statusFlag++;
	result = levelThreeLeafFour(2 * (variable + 3) - i + 1);
	if (result != 10)
		statusFlag++;
	return variable;
}

short levelTwoNodeThree(short variable)
{
	short           i = variable--;
	short           result = 0;
	result = levelThreeLeafFive((i + variable-- + 3) / 2 + 5);
	if (result != 11)
		statusFlag++;
	result = levelThreeLeafSix((i - variable) * 3 + 2 * i - variable - 1);
	if (result != 12)
		statusFlag++;
	return i;
}

short levelTwoNodeFour(short variable)
{
	short           i = variable / 2 - 1;
	short           result = 0;
	result = levelThreeLeafSeven(variable + i * (variable - i) - 1);
	if (result != 13)
		statusFlag++;
	result = levelThreeLeafEight(i * (2 * variable - i) - variable);
	if (result != 14)
		statusFlag++;
	return variable;
}

short levelThreeLeafOne(short variable)
{
	return variable;
}

short levelThreeLeafTwo(short variable)
{
	return variable;
}

short levelThreeLeafThree(short variable)
{
	return variable;
}

short levelThreeLeafFour(short variable)
{
	return variable;
}

short levelThreeLeafFive(short variable)
{
	return variable;
}

short levelThreeLeafSix(short variable)
{
	return variable;
}

short levelThreeLeafSeven(short variable)
{
	return variable;
}

short levelThreeLeafEight(short variable)
{
	return variable;
}
@def_
@def $macro278()
$LICENSE()
$HEAD()

char *levelOne(short, char*);
char *levelTwo(short, char*);
char *levelThree(short, char*);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 0, j = 1;
	static char    *numbers = "01234567890123456789";

	s = levelOne(j, &(numbers[j * (i + 1) * (i + 2) * (i + 3) + 4 * j]));
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *levelOne(short variable, char *numbers)
{
	char           *s;
	short           j = variable + 1;

	s = levelTwo(j, numbers - j * j * j - 2);
	if (*s != '2')
		statusFlag++;
	for (s = numbers, j = 0; j < variable; j++, s++);
	return s;
}

char *levelTwo(short variable, char *numbers)
{
	char           *s;
	short           k = variable + 1;

	s = levelThree(k, numbers + k * k + variable - 1);
	if (*s != '3')
		statusFlag++;
	for (s = numbers, k = 0; k < variable; k++, s++);
	return s;
}

char *levelThree(short variable, char *numbers)
{
	char           *s;
	short           l;

	for (s = numbers, l = 0; l < variable; l++, s++);
	return s;
}
@def_
@def $macro279()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, return value, legal
 * pointer to function returning an integer 
 */
{
	short           i = 3;
	short           result = 0;

	result = dummy1(divide4, ((i == 3) * i - 1) * i * (i - 1));
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           i = integer--;

	i = (*func) ((-1 + ++i + ++integer) / 2);
	if (i != 3)
		statusFlag++;
	return i;
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           i = integer++;

	i = (*func) ((-1 - --i - --integer) / -2);
	if (i != 6)
		statusFlag++;
	return i;
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro280()
$LICENSE()
$HEAD()

short levelOneNodeOne(short);
short levelTwoNodeOne(short);
short levelThreeLeafOne(short);

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	short           i = 1;
	short           counter = 0;

	while (levelOneNodeOne(i * (i + 1) * (i + 2) * (i + 3) - (i + 4) * (i + 3) - (i + 2)) != 32)
		counter++;
	if (!counter)
		printok();
	else
		printno();
	return 0;
}

short levelOneNodeOne(short variable)
{
	return 2 * levelTwoNodeOne(2 * variable);
}

short levelTwoNodeOne(short variable)
{
	return 2 * levelThreeLeafOne(2 * variable);
}

short levelThreeLeafOne(short variable)
{
	return 2 * variable;
}
@def_
@def $macro281()
$LICENSE()
$HEAD()

char *skip(short);
int compare(char*, char*, short);

char           *protean = "cassandracross";

int main(void)				/* alias root */
/*
 *  test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	short           i = 2, j = i;

	if (compare(skip(2 * i), &(protean[i * i]), 5)
	    == compare(skip(4 * j), &(protean[j * j * j]), 6))
		printok();
	else
		printno();
	return 0;
}

char *skip(short skipper)
{
	short           i;
	char           *pointer;

	for (i = 0, pointer = protean; i < skipper; i++)
		pointer++;
	return pointer;
}

int compare(char *s1, char *s2, short n)
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return n < 0 ? 0 : *s1 - *--s2;
}
@def_
@def $macro282()
$LICENSE()
$HEAD()

int dummy1(short (*) (short), short);
short divide4(short);
int dummy2(short (*) (short), short);
short divide2(short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : linear tree structure, in conditional
 * expression, pointer to function returning an integer 
 */
{
	short           i = 2;

	if (dummy1(divide4, (i - 1 << 3) + (i << 1)) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy1(short (*func) (short), short integer)
{
	short           i = integer % 3;

	return (*func) ((integer + i) * (2 + i) / (2 - i));
}

short divide4(short integer)
{
	return dummy2(divide2, integer) / 2;
}

int dummy2(short (*func) (short), short integer)
{
	short           i = integer + 1;

	return (*func) ((i + ++integer) / 2 - 1);
}

short divide2(short integer)
{
	return integer / 2;
}
@def_
@def $macro283()
$LICENSE()
$HEAD()

#ifndef TimeLimit
#define TimeLimit 10
#endif

int recursiveFunction(short, short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, no function
 * declaration 
 */
{
	short           i = 0, result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable, short counter)
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro284()
$LICENSE()
$HEAD()

#ifndef TimeLimit
#define TimeLimit 10
#endif

short recursiveFunction(short, short);

short           statusFlag = NoMistake;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, integer function
 * declaration 
 */
{
	short           i = 0, result = 0;
	short           counter = TimeLimit;

	result = recursiveFunction(i + 1 & i + 1, counter == TimeLimit ? counter : TimeLimit);
	if (result != 12 - counter)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable, short counter)
{
	short           result = 0;
	short           storage = variable + 1;

	if (counter) {
		result = recursiveFunction(variable > TimeLimit * 2 ? --variable : ++variable,
					   counter ? --counter : ++counter);
		if (result != 12 - counter)
			statusFlag++;
	}
	return storage;
}
@def_
@def $macro285()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

char *recursiveFunction(short, char*, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, function
 * declared to return a pointer to character 
 */
{
	char           *s;
	short           i = 4;
	short           counter = TimeLimit;
	static char    *numbers = "01234567890123456789";

	s = recursiveFunction(i + i / i * i - 6, &(numbers[i * i - i - i / 2]), counter);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable, char *numbers, short counter)
{
	char           *s;
	short           storage = variable;

	if (--counter) {
		s = recursiveFunction((storage + ++variable + 1) / 2 - 1,
				      counter % 2 ? numbers - 10 : &(numbers[10]), counter);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + storage;
}
@def_
@def $macro286()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int dummy(short (*) (short), short, short);
short increment(short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, return value, pointer to
 * function returning an integer 
 */
{
	short           i = 0;
	short           counter = TimeLimit;

	i = dummy(increment, i == 0 ? 3 % (i + 2) : 5 % i, counter);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable, short counter)
{
	short           result = 0;
	short           storage = variable;

	if (--counter) {
		result = dummy(function, (storage + ++variable + 1) / 2 - 1, counter);
		if (result != 2)
			statusFlag++;
	}
	return function(storage);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro287()
$LICENSE()
$HEAD()

int recursiveFunction(short, short);

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, function in conditional
 * expression, no function declaration 
 */
{
	short           i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int recursiveFunction(short variable, short counter)
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro288()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

short recursiveFunction(short, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, function in conditional
 * expression, integer function declaration 
 */
{
	short           i = -1;
	short           counter = TimeLimit;

	if (recursiveFunction((1 - i) / 2, counter) + i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short recursiveFunction(short variable, short counter)
{
	short           storage = variable;

	if (--counter)
		if (recursiveFunction((storage + --variable - 3) / 2 + 2, counter)
		    - storage != 1)
			statusFlag++;
	return ++storage;
}
@def_
@def $macro289()
$LICENSE()
$HEAD()

char *recursiveFunction(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, in conditional expression,
 * function declared to return a pointer to character 
 */
{
	short           i = 1, j = 3;

	if (*recursiveFunction((i == j + 1) * i + j) != '3')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *recursiveFunction(short variable)
{
	short           storage = variable;

	if (--counter)
		if (*recursiveFunction(++variable * 3 - storage * storage) != '3')
			statusFlag++;
	return numbers + storage;
}
@def_
@def $macro290()
$LICENSE()
$HEAD()

int dummy(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : recursive call, in conditional expression,
 * pointer to function returning an integer 
 */
{
	short           i = 2, j = 1;

	if (dummy(increment, j + i * j >= 10 || i - j > 0) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int dummy(short (*function) (short), short variable)
{
	short           storage = variable;

	if (--counter)
		if (dummy(function, (++variable - 1 == 0) + 1) != 2)
			statusFlag++;
	return function(storage);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro291()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

int castor(short, short);
int pollux(short, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, return value, no function declaration  
 */
{
	short           i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable, short counter)
{
	short           i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

int pollux(short variable, short counter)
{
	short           i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro292()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
#ifndef TimeLimit
#define TimeLimit 10
#endif

short castor(short, short);
short pollux(short, short);

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, return value, no function declaration  
 */
{
	short           i = 1, j = 2;
	short           counter = TimeLimit;
	short           result = 0;

	result = castor((i & i == i | i) + (j != i), counter);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable, short counter)
{
	short           i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = pollux((i & i == i) + (j == i), counter);
		if (result != 1)
			statusFlag++;
	}
	return variable;
}

short pollux(short variable, short counter)
{
	short           i = 1, j = 2;
	short           result = 0;

	if (--counter) {
		result = castor((i & i == i & i) + (j != i), counter);
		if (result != 2)
			statusFlag++;
	}
	return variable;
}
@def_
@def $macro293()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s;
	short           i = 1, j = 2, k = 3;

	s = castor((++i == j && ++j == k) * 2);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	char           *s;
	short           i = 4;

	if (--counter) {
		s = pollux(i / variable + i);
		if (*s != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	char           *s;
	short           i = 4;

	if (--counter) {
		s = castor(i * 3 / variable);
		if (*s != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro294()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, return value, pointer to function
 * returning an integer 
 */
{
	short           i = 0;

	i = castor(increment, i == 1 ? i : 1);
	if (i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	short           ii = 0;

	if (--counter) {
		ii = pollux(function, variable + 2 * (ii + 2) * (variable + 1));
		if (ii != 10)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	short           iii = 0;

	if (--counter) {
		iii = castor(function, variable - 2 * (iii + 2) * (11 - variable));
		if (iii != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_
@def $macro295()
$LICENSE()
$HEAD()

int castor(short);
int pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	short           i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short variable)
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

int pollux(short variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro296()
$LICENSE()
$HEAD()

short castor(short);
short pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	short           i = 0;

	if (castor(++i && ++i ? --i : i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

short castor(short variable)
{
	if (--counter) {
		if (pollux(2 * variable + 2 / variable) != 5)
			statusFlag++;
	}
	return ++variable;
}

short pollux(short variable)
{
	if (--counter) {
		if (castor(2 * variable - 7) != 2)
			statusFlag++;
	}
	return ++variable;
}
@def_
@def $macro297()
$LICENSE()
$HEAD()

char *castor(short);
char *pollux(short);

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	short           i = 1, j = 2;

	if (*castor((i << 1 == j) * 2) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

char *castor(short variable)
{
	if (--counter) {
		if (*pollux(variable << 1 | variable) != '6')
			statusFlag++;
	}
	return numbers + variable;
}

char *pollux(short variable)
{
	if (--counter) {
		if (*castor(variable >> 1 & variable) != '2')
			statusFlag++;
	}
	return numbers + variable;
}
@def_
@def $macro298()
$LICENSE()
$HEAD()

int castor(short (*) (short), short);
int pollux(short (*) (short), short);
short increment(short);

short           statusFlag = NoMistake;
short           counter = 10;

int main(void)
/*
 * test class: complex arithmatic and logical expression (case 1) instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           i = 1;

	if (castor(increment, (i << 1 | i) == i + 2) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return 0;
}

int castor(short (*function) (short), short variable)
{
	if (--counter) {
		if (pollux(function, (variable + 2) * 3 + variable * 2) != 12)
			statusFlag++;
	}
	return function(variable);
}

int pollux(short (*function) (short), short variable)
{
	if (--counter) {
		if (castor(function, (variable - 1) / 5 >> 1) != 2)
			statusFlag++;
	}
	return function(variable);
}

short increment(short variable)
{
	return ++variable;
}
@def_

@def $testout()
#ifdef unix
#include<stdio.h>
#include<float.h>
#define printok() printf("@OK@\n")
#define printno() printf("@NG@\n")
#define ABS(a) ((a > 0)? (a) : (-(a)))
#define MAX(a, b) ((a > b)? (a) : (b))
#define TGEN_FLT_EQ(a, b) ( ((a)==(b)) || ABS(((a) - (b))) / MAX( ABS(a), ABS(b) ) <= FLT_EPSILON )
#endif
@def_

@dir c89.4-2-05
@file >>def.h $macro0() @file_
@file >>fdef.h $macro1() @file_
@file >>ft2501.c $macro2() @file_
@file >>ft2502.c $macro3() @file_
@file >>ft2504.c $macro4() @file_
@file >>ft2506.c $macro5() @file_
@file >>ft2508.c $macro6() @file_
@file >>ft2510.c $macro7() @file_
@file >>ft2511.c $macro8() @file_
@file >>ft2512.c $macro9() @file_
@file >>ft2514.c $macro10() @file_
@file >>ft2516.c $macro11() @file_
@file >>ft2518.c $macro12() @file_
@file >>ft2520.c $macro13() @file_
@file >>ft2521.c $macro14() @file_
@file >>ft2522.c $macro15() @file_
@file >>ft2524.c $macro16() @file_
@file >>ft2526.c $macro17() @file_
@file >>ft2528.c $macro18() @file_
@file >>ft2530.c $macro19() @file_
@file >>ft2601.c $macro20() @file_
@file >>ft2602.c $macro21() @file_
@file >>ft2604.c $macro22() @file_
@file >>ft2606.c $macro23() @file_
@file >>ft2608.c $macro24() @file_
@file >>ft2610.c $macro25() @file_
@file >>ft2611.c $macro26() @file_
@file >>ft2612.c $macro27() @file_
@file >>ft2614.c $macro28() @file_
@file >>ft2616.c $macro29() @file_
@file >>ft2618.c $macro30() @file_
@file >>ft2620.c $macro31() @file_
@file >>ft2621.c $macro32() @file_
@file >>ft2622.c $macro33() @file_
@file >>ft2624.c $macro34() @file_
@file >>ft2626.c $macro35() @file_
@file >>ft2628.c $macro36() @file_
@file >>ft2630.c $macro37() @file_
@file >>ft2701.c $macro38() @file_
@file >>ft2702.c $macro39() @file_
@file >>ft2704.c $macro40() @file_
@file >>ft2706.c $macro41() @file_
@file >>ft2708.c $macro42() @file_
@file >>ft2710.c $macro43() @file_
@file >>ft2711.c $macro44() @file_
@file >>ft2714.c $macro45() @file_
@file >>ft2716.c $macro46() @file_
@file >>ft2718.c $macro47() @file_
@file >>ft2720.c $macro48() @file_
@file >>ft2721.c $macro49() @file_
@file >>ft2722.c $macro50() @file_
@file >>ft2724.c $macro51() @file_
@file >>ft2726.c $macro52() @file_
@file >>ft2728.c $macro53() @file_
@file >>ft2730.c $macro54() @file_
@file >>lt2501.c $macro55() @file_
@file >>lt2502.c $macro56() @file_
@file >>lt2504.c $macro57() @file_
@file >>lt2506.c $macro58() @file_
@file >>lt2508.c $macro59() @file_
@file >>lt2510.c $macro60() @file_
@file >>lt2511.c $macro61() @file_
@file >>lt2512.c $macro62() @file_
@file >>lt2514.c $macro63() @file_
@file >>lt2516.c $macro64() @file_
@file >>lt2518.c $macro65() @file_
@file >>lt2520.c $macro66() @file_
@file >>lt2521.c $macro67() @file_
@file >>lt2522.c $macro68() @file_
@file >>lt2524.c $macro69() @file_
@file >>lt2526.c $macro70() @file_
@file >>lt2528.c $macro71() @file_
@file >>lt2530.c $macro72() @file_
@file >>lt2601.c $macro73() @file_
@file >>lt2602.c $macro74() @file_
@file >>lt2604.c $macro75() @file_
@file >>lt2606.c $macro76() @file_
@file >>lt2608.c $macro77() @file_
@file >>lt2610.c $macro78() @file_
@file >>lt2611.c $macro79() @file_
@file >>lt2612.c $macro80() @file_
@file >>lt2614.c $macro81() @file_
@file >>lt2616.c $macro82() @file_
@file >>lt2618.c $macro83() @file_
@file >>lt2620.c $macro84() @file_
@file >>lt2621.c $macro85() @file_
@file >>lt2622.c $macro86() @file_
@file >>lt2624.c $macro87() @file_
@file >>lt2626.c $macro88() @file_
@file >>lt2628.c $macro89() @file_
@file >>lt2630.c $macro90() @file_
@file >>lt2701.c $macro91() @file_
@file >>lt2702.c $macro92() @file_
@file >>lt2704.c $macro93() @file_
@file >>lt2706.c $macro94() @file_
@file >>lt2708.c $macro95() @file_
@file >>lt2710.c $macro96() @file_
@file >>lt2711.c $macro97() @file_
@file >>lt2714.c $macro98() @file_
@file >>lt2716.c $macro99() @file_
@file >>lt2718.c $macro100() @file_
@file >>lt2720.c $macro101() @file_
@file >>lt2721.c $macro102() @file_
@file >>lt2722.c $macro103() @file_
@file >>lt2724.c $macro104() @file_
@file >>lt2726.c $macro105() @file_
@file >>lt2728.c $macro106() @file_
@file >>lt2730.c $macro107() @file_
@file >>lt2801.c $macro108() @file_
@file >>lt2802.c $macro109() @file_
@file >>lt2806.c $macro110() @file_
@file >>lt2808.c $macro111() @file_
@file >>lt2810.c $macro112() @file_
@file >>lt2811.c $macro113() @file_
@file >>lt2812.c $macro114() @file_
@file >>lt2814.c $macro115() @file_
@file >>lt2816.c $macro116() @file_
@file >>lt2818.c $macro117() @file_
@file >>lt2820.c $macro118() @file_
@file >>lt2821.c $macro119() @file_
@file >>lt2822.c $macro120() @file_
@file >>lt2824.c $macro121() @file_
@file >>lt2826.c $macro122() @file_
@file >>lt2828.c $macro123() @file_
@file >>lt2830.c $macro124() @file_
@file >>lt2902.c $macro125() @file_
@file >>lt2906.c $macro126() @file_
@file >>lt2908.c $macro127() @file_
@file >>lt2910.c $macro128() @file_
@file >>lt2912.c $macro129() @file_
@file >>lt2914.c $macro130() @file_
@file >>lt2916.c $macro131() @file_
@file >>lt2918.c $macro132() @file_
@file >>lt2920.c $macro133() @file_
@file >>lt2921.c $macro134() @file_
@file >>lt2922.c $macro135() @file_
@file >>lt2924.c $macro136() @file_
@file >>lt2928.c $macro137() @file_
@file >>lt2930.c $macro138() @file_
@file >>lt3001.c $macro139() @file_
@file >>lt3002.c $macro140() @file_
@file >>lt3004.c $macro141() @file_
@file >>lt3006.c $macro142() @file_
@file >>lt3008.c $macro143() @file_
@file >>lt3010.c $macro144() @file_
@file >>lt3011.c $macro145() @file_
@file >>lt3012.c $macro146() @file_
@file >>lt3014.c $macro147() @file_
@file >>lt3016.c $macro148() @file_
@file >>lt3018.c $macro149() @file_
@file >>lt3020.c $macro150() @file_
@file >>lt3021.c $macro151() @file_
@file >>lt3022.c $macro152() @file_
@file >>lt3026.c $macro153() @file_
@file >>lt3028.c $macro154() @file_
@file >>lt3030.c $macro155() @file_
@file >>t2503.c $macro156() @file_
@file >>t2504.c $macro157() @file_
@file >>t2505.c $macro158() @file_
@file >>t2506.c $macro159() @file_
@file >>t2507.c $macro160() @file_
@file >>t2508.c $macro161() @file_
@file >>t2509.c $macro162() @file_
@file >>t2510.c $macro163() @file_
@file >>t2513.c $macro164() @file_
@file >>t2514.c $macro165() @file_
@file >>t2515.c $macro166() @file_
@file >>t2516.c $macro167() @file_
@file >>t2517.c $macro168() @file_
@file >>t2518.c $macro169() @file_
@file >>t2519.c $macro170() @file_
@file >>t2520.c $macro171() @file_
@file >>t2523.c $macro172() @file_
@file >>t2524.c $macro173() @file_
@file >>t2525.c $macro174() @file_
@file >>t2526.c $macro175() @file_
@file >>t2527.c $macro176() @file_
@file >>t2528.c $macro177() @file_
@file >>t2529.c $macro178() @file_
@file >>t2530.c $macro179() @file_
@file >>t2603.c $macro180() @file_
@file >>t2604.c $macro181() @file_
@file >>t2605.c $macro182() @file_
@file >>t2606.c $macro183() @file_
@file >>t2607.c $macro184() @file_
@file >>t2608.c $macro185() @file_
@file >>t2609.c $macro186() @file_
@file >>t2610.c $macro187() @file_
@file >>t2613.c $macro188() @file_
@file >>t2614.c $macro189() @file_
@file >>t2615.c $macro190() @file_
@file >>t2616.c $macro191() @file_
@file >>t2617.c $macro192() @file_
@file >>t2618.c $macro193() @file_
@file >>t2619.c $macro194() @file_
@file >>t2620.c $macro195() @file_
@file >>t2623.c $macro196() @file_
@file >>t2624.c $macro197() @file_
@file >>t2625.c $macro198() @file_
@file >>t2626.c $macro199() @file_
@file >>t2627.c $macro200() @file_
@file >>t2628.c $macro201() @file_
@file >>t2629.c $macro202() @file_
@file >>t2630.c $macro203() @file_
@file >>t2703.c $macro204() @file_
@file >>t2704.c $macro205() @file_
@file >>t2705.c $macro206() @file_
@file >>t2706.c $macro207() @file_
@file >>t2707.c $macro208() @file_
@file >>t2708.c $macro209() @file_
@file >>t2709.c $macro210() @file_
@file >>t2710.c $macro211() @file_
@file >>t2713.c $macro212() @file_
@file >>t2714.c $macro213() @file_
@file >>t2715.c $macro214() @file_
@file >>t2716.c $macro215() @file_
@file >>t2717.c $macro216() @file_
@file >>t2718.c $macro217() @file_
@file >>t2719.c $macro218() @file_
@file >>t2720.c $macro219() @file_
@file >>t2723.c $macro220() @file_
@file >>t2724.c $macro221() @file_
@file >>t2725.c $macro222() @file_
@file >>t2726.c $macro223() @file_
@file >>t2727.c $macro224() @file_
@file >>t2728.c $macro225() @file_
@file >>t2729.c $macro226() @file_
@file >>t2730.c $macro227() @file_
@file >>t2803.c $macro228() @file_
@file >>t2804.c $macro229() @file_
@file >>t2805.c $macro230() @file_
@file >>t2806.c $macro231() @file_
@file >>t2807.c $macro232() @file_
@file >>t2808.c $macro233() @file_
@file >>t2809.c $macro234() @file_
@file >>t2810.c $macro235() @file_
@file >>t2813.c $macro236() @file_
@file >>t2814.c $macro237() @file_
@file >>t2815.c $macro238() @file_
@file >>t2816.c $macro239() @file_
@file >>t2817.c $macro240() @file_
@file >>t2818.c $macro241() @file_
@file >>t2819.c $macro242() @file_
@file >>t2820.c $macro243() @file_
@file >>t2823.c $macro244() @file_
@file >>t2824.c $macro245() @file_
@file >>t2825.c $macro246() @file_
@file >>t2826.c $macro247() @file_
@file >>t2827.c $macro248() @file_
@file >>t2828.c $macro249() @file_
@file >>t2829.c $macro250() @file_
@file >>t2830.c $macro251() @file_
@file >>t2901.c $macro252() @file_
@file >>t2903.c $macro253() @file_
@file >>t2904.c $macro254() @file_
@file >>t2905.c $macro255() @file_
@file >>t2906.c $macro256() @file_
@file >>t2907.c $macro257() @file_
@file >>t2908.c $macro258() @file_
@file >>t2909.c $macro259() @file_
@file >>t2910.c $macro260() @file_
@file >>t2911.c $macro261() @file_
@file >>t2913.c $macro262() @file_
@file >>t2914.c $macro263() @file_
@file >>t2915.c $macro264() @file_
@file >>t2917.c $macro265() @file_
@file >>t2918.c $macro266() @file_
@file >>t2919.c $macro267() @file_
@file >>t2920.c $macro268() @file_
@file >>t2923.c $macro269() @file_
@file >>t2924.c $macro270() @file_
@file >>t2925.c $macro271() @file_
@file >>t2926.c $macro272() @file_
@file >>t2927.c $macro273() @file_
@file >>t2928.c $macro274() @file_
@file >>t2929.c $macro275() @file_
@file >>t3003.c $macro276() @file_
@file >>t3004.c $macro277() @file_
@file >>t3005.c $macro278() @file_
@file >>t3006.c $macro279() @file_
@file >>t3008.c $macro280() @file_
@file >>t3009.c $macro281() @file_
@file >>t3010.c $macro282() @file_
@file >>t3013.c $macro283() @file_
@file >>t3014.c $macro284() @file_
@file >>t3015.c $macro285() @file_
@file >>t3016.c $macro286() @file_
@file >>t3017.c $macro287() @file_
@file >>t3018.c $macro288() @file_
@file >>t3019.c $macro289() @file_
@file >>t3020.c $macro290() @file_
@file >>t3023.c $macro291() @file_
@file >>t3024.c $macro292() @file_
@file >>t3025.c $macro293() @file_
@file >>t3026.c $macro294() @file_
@file >>t3027.c $macro295() @file_
@file >>t3028.c $macro296() @file_
@file >>t3029.c $macro297() @file_
@file >>t3030.c $macro298() @file_
@file >>testout.h $testout() @file_
@dir_
