@comment
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
ishiura-gcc@ksc.kwansei.ac.jp

This file was written by Yuki Uchiyama. (ishiura-gcc@ksc.kwansei.ac.jp)
@comment_

@def $LICENSE()
/*
  Copyright (C) 2005 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA

Please email any bugs, comments, and/or additions to this file to:
hikichi@sra.co.jp(Nobuyuki Hikichi)

This file was written by several people in Software Research Associates,
Inc. Japan in several years.
*/
@def_

@def $HEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "def.h"
@def_

@def $FHEAD()
#ifdef SYSDEP_H
#include "sysdep.h"
#endif
#include "fdef.h"
@def_

@def $macro0()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
#define NoMistake 00
@def_

@def $macro1()
$LICENSE()
#include "testout.h"
long            NO = 0;
long            OK = 1;
float           OK_f = 1.0;
float           NO_f = 0.0;
#define NoMistake 00
@def_

@def $macro2()
$LICENSE()
$FHEAD()
short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, no return value and legal 
 */
{
	float           i;

	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	(*variable) = 3.0;
	levelTwoNodeOne(variable);
	(*variable) = 4.0;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	(*variable) = 5.0;
	levelTwoNodeThree(variable);
	(*variable) = 6.0;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 3.0)) )
		statusFlag++;
	(*variable) = 7.0;
	levelThreeLeafOne(variable);
	(*variable) = 8.0;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 4.0)) )
		statusFlag++;
	(*variable) = 9.0;
	levelThreeLeafThree(variable);
	(*variable) = 10.0;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 5.0)) )
		statusFlag++;
	(*variable) = 11.0;
	levelThreeLeafFive(variable);
	(*variable) = 12.0;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 6.0)) )
		statusFlag++;
	(*variable) = 13.0;
	levelThreeLeafSeven(variable);
	(*variable) = 14.0;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 14.0)) )
		statusFlag++;
}
@def_
@def $macro3()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, no return value and illegal 
 */
{
	float           i, result;

	i = 1.0;
	result = levelOneNodeOne(&i);
	i = 2.0;
	result = levelOneNodeTwo(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	(*variable) = 3.0;
	result = levelTwoNodeOne(variable);
	(*variable) = 4.0;
	result = levelTwoNodeTwo(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	(*variable) = 5.0;
	result = levelTwoNodeThree(variable);
	(*variable) = 6.0;
	result = levelTwoNodeFour(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 3.0)) )
		statusFlag++;
	(*variable) = 7.0;
	result = levelThreeLeafOne(variable);
	(*variable) = 8.0;
	result = levelThreeLeafTwo(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 4.0)) )
		statusFlag++;
	(*variable) = 9.0;
	result = levelThreeLeafThree(variable);
	(*variable) = 10.0;
	result = levelThreeLeafFour(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 5.0)) )
		statusFlag++;
	(*variable) = 11.0;
	result = levelThreeLeafFive(variable);
	(*variable) = 12.0;
	result = levelThreeLeafSix(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
	float           result;

 	if ( !(TGEN_FLT_EQ(*variable, 6.0)) )
		statusFlag++;
	(*variable) = 13.0;
	result = levelThreeLeafSeven(variable);
	(*variable) = 14.0;
	result = levelThreeLeafEight(variable);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 7.0)) )
		statusFlag++;
	return;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 8.0)) )
		statusFlag++;
	return;
}

levelThreeLeafThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 9.0)) )
		statusFlag++;
	return;
}

levelThreeLeafFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 10.0)) )
		statusFlag++;
	return;
}

levelThreeLeafFive(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 11.0)) )
		statusFlag++;
	return;
}

levelThreeLeafSix(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 12.0)) )
		statusFlag++;
	return;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 13.0)) )
		statusFlag++;
	return;
}

levelThreeLeafEight(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable++, 14.0)) )
		statusFlag++;
	return;
}
@def_
@def $macro4()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, return value and legal, Float function
 * declaration 
 */
{
	float           i = 0, result = 0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	i = 1.0;
	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3.0;
	result = levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	(*variable) = 4.0;
	result = levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return (storage);
}

float 
levelOneNodeTwo(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5.0;
	result = levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	(*variable) = 6.0;
	result = levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7.0;
	result = levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	(*variable) = 8.0;
	result = levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeTwo(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9.0;
	result = levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	(*variable) = 10.0;
	result = levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeThree(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11.0;
	result = levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	(*variable) = 12.0;
	result = levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeFour(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13.0;
	result = levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	(*variable) = 14.0;
	result = levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return (storage);
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafTwo(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafThree(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafFour(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafFive(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafSix(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafSeven(variable)
	float          *variable;
{
	return (*variable);
}

float 
levelThreeLeafEight(variable)
	float          *variable;
{
	return (*variable);
}
@def_
@def $macro5()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, return value, legal pointer to function
 * returning an Float 
 */
{
	float           i, result = 0.0, divide4(), dummy1();

	i = 12.0;
	result = dummy1(divide4, &i);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	return (*Float / 2);
}
@def_
@def $macro6()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	float           i = 1.0, levelOneNodeOne();
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           ii, levelTwoNodeOne();

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           iii, levelThreeLeafOne();

	iii = 2 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro7()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an Float 
 */
{
	float           i, divide4(), dummy1();
	float           arg_a, arg_b;

	i = 12.0;
	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	return (*Float / 2);
}
@def_
@def $macro8()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, no return value, legal 
 */
{
	float           i;

	i = 1.0;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro9()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           whatIsThis;

main()
/*
 * test class: automatic variable address instance  : recursive call, no return value, illegal 
 */
{
	float           i = 1.0;

	whatIsThis = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		whatIsThis = recursiveFunction(variable);
		if (TGEN_FLT_EQ(whatIsThis, 0.0) )
			whatIsThis++;
	}
	return;
}
@def_
@def $macro10()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, legal, Float function declaration 
 */
{
	float           i = 1.0, result = 0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           i = *variable, result = 0;
	float           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(&i);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro11()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, pointer to function returning an Float 
 */
{
	float           i = 1.0, result = 0, increment(), dummy();

	result = dummy(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result, dummy();

	if (--counter) {
		result = dummy(function, variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro12()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	float           recursiveFunction();
	float           i = 1.0;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 1.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           recursiveFunction();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(variable) - *variable;
		arg_b = 1.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ((*variable) + 1);
}
@def_
@def $macro13()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, in conditional expression, pointer to function
 * returning an Float 
 */
{
	float           increment();
	float           i = 1.0, dummy();
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           dummy();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, variable);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro14()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, no return value, legal 
 */
{
	float           i = 1.0;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	float           i = *variable;

 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	float          *variable;
{
	float           i = *variable;

 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro15()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, legal, function declared to return an Float 
 */
{
	float           i = 1.0, result = 0, castor();

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, result = 0.0, pollux();

	if (--counter) {
		result = pollux(&ii);
 if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return (*variable + 1);
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, result = 0.0, castor();

	if (--counter) {
		result = castor(&iii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro16()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, pointer to function returning an Float 
 */
{
	float           i = 1.0, result = 0.0, increment(), castor();

	result = castor(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 8, result = 0.0, pollux();
	if (--counter) {
		result = pollux(function, &ii);
 if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 8, result = 0.0, castor();
	if (--counter) {
		result = castor(function, &iii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro17()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, function declared to return an
 * Float 
 */
{
	float           i = 1.0, castor();
	float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, pollux();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (++(*variable));
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, castor();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro18()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, pointer to function returning an
 * Float 
 */
{
	float           i = 1.0, increment(), castor();
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 10, pollux();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 12.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 10, castor();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro19()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	float           i;

	i = 1.0;
	levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	(*variable) = 3.0;
	levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 4.0;
	levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
	(*variable) = 5.0;
	levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 6.0;
	levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
	(*variable) = 7.0;
	levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 8.0;
	levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	(*variable) = 9.0;
	levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 10.0;
	levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
	(*variable) = 11.0;
	levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 12.0;
	levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
	(*variable) = 13.0;
	levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 14.0;
	levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	(*variable) = 0.0;
}
@def_
@def $macro20()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           result;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	float           i;

	i = 1.0;
	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	*variable = 3.0;
	result = levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	*variable = 5.0;
	result = levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 3.0)) )
		statusFlag++;
	*variable = 7.0;
	result = levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 4.0)) )
		statusFlag++;
	*variable = 9.0;
	result = levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 5.0)) )
		statusFlag++;
	*variable = 11.0;
	result = levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 6.0)) )
		statusFlag++;
	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	*variable = 0.0;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	*variable = 0.0;
}
@def_
@def $macro21()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, return value and legal,
 * Float function declaration 
 */
{
	float           i = 0, result = 0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	i = 1.0;
	result = levelOneNodeOne(&i);
	if ( (! TGEN_FLT_EQ(result, 1.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3.0;
	result = levelTwoNodeOne(variable);
	if ( (! TGEN_FLT_EQ(result, 3.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 4.0;
	result = levelTwoNodeTwo(variable);
	if ( (! TGEN_FLT_EQ(result, 4.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return (storage);
}

float 
levelOneNodeTwo(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5.0;
	result = levelTwoNodeThree(variable);
	if ( (! TGEN_FLT_EQ(result, 5.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 6.0;
	result = levelTwoNodeFour(variable);
	if ( (! TGEN_FLT_EQ(result, 6.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7.0;
	result = levelThreeLeafOne(variable);
	if ( (! TGEN_FLT_EQ(result, 7.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 8.0;
	result = levelThreeLeafTwo(variable);
	if ( (! TGEN_FLT_EQ(result, 8.0)) || (! TGEN_FLT_EQ(*variable, 0.0) ))
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeTwo(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9.0;
	result = levelThreeLeafThree(variable);
	if ( (! TGEN_FLT_EQ(result, 9.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 10.0;
	result = levelThreeLeafFour(variable);
	if ( (! TGEN_FLT_EQ(result, 10.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeThree(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11.0;
	result = levelThreeLeafFive(variable);
	if ( (! TGEN_FLT_EQ(result, 11.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 12.0;
	result = levelThreeLeafSix(variable);
	if ( (! TGEN_FLT_EQ(result, 12.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeFour(variable)
	float          *variable;
{
	float           storage = (*variable), result = 0.0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13.0;
	result = levelThreeLeafSeven(variable);
	if ( (! TGEN_FLT_EQ(result, 13.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 14.0;
	result = levelThreeLeafEight(variable);
	if ( (! TGEN_FLT_EQ(result, 14.0)) || (! TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	return (storage);
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafTwo(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafThree(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafFour(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafFive(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafSix(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafSeven(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}

float 
levelThreeLeafEight(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (i);
}
@def_
@def $macro22()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning an Float 
 */
{
	float           i, result = 0.0, divide4(), dummy1();

	i = 12.0;
	result = dummy1(divide4, &i);
	if ( (! TGEN_FLT_EQ(result, 3.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
	if ( (! TGEN_FLT_EQ(i, 3.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
	if ( (! TGEN_FLT_EQ(i, 6.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2);
}
@def_
@def $macro23()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Float function declaration 
 */
{
	float           i = 1.0, levelOneNodeOne();
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           levelTwoNodeOne();

	(*variable) *= 2.0;
	return (2 * levelTwoNodeOne(variable));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           levelThreeLeafOne();

	(*variable) *= 2.0;
	return (2 * levelThreeLeafOne(variable));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (2 * i);
}
@def_
@def $macro24()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning an Float 
 */
{
	float           i = 12.0, divide4(), dummy1();
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if ( (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if ( (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2);
}
@def_
@def $macro25()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	float           i = 10.0;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	float           fdata;

 	if ( !(TGEN_FLT_EQ(*variable, (float) counter)) )
		statusFlag++;

	(*variable) -= 1.0;
	if (--counter)
		recursiveFunction(variable);

}
@def_
@def $macro26()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           whatIsThis;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	float           i = 10.0;

	whatIsThis = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(whatIsThis, 0.0) )
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	if (--counter) {
 if ( !(TGEN_FLT_EQ(counter, --(*variable))) )
			statusFlag++;
		whatIsThis = recursiveFunction(variable);
		if (TGEN_FLT_EQ(whatIsThis, 0.0) )
			whatIsThis++;
	}
	return;
}
@def_
@def $macro27()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	float           i = 1.0, result = 0.0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, i)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           result = 0;
	float           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
 if ( !(TGEN_FLT_EQ(result, *variable)) )
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro28()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning an Float 
 */
{
	float           i = 1.0, result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result, i = *variable, dummy();

	if (--counter) {
		result = dummy(function, &i);
		if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
			statusFlag++;
	}
	return (function((*variable) -= 1.0) + 1.0);
}

float 
increment(variable)
	float           variable;
{
	return (variable += 1.0);
}
@def_
@def $macro29()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 3;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Float function declaration 
 */
{
	float           recursiveFunction();
	float           i = 1.0;
	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           i = *variable, recursiveFuncton();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(&i) - i;
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}

	return (((*variable) -= 1.0) + 2.0);

}
@def_
@def $macro30()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning an Float 
 */
{
	float           increment();
	float           i = 1.0, dummy();
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i) - i;
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           i = *variable, dummy();
	float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, &i) - i;
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (function((*variable) -= 1.0) + 1.0);
}

float 
increment(variable)
	float           variable;
{
	return (variable += 1.0);
}
@def_
@def $macro31()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	float           i = 1.0;

	castor(&i);
 	if (! TGEN_FLT_EQ(i, 0.0))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	float           i = *variable;

 	if (! TGEN_FLT_EQ(*variable, 1.0))
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if (! TGEN_FLT_EQ(i, 3.0) )
			statusFlag++;
	}
	(*variable) -= 1.0;
}

pollux(variable)
	float          *variable;
{
	float           i = *variable;

 	if (! TGEN_FLT_EQ(*variable, 2.0) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if (! TGEN_FLT_EQ(i, 0.0) )
			statusFlag++;
	}
	(*variable) += 1.0;
}
@def_
@def $macro32()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	float           i = 1.0;

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	float           i = *variable;

	if (--counter) {
		result = pollux(&i);
		if (! TGEN_FLT_EQ(i, 2.0) )
			statusFlag++;
	}
	(*variable) -= 1.0;
}

pollux(variable)
	float          *variable;
{
	float           i = *variable;

	if (--counter) {
		result = castor(&i);
		if (! TGEN_FLT_EQ(i, 0.0) )
			statusFlag++;
	}
	(*variable) += 1.0;
}
@def_
@def $macro33()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an Float 
 */
{
	float           i = 1.0, result = 0.0, castor();

	result = castor(&i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, result = 0.0, pollux();

	if (--counter) {
		result = pollux(&ii);
		if ( (! TGEN_FLT_EQ(result, 5.0)) || (! TGEN_FLT_EQ(ii, 3.0)) )
			statusFlag++;
	}
	return (++(*variable));
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, result = 0.0, castor();

	if (--counter) {
		result = castor(&iii);
		if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(iii, 2.0)) )
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro34()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * an Float 
 */
{
	float           i = 1.0, result = 0.0, increment(), castor();

	result = castor(increment, &i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 8, result = 0.0, pollux();
	if (--counter) {
		result = pollux(function, &ii);
		if ( (! TGEN_FLT_EQ(result, 10.0)) || (! TGEN_FLT_EQ(ii, 0.0)) )
			statusFlag++;
	}
	return (function(variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 8, result = 0.0, castor();
	if (--counter) {
		result = castor(function, &iii);
		if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(iii, 0.0)) )
			statusFlag++;
	}
	return (function(variable));
}

float 
increment(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (++i);
}
@def_
@def $macro35()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, function
 * declared to return an Float 
 */
{
	float           i = 1.0, castor();
	float           arg_a, arg_b;

	arg_a = castor(&i) - i;
	arg_b = 0.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, pollux();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(&ii) - ii;
		arg_b = 0.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++(*variable));
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, castor();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(&iii) - iii;
		arg_b = 0.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro36()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning an Float 
 */
{
	float           i = 1.0, increment(), castor();
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 10, pollux();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 12.0;
		if ( (!TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(ii, 10.0)) )
			statusFlag++;
	}
	return (function(variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 10, castor();
	float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(iii, 0.0)) )
			statusFlag++;
	}
	return (function(variable));
}

float 
increment(variable)
	float          *variable;
{
	return (--(*variable) + 2);
}
@def_
@def $macro37()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	float           i;

	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	*variable = 3.0;
	levelTwoNodeOne(variable);
	*variable = 4.0;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	float          *variable;
{
	*variable = 5.0;
	levelTwoNodeThree(variable);
	*variable = 6.0;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	float          *variable;
{
	*variable = 7.0;
	levelThreeLeafOne(variable);
	*variable = 8.0;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	*variable = 9.0;
	levelThreeLeafThree(variable);
	*variable = 10;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	float          *variable;
{
	*variable = 11.0;
	levelThreeLeafFive(variable);
	*variable = 12.0;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	float          *variable;
{
	*variable = 13.0;
	levelThreeLeafSeven(variable);
	*variable = 14.0;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0 )
		statusFlag++;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)	
		statusFlag++;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro38()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           result;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	float           i;

	i = 1.0;
	result = levelOneNodeOne(&i);
	i = 2.0;
	result = levelOneNodeTwo(&i);
	if (! TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	*variable = 3.0;
	result = levelTwoNodeOne(variable);
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
	*variable = 5.0;
	result = levelTwoNodeThree(variable);
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
	*variable = 7.0;
	result = levelThreeLeafOne(variable);
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	*variable = 9.0;
	result = levelThreeLeafThree(variable);
	*variable = 10;
	result = levelThreeLeafFour(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
	*variable = 11.0;
	result = levelThreeLeafFive(variable);
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro39()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, return value and legal, Float
 * function declaration 
 */
{
	float           i = 1.0, result = 0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3.0;
	result = levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return (storage);
}

float 
levelOneNodeTwo(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5.0;
	result = levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7.0;
	result = levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeTwo(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9.0;
	result = levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeThree(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11.0;
	result = levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeFour(variable)
	float          *variable;
{
	float           storage = *variable, result = 0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return (storage);
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafTwo(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafThree(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafFour(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafFive(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafSix(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafSeven(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafEight(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}
@def_
@def $macro40()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning an Float 
 */
{
	float           i, result = 0.0, divide4(), dummy1();

	i = 12.0;
	result = dummy1(divide4, &i);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2);
}
@def_
@def $macro41()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * Float function declaration 
 */
{
	float           i = 1.0, levelOneNodeOne();
	float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           levelTwoNodeOne();
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return (2 * levelTwoNodeOne(&i));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           levelThreeLeafOne();
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return (2 * levelThreeLeafOne(&i));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (2 * i);
}
@def_
@def $macro42()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning an Float 
 */
{
	float           i = 12.0, divide4(), dummy1();
	float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i / 2);
}
@def_
@def $macro43()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	float           i = 10.0;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro44()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;
float           result;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, no return value, illegal 
 */
{
	float           i = 10.0;

	result = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	if (--counter) {
		result = recursiveFunction(variable);
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
	}
	return;
}
@def_
@def $macro45()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	float           i = 1.0, result = 0.0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           result = 0, i = *variable;
	float           recursiveFunction();

	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = recursiveFunction(&i);
 if ( !(TGEN_FLT_EQ(result, 1.0)) )
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro46()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, pointer to function
 * returning an Float 
 */
{
	float           i = 1.0, result = 0.0, increment(), dummy();

	result = dummy(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result, i = *variable, dummy();

	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = dummy(function, &i);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(i));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro47()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, function in conditional expression, Float
 * function declaration 
 */
{
	float           recursiveFunction();
	float           i = 1.0;
 	float           arg_a, arg_b;

	arg_a = recursiveFunction(&i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           i = *variable, recursiveFunction();
	float           arg_a, arg_b;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = recursiveFunction(&i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++i);
}
@def_
@def $macro48()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning an Float 
 */
{
	float           increment();
	float           i = 1.0, dummy();
	float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           i = *variable, dummy();
	float           arg_a, arg_b;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = dummy(function, &i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (function(i));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro49()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	float           i = 1.0;

	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	float           i = *variable;

 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	float          *variable;
{
	float           i = *variable;

 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro50()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;
float           result;
float           pollux(), castor();

int
main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	float           i = 1.0;

	result = castor(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float
castor(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = pollux(&i);
 	if ( TGEN_FLT_EQ(result, 0.0) )
			result++;
	}
	return (result);
}

float
pollux(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = castor(&i);
 	if ( TGEN_FLT_EQ(result, 0.0) )
			result++;
	}
	return (result);
}
@def_
@def $macro51()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an Float 
 */
{
	float           i = 2.0, result = 0.0, castor();

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, result = 0, pollux();

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (ii);
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, result = 0, castor();

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
 if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro52()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, return value, pointer to function returning an
 * Float 
 */
{
	float           i = 1.0, result = 0.0, increment(), castor();

	result = castor(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 8, result = 0.0, pollux();

	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = pollux(function, &ii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(ii));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 8, result = 0.0, castor();

	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = castor(function, &iii);
 if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return (function(iii));
}

float 
increment(variable)
	float           variable;
{

	return (++variable);
}
@def_
@def $macro53()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return an Float 
 */
{
	float           i = 1.0, castor();
	float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 5.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	float           ii = *variable + 3, pollux();
	float           arg_a, arg_b;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++ii);
}

float 
pollux(variable)
	float          *variable;
{
	float           iii = *variable - 3, castor();
	float           arg_a, arg_b;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++iii);
}
@def_
@def $macro54()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning an Float 
 */
{
	float           i = 1.0, increment(), castor();
	float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 12.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	float           ii = *variable + 10, pollux();
   float           arg_a, arg_b;

	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (function(ii));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	float           iii = *variable - 10, castor();
   float           arg_a, arg_b;

	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 12.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (function(iii));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro55()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, no return value and legal 
 */
{
	static float    i;

	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 1.0)) )
		statusFlag++;
	variable = 3.0;
	levelTwoNodeOne(&variable);
	variable = 4.0;
	levelTwoNodeTwo(&variable);
}

levelOneNodeTwo(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 2.0)) )
		statusFlag++;
	variable = 5.0;
	levelTwoNodeThree(&variable);
	variable = 6.0;
	levelTwoNodeFour(&variable);
}

levelTwoNodeOne(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 3.0)) )
		statusFlag++;
	variable = 7.0;
	levelThreeLeafOne(&variable);
	variable = 8.0;
	levelThreeLeafTwo(&variable);
}

levelTwoNodeTwo(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 4.0)) )
		statusFlag++;
	variable = 9.0;
	levelThreeLeafThree(&variable);
	variable = 10.0;
	levelThreeLeafFour(&variable);
}

levelTwoNodeThree(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 5.0)) )
		statusFlag++;
	variable = 11.0;
	levelThreeLeafFive(&variable);
	variable = 12.0;
	levelThreeLeafSix(&variable);
}

levelTwoNodeFour(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 6.0)) )
		statusFlag++;
	variable = 13.0;
	levelThreeLeafSeven(&variable);
	variable = 14.0;
	levelThreeLeafEight(&variable);
}

levelThreeLeafOne(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 7.0)) )
		statusFlag++;
}

levelThreeLeafTwo(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 8.0)) )
		statusFlag++;
}

levelThreeLeafThree(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 9.0)) )
		statusFlag++;
}

levelThreeLeafFour(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 10.0)) )
		statusFlag++;
}

levelThreeLeafFive(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 11.0)) )
		statusFlag++;
}

levelThreeLeafSix(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 12.0)) )
		statusFlag++;
}

levelThreeLeafSeven(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 13.0)) )
		statusFlag++;
}

levelThreeLeafEight(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 14.0)) )
		statusFlag++;
}
@def_
@def $macro56()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           result;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, no return value and illegal 
 */
{
	static float    i;

	i = 1.0;
	result = levelOneNodeOne(&i);
	i = 2.0;
	result = levelOneNodeTwo(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 1.0)) )
		statusFlag++;
	variable = *argument + 2;
	result = levelTwoNodeOne(&variable);
	variable = *argument + 3;
	result = levelTwoNodeTwo(&variable);
}

levelOneNodeTwo(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 2.0)) )
		statusFlag++;
	variable = *argument + 3;
	result = levelTwoNodeThree(&variable);
	variable = *argument + 4;
	result = levelTwoNodeFour(&variable);
}

levelTwoNodeOne(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 3.0)) )
		statusFlag++;
	variable = *argument + 4;
	result = levelThreeLeafOne(&variable);
	variable = *argument + 5;
	result = levelThreeLeafTwo(&variable);
}

levelTwoNodeTwo(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 4.0)) )
		statusFlag++;
	variable = *argument + 5;
	result = levelThreeLeafThree(&variable);
	variable = *argument + 6;
	result = levelThreeLeafFour(&variable);
}

levelTwoNodeThree(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 5.0)) )
		statusFlag++;
	variable = *argument + 6;
	result = levelThreeLeafFive(&variable);
	variable = *argument + 7;
	result = levelThreeLeafSix(&variable);
}

levelTwoNodeFour(argument)
	float          *argument;
{
	static float    variable;

 	if ( !(TGEN_FLT_EQ(*argument, 6.0)) )
		statusFlag++;
	variable = *argument + 7;
	result = levelThreeLeafSeven(&variable);
	variable = *argument + 8;
	result = levelThreeLeafEight(&variable);
}

levelThreeLeafOne(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 7.0)) )
		statusFlag++;
	return;
}

levelThreeLeafTwo(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 8.0)) )
		statusFlag++;
	return;
}

levelThreeLeafThree(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 9.0)) )
		statusFlag++;
	return;
}

levelThreeLeafFour(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 10.0)) )
		statusFlag++;
	return;
}

levelThreeLeafFive(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 11.0)) )
		statusFlag++;
	return;
}

levelThreeLeafSix(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 12.0)) )
		statusFlag++;
	return;
}

levelThreeLeafSeven(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 13.0)) )
		statusFlag++;
	return;
}

levelThreeLeafEight(argument)
	float          *argument;
{
 	if ( !(TGEN_FLT_EQ(*argument, 14.0)) )
		statusFlag++;
	return;
}
@def_
@def $macro57()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, return value and legal, Float function
 * declaration 
 */
{
	static float    i = 0.0;
	float           result = 0.0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	i = 1.0;
	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	variable = 3.0;
	result = levelTwoNodeOne(&variable);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	variable = 4.0;
	result = levelTwoNodeTwo(&variable);
 	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelOneNodeTwo(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	variable = 5.0;
	result = levelTwoNodeThree(&variable);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	variable = 6.0;
	result = levelTwoNodeFour(&variable);
 	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelTwoNodeOne(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	variable = 7.0;
	result = levelThreeLeafOne(&variable);
 	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	variable = 8.0;
	result = levelThreeLeafTwo(&variable);
 	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelTwoNodeTwo(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	variable = 9.0;
	result = levelThreeLeafThree(&variable);
 	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	variable = 10.0;
	result = levelThreeLeafFour(&variable);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelTwoNodeThree(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	variable = 11.0;
	result = levelThreeLeafFive(&variable);
 	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	variable = 12.0;
	result = levelThreeLeafSix(&variable);
 	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelTwoNodeFour(argument)
	float          *argument;
{
	float           result = 0.0;
	static float    variable;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	variable = 13.0;
	result = levelThreeLeafSeven(&variable);
 	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	variable = 14.0;
	result = levelThreeLeafEight(&variable);
 	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return (*argument);
}

float 
levelThreeLeafOne(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafTwo(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafThree(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafFour(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafFive(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafSix(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafSeven(argument)
	float          *argument;
{
	return (*argument);
}

float 
levelThreeLeafEight(argument)
	float          *argument;
{
	return (*argument);
}
@def_
@def $macro58()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, return value, legal pointer to function returning
 * an Float 
 */
{
	static float    i = 12.0;
	float           result = 0.0, divide4(), dummy1();

	result = dummy1(divide4, &i);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	return (*Float / 2);
}
@def_
@def $macro59()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, used in conditional expression, Float function
 * declaration 
 */
{
	static float    i = 1.0;
	float           levelOneNodeOne();
   float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	static float    ii;
	float           levelTwoNodeOne();

	ii = 2.0 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	static float    iii;
	float           levelThreeLeafOne();

	iii = 2.0 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro60()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an Float 
 */
{
	static float    i = 12.0;
	float           divide4(), dummy1();
   float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	return (*Float / 2);
}
@def_
@def $macro61()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, no return value, legal 
 */
{
	static float    i;

	i = 1.0;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro62()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;

main()
/*
 * test class: static variable address instance  : recursive call, no return value, illegal 
 */
{
	static float    i = 1.0;

	result = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	static float    ii;

	if (! TGEN_FLT_EQ((ii = *variable), 1.0) )
		statusFlag++;
	if (--counter)
		result = recursiveFunction(&ii);
	return;
}
@def_
@def $macro63()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, legal, Float function declaration 
 */
{
	static float    i = 1.0;
	float           result = 0.0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	static float    i;
	float           result = 0;
	float           recursiveFunction();

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro64()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, pointer to function returning an Float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, increment(), dummy();

	result = dummy(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result, dummy();

	if (--counter) {
		result = dummy(function, variable);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro65()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, function in conditional expression, Float function
 * declaration 
 */
{
	float           recursiveFunction();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 1.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           recursiveFunction();
   float           arg_a, arg_b;

	if (--counter){
		arg_a = recursiveFunction(variable) - *variable;
		arg_b = 1.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return ((*variable) + 1);
}
@def_
@def $macro66()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, in conditional expression, pointer to function returning
 * an Float 
 */
{
	float           increment(), dummy();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           dummy();
   float           arg_a, arg_b;

	if (--counter){
		arg_a = dummy(function, variable);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro67()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, no return value, legal 
 */
{
	static float    i = 1.0;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro68()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           counter = 10.0;
float           result;

main()
/*
 * test class: static variable address instance  : gemini, no return value, illegal 
 */
{
	static float   *i;

	i = &counter;
	result = castor(i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, counter)) )
		statusFlag++;
	if (--counter)
		result = pollux(variable);
}

pollux(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, counter)) )
		statusFlag++;
	if (--counter)
		result = castor(variable);
}
@def_
@def $macro69()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, legal, function declared to return an Float 
 */
{
	static float    i = 1;
	float           result = 0, castor();

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
 if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return (*variable + 1);
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro70()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, pointer to function returning an Float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, castor(), increment();

	result = castor(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
 if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro71()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, function declared to return an Float 
 */
{
	static float    i = 1.0;
	float           castor();
   float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 3;
	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (*variable + 1);
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 3;
	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro72()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, pointer to function returning an Float 
 */
{
	static float    i = 1.0;
	float           castor(), increment();
   float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 10;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 12.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 10;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	return (function(*variable));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro73()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	static float    i;

	i = 1.0;
	levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	(*variable) = 3.0;
	levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 4.0;
	levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
	(*variable) = 5.0;
	levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 6.0;
	levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
	(*variable) = 7.0;
	levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 8.0;
	levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	(*variable) = 9.0;
	levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 10.0;
	levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
	(*variable) = 11.0;
	levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 12.0;
	levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
	(*variable) = 13.0;
	levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	(*variable) = 14.0;
	levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	(*variable) = 0.0;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	(*variable) = 0.0;
}
@def_
@def $macro74()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           result;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	static float    i;

	i = 1.0;
	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	*variable = 3.0;
	result = levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelOneNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	*variable = 5.0;
	result = levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 3.0)) )
		statusFlag++;
	*variable = 7.0;
	result = levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 4.0)) )
		statusFlag++;
	*variable = 9.0;
	result = levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 5.0)) )
		statusFlag++;
	*variable = 11.0;
	result = levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelTwoNodeFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 6.0)) )
		statusFlag++;
	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(*variable, 0.0)) )
		statusFlag++;
}

levelThreeLeafOne(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 7.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 8.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafThree(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 9.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafFour(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafFive(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 11.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafSix(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 12.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 13.0)) )
		statusFlag++;
	*variable = 0.0;
}

levelThreeLeafEight(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, 14.0)) )
		statusFlag++;
	*variable = 0.0;
}
@def_
@def $macro75()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, return value, legal pointer to
 * function returning a float 
 */
{
	static float    i;
	float           result = 0.0, divide4(), dummy1();

	i = 12.0;
	result = dummy1(divide4, &i);
	if ( (! TGEN_FLT_EQ(result, 3.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
	if ( (! TGEN_FLT_EQ(i, 3.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
	if ( (! TGEN_FLT_EQ(i, 6.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2.0);
}
@def_
@def $macro76()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Float function declaration 
 */
{
	static float    i = 1.0;
	float           levelOneNodeOne();
   float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           levelTwoNodeOne();

	(*variable) *= 2.0;
	return (2.0 * levelTwoNodeOne(variable));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           levelThreeLeafOne();

	(*variable) *= 2.0;
	return (2.0 * levelThreeLeafOne(variable));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) = 0.0;
	return (2.0 * i);
}
@def_
@def $macro77()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning a float 
 */
{
	static float    i = 12.0;
	float           divide4(), dummy1();
   float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if ( (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if ( (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0)) || (! TGEN_FLT_EQ(*Float, 0.0)) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2.0);
}
@def_
@def $macro78()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           counter = 10.0;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	static float    i = 10.0;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
 	if ( !(TGEN_FLT_EQ(*variable, counter)) )
		statusFlag++;
	(*variable) -= 1.0;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro79()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	static float    i = 10.0;

	result = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	if (--counter) {
 if ( !(TGEN_FLT_EQ(counter, --(*variable))) )
			statusFlag++;
		result = recursiveFunction(variable);
	}
	return;
}
@def_
@def $macro80()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	static float    i = 1.0;
	float           result = 0.0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, i)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           result = 0.0;
	float           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
 if ( !(TGEN_FLT_EQ(result, *variable)) )
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro81()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           counter = 10.0;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning a float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, increment(), dummy();

	result = dummy(increment, &i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result;
	float           i = *variable, dummy();

	if (--counter) {
		result = dummy(function, &i);
		if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
			statusFlag++;
	}
	return (function(((*variable) -= 1.0) + 1.0));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro82()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Float function declaration 
 */
{
	float           recursiveFunction();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = recursiveFunction(&i) - i;
	arg_b = 2.0;
	if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	static float    i;
   float           arg_a, arg_b;

	i = *variable;
	if (--counter){
		arg_a = recursiveFunction(&i) - i;
		arg_b = 2.0;
		if ( (! TGEN_FLT_EQ(arg_a, arg_b)) )
			statusFlag++;
	}
	return (((*variable) -= 1.0) + 2.0);
}
@def_
@def $macro83()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, in conditional expression, pointer to
 * function returning a float 
 */
{
	float           increment(), dummy();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = dummy(increment, &i) - i;
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	static float    i;
	float		dummy();
   float           arg_a, arg_b;

	i = *variable;
	if (--counter){
		arg_a = dummy(function, &i) - i;
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (function(((*variable) -= 1.0) + 1.0));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro84()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	static float    i = 1.0;

	castor(&i);
 	if ( ! TGEN_FLT_EQ(i, 0.0) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if (! TGEN_FLT_EQ(*variable, 1.0) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if (! TGEN_FLT_EQ(i, 3.0) )
			statusFlag++;
	}
	(*variable) = 0.0;
}

pollux(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if (! TGEN_FLT_EQ(i, 0.0) )
			statusFlag++;
	}
	(*variable) = 3.0;
}
@def_
@def $macro85()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           result;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	static float    i = 1.0;

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
	if (--counter) {
		result = pollux(&i);
		if (! TGEN_FLT_EQ(i, 2.0) )
			statusFlag++;
	}
	*variable = 0.0;
}

pollux(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
	if (--counter) {
		result = castor(&i);
		if (! TGEN_FLT_EQ(i, 0.0) )
			statusFlag++;
	}
	*variable = 2.0;
}
@def_
@def $macro86()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, castor();

	result = castor(&i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 3.0;
	if (--counter) {
		result = pollux(&ii);
		if (! TGEN_FLT_EQ(result, ii + 2.0) )
			statusFlag++;
	}
	return (++(*variable));
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 3.0;
	if (--counter) {
		result = castor(&iii);
 if (! TGEN_FLT_EQ(result, iii) )
			statusFlag++;
	}
	return (--(*variable) + 2.0);
}
@def_
@def $macro87()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, pointer to function returning a
 * float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, increment(), castor();

	result = castor(increment, &i);
	if ( (! TGEN_FLT_EQ(result, 2.0)) || (! TGEN_FLT_EQ(i, 0.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 8.0;
	if (--counter) {
		result = pollux(function, &ii);
		if (! TGEN_FLT_EQ(result, ii + 2.0) )
			statusFlag++;
	}
	return (function(variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 8.0;
	if (--counter) {
		result = castor(function, &iii);
		if (! TGEN_FLT_EQ(result, iii + 2.0) )
			statusFlag++;
	}
	return (function(variable));
}

float 
increment(variable)
	float          *variable;
{
	float           i = *variable;

	(*variable) -= 1.0;
	return (++i);
}
@def_
@def $macro88()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return a float 
 */
{
	static float    i = 1.0;
	float           castor();
   float           arg_a, arg_b;

	arg_a = castor(&i) - i;
	arg_b = 0.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 3.0;
	if (--counter) {
		arg_a = pollux(&ii) - ii;
		arg_b = 0.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++(*variable));
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 3.0;
	if (--counter) {
		arg_a = castor(&iii) - iii;
		arg_b = 0.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro89()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, pointer to function
 * returning a float 
 */
{
	static float    i = 1.0;
	float           increment(), castor();
   float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = i + 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 10.0;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = ii + 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (function(variable));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 10.0;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = iii + 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (function(variable));
}

float 
increment(variable)
	float          *variable;
{
	return (--(*variable) + 2.0);
}
@def_
@def $macro90()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	static float    i;

	i = 1.0;
	levelOneNodeOne(&i);
	i = 2.0;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	*variable = 3.0;
	levelTwoNodeOne(variable);
	*variable = 4.0;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	float          *variable;
{
	*variable = 5.0;
	levelTwoNodeThree(variable);
	*variable = 6.0;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	float          *variable;
{
	*variable = 7.0;
	levelThreeLeafOne(variable);
	*variable = 8.0;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	*variable = 9.0;
	levelThreeLeafThree(variable);
	*variable = 10.0;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	float          *variable;
{
	*variable = 11.0;
	levelThreeLeafFive(variable);
	*variable = 12.0;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	float          *variable;
{
	*variable = 13.0;
	levelThreeLeafSeven(variable);
	*variable = 14.0;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;

}

levelThreeLeafTwo(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro91()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           result;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	static float    i;

	i = 1.0;
	result = levelOneNodeOne(&i);
	i = 2.0;
	result = levelOneNodeTwo(&i);
 if (! TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	float          *variable;
{
	*variable = 3.0;
	result = levelTwoNodeOne(variable);
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	float          *variable;
{
	*variable = 5.0;
	result = levelTwoNodeThree(variable);
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	float          *variable;
{
	*variable = 7.0;
	result = levelThreeLeafOne(variable);
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	float          *variable;
{
	*variable = 9.0;
	result = levelThreeLeafThree(variable);
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	float          *variable;
{
	*variable = 11.0;
	result = levelThreeLeafFive(variable);
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	float          *variable;
{
	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafThree(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFour(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafFive(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSix(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}

levelThreeLeafEight(variable)
	float          *variable;
{
	variable = 0;
	if (variable != 0)
		statusFlag++;
}
@def_
@def $macro92()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, return value and legal, Float
 * function declaration 
 */
{
	static float    i = 1.0;
	float           result = 0.0;
	float           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	i = 2.0;
	result = levelOneNodeTwo(&i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3.0;
	result = levelTwoNodeOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	*variable = 4.0;
	result = levelTwoNodeTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 4.0)) )
		statusFlag++;
	return (storage);
}

float 
levelOneNodeTwo(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5.0;
	result = levelTwoNodeThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	*variable = 6.0;
	result = levelTwoNodeFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 6.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7.0;
	result = levelThreeLeafOne(variable);
 	if ( !(TGEN_FLT_EQ(result, 7.0)) )
		statusFlag++;
	*variable = 8.0;
	result = levelThreeLeafTwo(variable);
 	if ( !(TGEN_FLT_EQ(result, 8.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeTwo(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9.0;
	result = levelThreeLeafThree(variable);
 	if ( !(TGEN_FLT_EQ(result, 9.0)) )
		statusFlag++;
	*variable = 10.0;
	result = levelThreeLeafFour(variable);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeThree(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11.0;
	result = levelThreeLeafFive(variable);
 	if ( !(TGEN_FLT_EQ(result, 11.0)) )
		statusFlag++;
	*variable = 12.0;
	result = levelThreeLeafSix(variable);
 	if ( !(TGEN_FLT_EQ(result, 12.0)) )
		statusFlag++;
	return (storage);
}

float 
levelTwoNodeFour(variable)
	float          *variable;
{
	float           storage = *variable, result = 0.0;
	float           levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13.0;
	result = levelThreeLeafSeven(variable);
 	if ( !(TGEN_FLT_EQ(result, 13.0)) )
		statusFlag++;
	*variable = 14.0;
	result = levelThreeLeafEight(variable);
 	if ( !(TGEN_FLT_EQ(result, 14.0)) )
		statusFlag++;
	return (storage);
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafTwo(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafThree(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafFour(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafFive(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafSix(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafSeven(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}

float 
levelThreeLeafEight(variable)
	float          *variable;
{
	float           i = *variable;

	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (i);
}
@def_
@def $macro93()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning a float 
 */
{
	static float    i;
	float           result = 0.0, divide4(), dummy1();

	i = 12.0;
	result = dummy1(divide4, &i);
 	if ( !(TGEN_FLT_EQ(result, 3.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 3.0)) )
		statusFlag++;
	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           i;

	i = (*func) (Float);
 	if ( !(TGEN_FLT_EQ(i, 6.0)) )
		statusFlag++;
	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	(*Float) = 0.0;
	return (i / 2.0);
}
@def_
@def $macro94()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, used in conditional expression, Float
 * function declaration 
 */
{
	static float    i = 1.0;
	float           levelOneNodeOne();
   float           arg_a, arg_b;

	arg_a = levelOneNodeOne(&i);
	arg_b = 32.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
levelOneNodeOne(variable)
	float          *variable;
{
	float           levelTwoNodeOne();
	static float    i;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return (2.0 * levelTwoNodeOne(&i));
}

float 
levelTwoNodeOne(variable)
	float          *variable;
{
	float           levelThreeLeafOne();
	static float    i;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	i *= 2.0;
	return (2.0 * levelThreeLeafOne(&i));
}

float 
levelThreeLeafOne(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (2.0 * i);
}
@def_
@def $macro95()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, in conditional expression, pointer to
 * function returning a float 
 */
{
	static float    i = 12.0;
	float           divide4(), dummy1();
   float           arg_a, arg_b;

	arg_a = dummy1(divide4, &i);
	arg_b = 3.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy1(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 3.0) )
		statusFlag++;
	return (ii);
}

float 
divide4(Float)
	float          *Float;
{
	float           divide2(), dummy2();

	return (dummy2(divide2, Float) / 2.0);
}

float 
dummy2(func, Float)
	float           (*func) (), *Float;
{
	float           ii;

	if (! TGEN_FLT_EQ((ii = (*func) (Float)), 6.0) )
		statusFlag++;
	return (ii);
}

float 
divide2(Float)
	float          *Float;
{
	float           i = *Float;

	Float = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*Float, 10.0)) )
		statusFlag++;
	return (i / 2.0);
}
@def_
@def $macro96()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	static float    i = 10.0;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro97()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;
float           result;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, no return value, illegal 
 */
{
	static float    i = 10.0;

	result = recursiveFunction(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	float          *variable;
{
	if (--counter) {
		result = recursiveFunction(variable);
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
	}
	return;
}
@def_
@def $macro98()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, legal, Float function
 * declaration 
 */
{
	static float    i = 1.0;
	float           result = 0.0;
	float           recursiveFunction();

	result = recursiveFunction(&i);
 	if ( !(TGEN_FLT_EQ(result, 1.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	float           result = 0.0;
	static float    i;
	float           recursiveFunction();

	i = *variable;
	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = recursiveFunction(&i);
 if ( !(TGEN_FLT_EQ(result, 1.0)) )
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro99()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, pointer to function returning a
 * float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, increment(), dummy();

	result = dummy(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 2.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	float           result, dummy();
	static float    i;

	i = *variable;
	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = dummy(function, &i);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(i));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro100()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, function in conditional expression, Float
 * function declaration 
 */
{
	float           recursiveFunction();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = recursiveFunction(&i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
recursiveFunction(variable)
	float          *variable;
{
	static float    i;
   float           arg_a, arg_b;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = recursiveFunction(&i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (i + 1.0);
}
@def_
@def $macro101()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning a float 
 */
{
	float           increment(), dummy();
	static float    i = 1.0;
   float           arg_a, arg_b;

	arg_a = dummy(increment, &i);
	arg_b = 2.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
dummy(function, variable)
	float           (*function) (), *variable;
{
	static float    i;
	float		dummy();
   float           arg_a, arg_b;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter){
		arg_a = dummy(function, &i);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (function(i));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro102()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	static float    i = 1.0;

	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if ( !(TGEN_FLT_EQ(*variable, 1.0)) )
		statusFlag++;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
 	if ( !(TGEN_FLT_EQ(*variable, 2.0)) )
		statusFlag++;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro103()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;
float           result;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	static float    i = 1.0;

	result = castor(&i);
 if ( TGEN_FLT_EQ(result, 0.0) )
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter)
		result = pollux(&i);
}

pollux(variable)
	float          *variable;
{
	static float    i;

	i = *variable;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter)
		result = castor(&i);
}
@def_
@def $macro104()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a float 
 */
{
	static float    i = 2.0;
	float           result = 0.0, castor();

	result = castor(&i);
 	if ( !(TGEN_FLT_EQ(result, 5.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 3.0;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (ii);
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 3.0;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
 if ( !(TGEN_FLT_EQ(result, 5.0)) )
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro105()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, return value, pointer to function returning a float 
 */
{
	static float    i = 1.0;
	float           result = 0.0, increment(), castor();

	result = castor(increment, &i);
 	if ( !(TGEN_FLT_EQ(result, 10.0)) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           result = 0.0, pollux();

	ii = *variable + 8.0;
	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = pollux(function, &ii);
 if ( !(TGEN_FLT_EQ(result, 2.0)) )
			statusFlag++;
	}
	return (function(ii));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           result = 0.0, castor();

	iii = *variable - 8.0;
	if (--counter) {
		variable = &globalFloat;
 if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
			statusFlag++;
		result = castor(function, &iii);
 if ( !(TGEN_FLT_EQ(result, 10.0)) )
			statusFlag++;
	}
	return (function(iii));
}

float 
increment(variable)
	float           variable;
{

	return (++variable);
}
@def_
@def $macro106()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a float 
 */
{
	static float    i = 1.0;
	float           castor();
   float           arg_a, arg_b;

	arg_a = castor(&i);
	arg_b = 5.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b) )
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(variable)
	float          *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 3.0;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = pollux(&ii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (ii + 1.0);
}

float 
pollux(variable)
	float          *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 3.0;
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	if (--counter) {
		arg_a = castor(&iii);
		arg_b = 5.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b) )
			statusFlag++;
	}
	return (iii + 1.0);
}
@def_
@def $macro107()
$LICENSE()
$FHEAD()

short           statusFlag = NoMistake;
short           counter = 10;
float           globalFloat = 10.0;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning a float 
 */
{
	static float    i = 1.0;
	float           increment(), castor();
   float           arg_a, arg_b;

	arg_a = castor(increment, &i);
	arg_b = 12.0;
	if (! TGEN_FLT_EQ(arg_a, arg_b))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

float 
castor(function, variable)
	float           (*function) (), *variable;
{
	static float    ii;
	float           pollux();
   float           arg_a, arg_b;

	ii = *variable + 10.0;
	if (--counter) {
		arg_a = pollux(function, &ii);
		arg_b = 2.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (function(ii));
}

float 
pollux(function, variable)
	float           (*function) (), *variable;
{
	static float    iii;
	float           castor();
   float           arg_a, arg_b;

	iii = *variable - 10.0;
	if (--counter) {
		arg_a = castor(function, &iii);
		arg_b = 12.0;
		if (! TGEN_FLT_EQ(arg_a, arg_b))
			statusFlag++;
	}
	variable = &globalFloat;
 	if ( !(TGEN_FLT_EQ(*variable, 10.0)) )
		statusFlag++;
	return (function(iii));
}

float 
increment(variable)
	float           variable;
{
	return (++variable);
}
@def_
@def $macro108()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, no return value and legal 
 */
{
	long            i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	(*variable) = 3;
	levelTwoNodeOne(variable);
	(*variable) = 4;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	long           *variable;
{
	if (*variable != 2L)
		statusFlag++;
	(*variable) = 5;
	levelTwoNodeThree(variable);
	(*variable) = 6;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	long           *variable;
{
	if (*variable != 3L)
		statusFlag++;
	(*variable) = 7;
	levelThreeLeafOne(variable);
	(*variable) = 8;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	if (*variable != 4L)
		statusFlag++;
	(*variable) = 9;
	levelThreeLeafThree(variable);
	(*variable) = 10;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	long           *variable;
{
	if (*variable != 5L)
		statusFlag++;
	(*variable) = 11;
	levelThreeLeafFive(variable);
	(*variable) = 12;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	long           *variable;
{
	if (*variable != 6L)
		statusFlag++;
	(*variable) = 13;
	levelThreeLeafSeven(variable);
	(*variable) = 14;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	long           *variable;
{
	if (*variable != 7L)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	if (*variable != 8L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	if (*variable != 9L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	if (*variable != 10L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	if (*variable != 11L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	if (*variable != 12L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	if (*variable != 13L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	if (*variable != 14L)
		statusFlag++;
}
@def_
@def $macro109()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, no return value and illegal 
 */
{
	long            i, result;

	i = 1;
	result = levelOneNodeOne(&i);
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	long            result;

	if (*variable != 1L)
		statusFlag++;
	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result == 0L)
		result++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	long            result;

	if (*variable != 2L)
		statusFlag++;
	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result == 0L)
		result++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	long            result;

	if (*variable != 3L)
		statusFlag++;
	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result == 0L)
		result++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	long            result;

	if (*variable != 4L)
		statusFlag++;
	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result == 0L)
		result++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	long            result;

	if (*variable != 5L)
		statusFlag++;
	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result == 0L)
		result++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	long            result;

	if (*variable != 6L)
		statusFlag++;
	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result == 0L)
		result++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	if (*variable++ != 7L)
		statusFlag++;
	return;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	if (*variable++ != 8L)
		statusFlag++;
	return;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	if (*variable++ != 9L)
		statusFlag++;
	return;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	if (*variable++ != 10L)
		statusFlag++;
	return;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	if (*variable++ != 11L)
		statusFlag++;
	return;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	if (*variable++ != 12L)
		statusFlag++;
	return;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	if (*variable++ != 13L)
		statusFlag++;
	return;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	if (*variable++ != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro110()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, return value and legal, Long function
 * declaration 
 */
{
	long            i = 0, result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L)
		statusFlag++;
	return (storage);
}

long 
levelOneNodeTwo(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeTwo(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeThree(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeFour(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L)
		statusFlag++;
	return (storage);
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafTwo(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafThree(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafFour(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafFive(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafSix(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafSeven(variable)
	long           *variable;
{
	return (*variable);
}

long 
levelThreeLeafEight(variable)
	long           *variable;
{
	return (*variable);
}
@def_
@def $macro111()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, return value, legal pointer to function
 * returning a long 
 */
{
	long            i, result = 0, divide4(), dummy1();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	return (*Long / 2);
}
@def_
@def $macro112()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	long            i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            ii, levelTwoNodeOne();

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            iii, levelThreeLeafOne();

	iii = 2 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro113()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            i, divide4(), dummy1();

	i = 12;
	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	return (*Long / 2);
}
@def_
@def $macro114()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, no return value, legal 
 */
{
	long            i;

	i = 1;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro115()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            whatIsThis;

main()
/*
 * test class: automatic variable address instance  : recursive call, no return value, illegal 
 */
{
	long            i = 1;

	whatIsThis = recursiveFunction(&i);
	if (whatIsThis == 0L)
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		whatIsThis = recursiveFunction(variable);
		if (whatIsThis == 0L)
			whatIsThis++;
	}
	return;
}
@def_
@def $macro116()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, legal, Long function declaration 
 */
{
	long            i = 1, result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            i = *variable, result = 0;
	long            recursiveFunction();

	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2L)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro117()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, pointer to function returning a long 
 */
{
	long            i = 1, result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result, dummy();

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro118()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{
	long            recursiveFunction();
	long            i = 1;

	if (!(recursiveFunction(&i) - i == 1L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1L))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro119()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            increment();
	long            i = 1, dummy();

	if (!(dummy(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            dummy();
	if (--counter)
		if (!(dummy(function, variable) == 2L))
			statusFlag++;
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro120()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, no return value, legal 
 */
{
	long            i = 1;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro121()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, no return value, illegal 
 */
{
	long           *i, result;

	i = &counter;
	result = castor(i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            ii;

	if (*variable != counter)
		statusFlag++;
	if (--counter) {
		ii = pollux(variable);
		if (ii == 0L)
			ii++;
	}
}

pollux(variable)
	long           *variable;
{
	long            iii;

	if (*variable != counter)
		statusFlag++;
	if (--counter) {
		iii = castor(variable);
		if (iii == 0L)
			iii++;
	}
}
@def_
@def $macro122()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, legal, function declared to return a long 
 */
{
	long            i = 1, result = 0, castor();

	result = castor(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, result = 0, pollux();

	if (--counter) {
		result = pollux(&ii);
		if (result != 5L)
			statusFlag++;
	}
	return (*variable + 1);
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3, result = 0;
	long            castor();

	if (--counter) {
		result = castor(&iii);
		if (result != 2L)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro123()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i = 1, result = 0, increment();
	long            castor();

	result = castor(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 8, result = 0;
	long            pollux();
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 8, result = 0;
	long            castor();
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro124()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	long            i = 1, castor();

	if (!(castor(&i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, pollux();

	if (--counter) {
		if (!(pollux(&ii) == 5L))
			statusFlag++;
	}
	return (++(*variable));
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3;
	long            castor();
	if (--counter) {
		if (!(castor(&iii) == 2L))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro125()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, pointer to function returning a
 * long 
 */
{
	long            i = 1, increment();
	long            castor();

	if (!(castor(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 10, pollux();

	if (--counter) {
		if (!(pollux(function, &ii) == 12L))
			statusFlag++;
	}
	return (function(*variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 10, castor();
	if (--counter) {
		if (!(castor(function, &iii) == 2L))
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro126()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	long            i;

	i = 1;
	levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	(*variable) = 3;
	levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 4;
	levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	(*variable) = 5;
	levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 6;
	levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	(*variable) = 7;
	levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 8;
	levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	(*variable) = 9;
	levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 10;
	levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	(*variable) = 11;
	levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 12;
	levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	(*variable) = 13;
	levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 14;
	levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	(*variable) = 0;
}
@def_
@def $macro127()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	long            i;

	i = 1;
	result = levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	if (*variable != 2L)
		statusFlag++;
	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	if (*variable != 3L)
		statusFlag++;
	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	if (*variable != 4L)
		statusFlag++;
	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	if (*variable != 5L)
		statusFlag++;
	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	if (*variable != 6L)
		statusFlag++;
	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	*variable = 0;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	*variable = 0;
}
@def_
@def $macro128()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, return value and legal,
 * Long function declaration 
 */
{
	long            i = 0, result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1L || i != 0L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L || *variable != 0L)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelOneNodeTwo(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L || *variable != 0L)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L || *variable != 0L)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeTwo(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L || *variable != 0L)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeThree(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L || *variable != 0L)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeFour(variable)
	long           *variable;
{
	long            storage = (*variable), result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L || *variable != 0L)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L || *variable != 0L)
		statusFlag++;
	return (storage);
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafTwo(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafThree(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafFour(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafFive(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafSix(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafSeven(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}

long 
levelThreeLeafEight(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (i);
}
@def_
@def $macro129()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning a long 
 */
{
	long            i, result = 0, divide4(), dummy1();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L || *Long != 0L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L || *Long != 0L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro130()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	long            i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L) || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            levelTwoNodeOne();

	(*variable) *= 2;
	return (2 * levelTwoNodeOne(variable));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            levelThreeLeafOne();

	(*variable) *= 2;
	return (2 * levelThreeLeafOne(variable));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (2 * i);
}
@def_
@def $macro131()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning a long 
 */
{
	long            i = 12, divide4(), dummy1();

	if (dummy1(divide4, &i) != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L || *Long != 0L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L || *Long != 0L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro132()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	long            i = 10;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (*variable != counter)
		statusFlag++;
	(*variable)--;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro133()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            whatIsThis;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	long            i = 10;

	whatIsThis = recursiveFunction(&i);
	if (whatIsThis == 0L)
		whatIsThis++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (--counter) {
		if (counter != --(*variable))
			statusFlag++;
		whatIsThis = recursiveFunction(variable);
		if (whatIsThis == 0L)
			whatIsThis++;
	}
	return;
}
@def_
@def $macro134()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	long            i = 1, result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            result = 0;
	long            recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro135()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	long            i = 1, result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result, i = *variable, dummy();

	if (--counter) {
		result = dummy(function, &i);
		if (result != 2L || i != 0L)
			statusFlag++;
	}
	return (function((*variable)--));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro136()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Long function declaration 
 */
{
	long            recursiveFunction();
	long            i = 1;

	if (recursiveFunction(&i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            i = *variable;

	if (--counter)
		if (recursiveFunction(&i) - i != 2L)
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro137()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning a long 
 */
{
	long            increment();
	long            i = 1, dummy();

	if (dummy(increment, &i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            i = *variable, dummy();
	if (--counter)
		if (dummy(function, &i) - i != 2L)
			statusFlag++;
	return (function((*variable)--));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro138()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	long            i = 1;

	castor(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if (i != 3L)
			statusFlag++;
	}
	(*variable)--;
}

pollux(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	(*variable)++;
}
@def_
@def $macro139()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	long            i = 1;

	result = castor(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            i = *variable;

	if (--counter) {
		result = pollux(&i);
		if (i != 2L)
			statusFlag++;
	}
	(*variable)--;
}

pollux(variable)
	long           *variable;
{
	long            i = *variable;

	if (--counter) {
		result = castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	(*variable)++;
}
@def_
@def $macro140()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	long            i = 1, result = 0, castor();

	result = castor(&i);
	if (result != 2L || i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, result = 0, pollux();

	if (--counter) {
		result = pollux(&ii);
		if (result != 5L || ii != 3L)
			statusFlag++;
	}
	return (++(*variable));
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3, result = 0, castor();

	if (--counter) {
		result = castor(&iii);
		if (result != 2L || iii != 2L)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro141()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * a long 
 */
{
	long            i = 1, result = 0, increment(), castor();

	result = castor(increment, &i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 8, result = 0, pollux();
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10L || ii != 0L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 8, result = 0, castor();
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2L || iii != 0L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (++i);
}
@def_
@def $macro142()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, function
 * declared to return a long 
 */
{
	long            i = 1, castor();

	if (castor(&i) - i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, pollux();

	if (--counter) {
		if (pollux(&ii) - ii != 0L)
			statusFlag++;
	}
	return (++(*variable));
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0L)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro143()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            i = 1, increment(), castor();

	if (!(castor(increment, &i) == 2L) || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 10, pollux();
	if (--counter) {
		if (!(pollux(function, &ii) == 12L) || ii != 10L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 10, castor();
	if (--counter) {
		if (!(castor(function, &iii) == 2L) || iii != 0L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long           *variable;
{
	return (--(*variable) + 2);
}
@def_
@def $macro144()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	long            i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	*variable = 3;
	levelTwoNodeOne(variable);
	*variable = 4;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	long           *variable;
{
	*variable = 5;
	levelTwoNodeThree(variable);
	*variable = 6;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	long           *variable;
{
	*variable = 7;
	levelThreeLeafOne(variable);
	*variable = 8;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	*variable = 9;
	levelThreeLeafThree(variable);
	*variable = 10;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	long           *variable;
{
	*variable = 11;
	levelThreeLeafFive(variable);
	*variable = 12;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	long           *variable;
{
	*variable = 13;
	levelThreeLeafSeven(variable);
	*variable = 14;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;

}

levelThreeLeafTwo(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro145()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	long            i;

	i = 1;
	result = levelOneNodeOne(&i);
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	*variable = 3;
	result = levelTwoNodeOne(variable);
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	*variable = 5;
	result = levelTwoNodeThree(variable);
	*variable = 6;
	result = levelTwoNodeFour(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	*variable = 7;
	result = levelThreeLeafOne(variable);
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	*variable = 9;
	result = levelThreeLeafThree(variable);
	*variable = 10;
	result = levelThreeLeafFour(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	*variable = 11;
	result = levelThreeLeafFive(variable);
	*variable = 12;
	result = levelThreeLeafSix(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	*variable = 13;
	result = levelThreeLeafSeven(variable);
	*variable = 14;
	result = levelThreeLeafEight(variable);
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro146()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, return value and legal, Long
 * function declaration 
 */
{
	long            i = 1, result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L)
		statusFlag++;
	return (storage);
}

long 
levelOneNodeTwo(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeTwo(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeThree(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeFour(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L)
		statusFlag++;
	return (storage);
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafTwo(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafThree(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafFour(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafFive(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafSix(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafSeven(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafEight(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}
@def_
@def $macro147()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	long            i, result = 0, divide4(), dummy1();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro148()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * Long function declaration 
 */
{
	long            i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            levelTwoNodeOne();
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return (2 * levelTwoNodeOne(&i));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            levelThreeLeafOne();
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return (2 * levelThreeLeafOne(&i));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (2 * i);
}
@def_
@def $macro149()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning a long 
 */
{
	long            i = 12, divide4(), dummy1();

	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i / 2);
}
@def_
@def $macro150()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	long            i = 10;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro151()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            result;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, no return value, illegal 
 */
{
	long            i = 10;

	result = recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (--counter) {
		result = recursiveFunction(variable);
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
	}
	return;
}
@def_
@def $macro152()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	long            i = 1, result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            result = 0, i = *variable;
	long            recursiveFunction();

	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1L)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro153()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	long            i = 1, result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result, i = *variable, dummy();

	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2L)
			statusFlag++;
	}
	return (function(i));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro154()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	long            recursiveFunction();
	long            i = 1;

	if (recursiveFunction(&i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2L)
			statusFlag++;
	return (++i);
}
@def_
@def $macro155()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            increment();
	long            i = 1, dummy();

	if (dummy(increment, &i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            i = *variable, dummy();

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2L)
			statusFlag++;
	return (function(i));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro156()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	long            i = 1;

	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 1L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	long           *variable;
{
	long            i = *variable;

	if (*variable != 2L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro157()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            result;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	long            i = 1;

	result = castor(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = pollux(&i);
		if (result == 0L)
			result++;
	}
}

pollux(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = castor(&i);
		if (result == 0L)
			result++;
	}
}
@def_
@def $macro158()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	long            i = 2, result = 0, castor();

	result = castor(&i);
	if (result != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, result = 0, pollux();

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2L)
			statusFlag++;
	}
	return (ii);
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3, result = 0, castor();

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5L)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro159()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, return value, pointer to function returning a long 
 */
{
	long            i = 1, result = 0, increment(), castor();

	result = castor(increment, &i);
	if (result != 10L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 8, result = 0, pollux();
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2L)
			statusFlag++;
	}
	return (function(ii));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 8, result = 0, castor();
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10L)
			statusFlag++;
	}
	return (function(iii));
}

long 
increment(variable)
	long            variable;
{

	return (++variable);
}
@def_
@def $macro160()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	long            i = 1, castor();

	if (castor(&i) != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	long            ii = *variable + 3, pollux();

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2L)
			statusFlag++;
	}
	return (++ii);
}

long 
pollux(variable)
	long           *variable;
{
	long            iii = *variable - 3, castor();
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5L)
			statusFlag++;
	}
	return (++iii);
}
@def_
@def $macro161()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	long            i = 1, increment(), castor();

	if (!(castor(increment, &i) == 12L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	long            ii = *variable + 10, pollux();
	if (--counter) {
		if (!(pollux(function, &ii) == 2L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (function(ii));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	long            iii = *variable - 10, castor();
	if (--counter) {
		if (!(castor(function, &iii) == 12L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (function(iii));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro162()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, no return value and legal 
 */
{
	static long     i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 1L)
		statusFlag++;
	variable = 3;
	levelTwoNodeOne(&variable);
	variable = 4;
	levelTwoNodeTwo(&variable);
}

levelOneNodeTwo(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 2L)
		statusFlag++;
	variable = 5;
	levelTwoNodeThree(&variable);
	variable = 6;
	levelTwoNodeFour(&variable);
}

levelTwoNodeOne(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 3L)
		statusFlag++;
	variable = 7;
	levelThreeLeafOne(&variable);
	variable = 8;
	levelThreeLeafTwo(&variable);
}

levelTwoNodeTwo(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 4L)
		statusFlag++;
	variable = 9;
	levelThreeLeafThree(&variable);
	variable = 10;
	levelThreeLeafFour(&variable);
}

levelTwoNodeThree(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 5L)
		statusFlag++;
	variable = 11;
	levelThreeLeafFive(&variable);
	variable = 12;
	levelThreeLeafSix(&variable);
}

levelTwoNodeFour(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 6L)
		statusFlag++;
	variable = 13;
	levelThreeLeafSeven(&variable);
	variable = 14;
	levelThreeLeafEight(&variable);
}

levelThreeLeafOne(argument)
	long           *argument;
{
	if (*argument != 7L)
		statusFlag++;
}

levelThreeLeafTwo(argument)
	long           *argument;
{
	if (*argument != 8L)
		statusFlag++;
}

levelThreeLeafThree(argument)
	long           *argument;
{
	if (*argument != 9L)
		statusFlag++;
}

levelThreeLeafFour(argument)
	long           *argument;
{
	if (*argument != 10L)
		statusFlag++;
}

levelThreeLeafFive(argument)
	long           *argument;
{
	if (*argument != 11L)
		statusFlag++;
}

levelThreeLeafSix(argument)
	long           *argument;
{
	if (*argument != 12L)
		statusFlag++;
}

levelThreeLeafSeven(argument)
	long           *argument;
{
	if (*argument != 13L)
		statusFlag++;
}

levelThreeLeafEight(argument)
	long           *argument;
{
	if (*argument != 14L)
		statusFlag++;
}
@def_
@def $macro163()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, no return value and illegal 
 */
{
	static long     i;

	i = 1;
	result = levelOneNodeOne(&i);
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 1L)
		statusFlag++;
	variable = *argument + 2;
	result = levelTwoNodeOne(&variable);
	variable = *argument + 3;
	result = levelTwoNodeTwo(&variable);
}

levelOneNodeTwo(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 2L)
		statusFlag++;
	variable = *argument + 3;
	result = levelTwoNodeThree(&variable);
	variable = *argument + 4;
	result = levelTwoNodeFour(&variable);
}

levelTwoNodeOne(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 3L)
		statusFlag++;
	variable = *argument + 4;
	result = levelThreeLeafOne(&variable);
	variable = *argument + 5;
	result = levelThreeLeafTwo(&variable);
}

levelTwoNodeTwo(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 4L)
		statusFlag++;
	variable = *argument + 5;
	result = levelThreeLeafThree(&variable);
	variable = *argument + 6;
	result = levelThreeLeafFour(&variable);
}

levelTwoNodeThree(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 5L)
		statusFlag++;
	variable = *argument + 6;
	result = levelThreeLeafFive(&variable);
	variable = *argument + 7;
	result = levelThreeLeafSix(&variable);
}

levelTwoNodeFour(argument)
	long           *argument;
{
	static long     variable;

	if (*argument != 6L)
		statusFlag++;
	variable = *argument + 7;
	result = levelThreeLeafSeven(&variable);
	variable = *argument + 8;
	result = levelThreeLeafEight(&variable);
}

levelThreeLeafOne(argument)
	long           *argument;
{
	if (*argument != 7L)
		statusFlag++;
	return;
}

levelThreeLeafTwo(argument)
	long           *argument;
{
	if (*argument != 8L)
		statusFlag++;
	return;
}

levelThreeLeafThree(argument)
	long           *argument;
{
	if (*argument != 9L)
		statusFlag++;
	return;
}

levelThreeLeafFour(argument)
	long           *argument;
{
	if (*argument != 10L)
		statusFlag++;
	return;
}

levelThreeLeafFive(argument)
	long           *argument;
{
	if (*argument != 11L)
		statusFlag++;
	return;
}

levelThreeLeafSix(argument)
	long           *argument;
{
	if (*argument != 12L)
		statusFlag++;
	return;
}

levelThreeLeafSeven(argument)
	long           *argument;
{
	if (*argument != 13L)
		statusFlag++;
	return;
}

levelThreeLeafEight(argument)
	long           *argument;
{
	if (*argument != 14L)
		statusFlag++;
	return;
}
@def_
@def $macro164()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, return value and legal, Long function declaration 
 */
{
	static long     i = 0;
	long            result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	variable = 3;
	result = levelTwoNodeOne(&variable);
	if (result != 3L)
		statusFlag++;
	variable = 4;
	result = levelTwoNodeTwo(&variable);
	if (result != 4L)
		statusFlag++;
	return (*argument);
}

long 
levelOneNodeTwo(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	variable = 5;
	result = levelTwoNodeThree(&variable);
	if (result != 5L)
		statusFlag++;
	variable = 6;
	result = levelTwoNodeFour(&variable);
	if (result != 6L)
		statusFlag++;
	return (*argument);
}

long 
levelTwoNodeOne(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	variable = 7;
	result = levelThreeLeafOne(&variable);
	if (result != 7L)
		statusFlag++;
	variable = 8;
	result = levelThreeLeafTwo(&variable);
	if (result != 8L)
		statusFlag++;
	return (*argument);
}

long 
levelTwoNodeTwo(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	variable = 9;
	result = levelThreeLeafThree(&variable);
	if (result != 9L)
		statusFlag++;
	variable = 10;
	result = levelThreeLeafFour(&variable);
	if (result != 10L)
		statusFlag++;
	return (*argument);
}

long 
levelTwoNodeThree(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	variable = 11;
	result = levelThreeLeafFive(&variable);
	if (result != 11L)
		statusFlag++;
	variable = 12;
	result = levelThreeLeafSix(&variable);
	if (result != 12L)
		statusFlag++;
	return (*argument);
}

long 
levelTwoNodeFour(argument)
	long           *argument;
{
	long            result = 0;
	static long     variable;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	variable = 13;
	result = levelThreeLeafSeven(&variable);
	if (result != 13L)
		statusFlag++;
	variable = 14;
	result = levelThreeLeafEight(&variable);
	if (result != 14L)
		statusFlag++;
	return (*argument);
}

long 
levelThreeLeafOne(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafTwo(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafThree(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafFour(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafFive(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafSix(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafSeven(argument)
	long           *argument;
{
	return (*argument);
}

long 
levelThreeLeafEight(argument)
	long           *argument;
{
	return (*argument);
}
@def_
@def $macro165()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, return value, legal pointer to function returning
 * a long 
 */
{
	static long     i = 12;
	long            result = 0, divide4(), dummy1();

	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	return (*Long / 2);
}
@def_
@def $macro166()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, used in conditional expression, Long function
 * declaration 
 */
{
	static long     i = 1;
	long            levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	static long     ii;
	long            levelTwoNodeOne();

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	static long     iii;
	long            levelThreeLeafOne();

	iii = 2 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro167()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning a long 
 */
{
	static long     i = 12;
	long            divide4(), dummy1();

	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	return (*Long / 2);
}
@def_
@def $macro168()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, no return value, legal 
 */
{
	static long     i;

	i = 1;
	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro169()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

main()
/*
 * test class: static variable address instance  : recursive call, no return value, illegal 
 */
{
	static long     i = 1;

	result = recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	static long     ii;

	if ((ii = *variable) != 1L)
		statusFlag++;
	if (--counter)
		result = recursiveFunction(&ii);
	return;
}
@def_
@def $macro170()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, legal, Long function declaration 
 */
{
	static long     i = 1;
	long            result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	static long     i;
	long            result = 0;
	long            recursiveFunction();

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2L)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro171()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, pointer to function returning a long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result, dummy();

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro172()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, function in conditional expression, Long function
 * declaration 
 */
{
	long            recursiveFunction();
	static long     i = 1;

	if (!(recursiveFunction(&i) - i == 1L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1L))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro173()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, in conditional expression, pointer to function returning
 * a long 
 */
{
	long            increment();
	static long     i = 1;
	long            dummy();

	if (!(dummy(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            dummy();
	if (--counter)
		if (!(dummy(function, variable) == 2L))
			statusFlag++;
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro174()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, no return value, legal 
 */
{
	static long     i = 1;
	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro175()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, legal, function declared to return a long 
 */
{
	static long     i = 1;
	long            result = 0, castor();

	result = castor(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5L)
			statusFlag++;
	}
	return (*variable + 1);
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2L)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro176()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, pointer to function returning a long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), castor();

	result = castor(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2L)
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro177()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, function declared to return a long 
 */
{
	static long     i = 1;
	long            castor();

	if (!(castor(&i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5L))
			statusFlag++;
	}
	return (*variable + 1);
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long		castor();

	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2L))
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro178()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, pointer to function returning a long 
 */
{
	static long     i = 1;
	long            increment(), castor();

	if (!(castor(increment, &i) == 2L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12L))
			statusFlag++;
	}
	return (function(*variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            castor();

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2L))
			statusFlag++;
	}
	return (function(*variable));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro179()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, no return value and legal 
 */
{
	static long     i;

	i = 1;
	levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	(*variable) = 3;
	levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 4;
	levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	(*variable) = 5;
	levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 6;
	levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	(*variable) = 7;
	levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 8;
	levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	(*variable) = 9;
	levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 10;
	levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	(*variable) = 11;
	levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 12;
	levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	(*variable) = 13;
	levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	(*variable) = 14;
	levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	(*variable) = 0;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	(*variable) = 0;
}
@def_
@def $macro180()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, no return value and illegal 
 */
{
	static long     i;

	i = 1;
	result = levelOneNodeOne(&i);
	if (i != 0L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (i != 0L)
		statusFlag++;
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	if (*variable != 1L)
		statusFlag++;
	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelOneNodeTwo(variable)
	long           *variable;
{
	if (*variable != 2L)
		statusFlag++;
	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeOne(variable)
	long           *variable;
{
	if (*variable != 3L)
		statusFlag++;
	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	if (*variable != 4L)
		statusFlag++;
	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeThree(variable)
	long           *variable;
{
	if (*variable != 5L)
		statusFlag++;
	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelTwoNodeFour(variable)
	long           *variable;
{
	if (*variable != 6L)
		statusFlag++;
	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (*variable != 0L)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (*variable != 0L)
		statusFlag++;
}

levelThreeLeafOne(variable)
	long           *variable;
{
	if (*variable != 7L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	if (*variable != 8L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	if (*variable != 9L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	if (*variable != 10L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	if (*variable != 11L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	if (*variable != 12L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	if (*variable != 13L)
		statusFlag++;
	*variable = 0;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	if (*variable != 14L)
		statusFlag++;
	*variable = 0;
}
@def_
@def $macro181()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	static long     i;
	long            result = 0, divide4(), dummy1();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L || *Long != 0L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L || *Long != 0L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro182()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, Long function declaration 
 */
{
	static long     i = 1;
	long            levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L) || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            levelTwoNodeOne();

	(*variable) *= 2;
	return (2 * levelTwoNodeOne(variable));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            levelThreeLeafOne();

	(*variable) *= 2;
	return (2 * levelThreeLeafOne(variable));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable) = 0;
	return (2 * i);
}
@def_
@def $macro183()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning a long 
 */
{
	static long     i = 12;
	long            divide4(), dummy1();

	if (dummy1(divide4, &i) != 3L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L || *Long != 0L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L || *Long != 0L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro184()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, no return value, legal 
 */
{
	static long     i = 10;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (*variable != counter)
		statusFlag++;
	(*variable)--;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro185()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, no return value, illegal 
 */
{
	static long     i = 10;

	result = recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (--counter) {
		if (counter != --(*variable))
			statusFlag++;
		result = recursiveFunction(variable);
	}
	return;
}
@def_
@def $macro186()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	static long     i = 1;
	long            result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            result = 0;
	long            recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro187()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning a long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result;
	long            i = *variable, dummy();

	if (--counter) {
		result = dummy(function, &i);
		if (result != 2L || i != 0L)
			statusFlag++;
	}
	return (function((*variable)--));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro188()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, function in conditional expression,
 * Long function declaration 
 */
{
	long            recursiveFunction();
	static long     i = 1;

	if (recursiveFunction(&i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (--counter)
		if (recursiveFunction(&i) - i != 2L)
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro189()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            increment(), dummy();
	static long     i = 1;

	if (dummy(increment, &i) - i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	static long     i;
	long		dummy();

	i = *variable;
	if (--counter)
		if (dummy(function, &i) - i != 2L)
			statusFlag++;
	return (function((*variable)--));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro190()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, no return value, legal 
 */
{
	static long     i = 1;

	castor(&i);
	if (i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 1L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
		if (i != 3L)
			statusFlag++;
	}
	(*variable) = 0;
}

pollux(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 2L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	(*variable) = 3;
}
@def_
@def $macro191()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            result;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, no return value, illegal 
 */
{
	static long     i = 1;

	result = castor(&i);
	if (i != 0L)
		statusFlag++;
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (--counter) {
		result = pollux(&i);
		if (i != 2L)
			statusFlag++;
	}
	*variable = 0;
}

pollux(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (--counter) {
		result = castor(&i);
		if (i != 0L)
			statusFlag++;
	}
	*variable = 2;
}
@def_
@def $macro192()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	static long     i = 1;
	long            result = 0, castor();

	result = castor(&i);
	if (result != 2L || i != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2L)
			statusFlag++;
	}
	return (++(*variable));
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro193()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, pointer to function returning a
 * long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), castor();

	result = castor(increment, &i);
	if (result != 2L || i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != ii + 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != iii + 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long           *variable;
{
	long            i = *variable;

	(*variable)--;
	return (++i);
}
@def_
@def $macro194()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return a long 
 */
{
	static long     i = 1;
	long            castor();

	if (castor(&i) - i != 0L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0L)
			statusFlag++;
	}
	return (++(*variable));
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long            castor();

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0L)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro195()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	static long     i = 1;
	long            increment(), castor();

	if (castor(increment, &i) != i + 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 10;
	if (--counter) {
		if (pollux(function, &ii) != ii + 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            castor();

	iii = *variable - 10;
	if (--counter) {
		if (castor(function, &iii) != iii + 2L)
			statusFlag++;
	}
	return (function(variable));
}

long 
increment(variable)
	long           *variable;
{
	return (--(*variable) + 2);
}
@def_
@def $macro196()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, no return value and legal 
 */
{
	static long     i;

	i = 1;
	levelOneNodeOne(&i);
	i = 2;
	levelOneNodeTwo(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	*variable = 3;
	levelTwoNodeOne(variable);
	*variable = 4;
	levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	long           *variable;
{
	*variable = 5;
	levelTwoNodeThree(variable);
	*variable = 6;
	levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	long           *variable;
{
	*variable = 7;
	levelThreeLeafOne(variable);
	*variable = 8;
	levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	*variable = 9;
	levelThreeLeafThree(variable);
	*variable = 10;
	levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	long           *variable;
{
	*variable = 11;
	levelThreeLeafFive(variable);
	*variable = 12;
	levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	long           *variable;
{
	*variable = 13;
	levelThreeLeafSeven(variable);
	*variable = 14;
	levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;

}

levelThreeLeafTwo(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro197()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            result;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, no return value and illegal 
 */
{
	static long     i;

	i = 1;
	result = levelOneNodeOne(&i);
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	long           *variable;
{
	*variable = 3;
	result = levelTwoNodeOne(variable);
	*variable = 4;
	result = levelTwoNodeTwo(variable);
}

levelOneNodeTwo(variable)
	long           *variable;
{
	*variable = 5;
	result = levelTwoNodeThree(variable);
	*variable = 6;
	result = levelTwoNodeFour(variable);
}

levelTwoNodeOne(variable)
	long           *variable;
{
	*variable = 7;
	result = levelThreeLeafOne(variable);
	*variable = 8;
	result = levelThreeLeafTwo(variable);
}

levelTwoNodeTwo(variable)
	long           *variable;
{
	*variable = 9;
	result = levelThreeLeafThree(variable);
	*variable = 10;
	result = levelThreeLeafFour(variable);
}

levelTwoNodeThree(variable)
	long           *variable;
{
	*variable = 11;
	result = levelThreeLeafFive(variable);
	*variable = 12;
	result = levelThreeLeafSix(variable);
}

levelTwoNodeFour(variable)
	long           *variable;
{
	*variable = 13;
	result = levelThreeLeafSeven(variable);
	*variable = 14;
	result = levelThreeLeafEight(variable);
}

levelThreeLeafOne(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafTwo(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafThree(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFour(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafFive(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSix(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafSeven(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}

levelThreeLeafEight(variable)
	long           *variable;
{
	variable = 0;
	if (variable != 0L)
		statusFlag++;
}
@def_
@def $macro198()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, return value and legal, Long function
 * declaration 
 */
{
	static long     i = 1;
	long            result = 0;
	long            levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
	if (result != 1L)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3L)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4L)
		statusFlag++;
	return (storage);
}

long 
levelOneNodeTwo(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5L)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7L)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeTwo(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9L)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeThree(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11L)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12L)
		statusFlag++;
	return (storage);
}

long 
levelTwoNodeFour(variable)
	long           *variable;
{
	long            storage = *variable, result = 0;
	long            levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13L)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14L)
		statusFlag++;
	return (storage);
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafTwo(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafThree(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafFour(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafFive(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafSix(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafSeven(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}

long 
levelThreeLeafEight(variable)
	long           *variable;
{
	long            i = *variable;

	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (i);
}
@def_
@def $macro199()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning a long 
 */
{
	static long     i;
	long            result = 0, divide4(), dummy1();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 3L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            i;

	i = (*func) (Long);
	if (i != 6L)
		statusFlag++;
	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	(*Long) = 0;
	return (i / 2);
}
@def_
@def $macro200()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, used in conditional expression, Long
 * function declaration 
 */
{
	static long     i = 1;
	long            levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
levelOneNodeOne(variable)
	long           *variable;
{
	long            levelTwoNodeOne();
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return (2 * levelTwoNodeOne(&i));
}

long 
levelTwoNodeOne(variable)
	long           *variable;
{
	long            levelThreeLeafOne();
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	i *= 2;
	return (2 * levelThreeLeafOne(&i));
}

long 
levelThreeLeafOne(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (2 * i);
}
@def_
@def $macro201()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, in conditional expression, pointer to
 * function returning a long 
 */
{
	static long     i = 12;
	long            divide4(), dummy1();

	if (dummy1(divide4, &i) != 3L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy1(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 3L)
		statusFlag++;
	return (ii);
}

long 
divide4(Long)
	long           *Long;
{
	long            divide2(), dummy2();

	return (dummy2(divide2, Long) / 2);
}

long 
dummy2(func, Long)
	long            (*func) (), *Long;
{
	long            ii;

	if ((ii = (*func) (Long)) != 6L)
		statusFlag++;
	return (ii);
}

long 
divide2(Long)
	long           *Long;
{
	long            i = *Long;

	Long = &globalLong;
	if (*Long != 10L)
		statusFlag++;
	return (i / 2);
}
@def_
@def $macro202()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, no return value, legal 
 */
{
	static long     i = 10;

	recursiveFunction(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		recursiveFunction(variable);
}
@def_
@def $macro203()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            result;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, no return value, illegal 
 */
{
	static long     i = 10;

	result = recursiveFunction(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	long           *variable;
{
	if (--counter) {
		result = recursiveFunction(variable);
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
	}
	return;
}
@def_
@def $macro204()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, legal, Long function
 * declaration 
 */
{
	static long     i = 1;
	long            result = 0;
	long            recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 1L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	long            result = 0;
	static long     i;
	long            recursiveFunction();

	i = *variable;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1L)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro205()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, pointer to function returning a
 * long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), dummy();

	result = dummy(increment, &i);
	if (result != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	long            result, dummy();
	static long     i;

	i = *variable;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2L)
			statusFlag++;
	}
	return (function(i));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro206()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, function in conditional expression, Long
 * function declaration 
 */
{
	long            recursiveFunction();
	static long     i = 1;

	if (recursiveFunction(&i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
recursiveFunction(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2L)
			statusFlag++;
	return (i + 1);
}
@def_
@def $macro207()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning a long 
 */
{
	long            increment(), dummy();
	static long     i = 1;

	if (dummy(increment, &i) != 2L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
dummy(function, variable)
	long            (*function) (), *variable;
{
	static long     i;
	long		dummy();

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2L)
			statusFlag++;
	return (function(i));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro208()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, no return value, legal 
 */
{
	static long     i = 1;

	castor(&i);
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 1L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		i++;
		pollux(&i);
	}
}

pollux(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	if (*variable != 2L)
		statusFlag++;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		--i;
		castor(&i);
	}
}
@def_
@def $macro209()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;
long            result;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, no return value, illegal 
 */
{
	static long     i = 1;

	result = castor(&i);
	if (result == 0L)
		result++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		result = pollux(&i);
}

pollux(variable)
	long           *variable;
{
	static long     i;

	i = *variable;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter)
		result = castor(&i);
}
@def_
@def $macro210()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return a long 
 */
{
	static long     i = 2;
	long            result = 0, castor();

	result = castor(&i);
	if (result != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2L)
			statusFlag++;
	}
	return (ii);
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5L)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro211()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, return value, pointer to function returning a long 
 */
{
	static long     i = 1;
	long            result = 0, increment(), castor();

	result = castor(increment, &i);
	if (result != 10L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            result = 0, pollux();

	ii = *variable + 8;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2L)
			statusFlag++;
	}
	return (function(ii));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            result = 0, castor();

	iii = *variable - 8;
	if (--counter) {
		variable = &globalLong;
		if (*variable != 10L)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10L)
			statusFlag++;
	}
	return (function(iii));
}

long 
increment(variable)
	long            variable;
{

	return (++variable);
}
@def_
@def $macro212()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a long 
 */
{
	static long     i = 1;
	long            castor();

	if (castor(&i) != 5L)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(variable)
	long           *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2L)
			statusFlag++;
	}
	return (ii + 1);
}

long 
pollux(variable)
	long           *variable;
{
	static long     iii;
	long            castor();

	iii = *variable - 3;
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5L)
			statusFlag++;
	}
	return (iii + 1);
}
@def_
@def $macro213()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
long            globalLong = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning a long 
 */
{
	static long     i = 1;
	long            increment(), castor();

	if (!(castor(increment, &i) == 12L))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

long 
castor(function, variable)
	long            (*function) (), *variable;
{
	static long     ii;
	long            pollux();

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 2L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (function(ii));
}

long 
pollux(function, variable)
	long            (*function) (), *variable;
{
	static long     iii;
	long            castor();

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 12L))
			statusFlag++;
	}
	variable = &globalLong;
	if (*variable != 10L)
		statusFlag++;
	return (function(iii));
}

long 
increment(variable)
	long            variable;
{
	return (++variable);
}
@def_
@def $macro214()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	short           i = 0, result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	return (*variable);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	return (*variable);
}
@def_
@def $macro215()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	short           i = 0, result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

short 
levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafTwo(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafThree(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafFour(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafFive(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafSix(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafSeven(variable)
	short          *variable;
{
	return (*variable);
}

short 
levelThreeLeafEight(variable)
	short          *variable;
{
	return (*variable);
}
@def_
@def $macro216()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s, *levelOne();
	short           i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	if (*variable != 1)
		statusFlag++;
	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	return (s);
}
@def_
@def $macro217()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, return value, legal pointer to function
 * returning an integer 
 */
{
	short           i, result = 0, divide4();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	return (*integer / 2);
}
@def_
@def $macro218()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	short           i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           ii, jj;
	jj = (ii = (*variable) + 1) + 1;
	return (levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj));
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           iii, jjj;
	jjj = (iii = (*variable) + 1) + 1;
	return (levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj));
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           iiii, jjjj;
	jjjj = (iiii = (*variable) + 1) + 1;
	return (levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj));
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           iiiii, jjjjj;
	jjjjj = (iiiii = (*variable) + 1) + 1;
	return (levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj));
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           iiiiii, jjjjjj;
	jjjjjj = (iiiiii = (*variable) + 1) + 1;
	return (levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj));
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = (*variable) + 1) + 1;
	return (levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj));
}

levelThreeLeafOne(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	return ((*variable) + 1);
}
@def_
@def $macro219()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, used in conditional expression, integer
 * function declaration 
 */
{
	short           i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           ii, levelTwoNodeOne();

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           iii, levelThreeLeafOne();

	iii = 2 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro220()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: automatic variable address instance  : linear tree structure, used in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char            i = 4, j, *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) == compare(skip(&j), "across", 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < *skipper; ii++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro221()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           i, divide4();

	i = 12;
	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	return (*integer / 2);
}
@def_
@def $macro222()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, legal, no function declaration 
 */
{
	short           i = 1, result;

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable, result = 0;

	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro223()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, legal, integer function declaration 
 */
{
	short           i = 1, result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable, result = 0;
	short           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro224()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *recursiveFunction();
	short           i = 2;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + (*variable));
}
@def_
@def $macro225()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	short           i = 1, result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro226()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	short           i = 1;

	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	if (--counter)
		if (!(recursiveFunction(variable) - (*variable) == 1))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro227()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           recursiveFunction();
	short           i = 1;

	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro228()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address instance  : recursive call, in conditional expression, function declared to return
 * a pointer to character 
 */
{
	char           *recursiveFunction();
	short           i = 2;

	if (!(*recursiveFunction(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	if (--counter)
		if (!(*recursiveFunction(variable) == '2'))
			statusFlag++;
	return (numbers + *variable);
}
@def_
@def $macro229()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : recursive call, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           increment();
	short           i = 1;

	if (!(dummy(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	if (--counter)
		if (!(dummy(function, variable) == 2))
			statusFlag++;
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro230()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, legal, no function declaration 
 */
{
	short           i = 1, result = 0;

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0;

	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return (*variable + 1);
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro231()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	short           i = 1, result = 0, castor();

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0, pollux();

	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return (*variable + 1);
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro232()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address instance  : gemini, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *castor();
	short           i = 2;

	s = castor(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	short           ii = *variable + 4;
	char           *s, *pollux();

	if (--counter) {
		s = pollux(&ii);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + *variable);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	char           *s;

	if (--counter) {
		s = castor(&iii);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + *variable);
}
@def_
@def $macro233()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, return value, pointer to function returning an integer 
 */
{
	short           i = 1, result = 0, increment();

	result = castor(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 8, result = 0;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10)
			statusFlag++;
	}
	return (function(*variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 8, result = 0;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2)
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro234()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, no function declaration 
 */
{
	short           i = 1;

	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return (++(*variable));
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro235()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, function declared to return an
 * integer 
 */
{
	short           i = 1, castor();

	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, pollux();

	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return (++(*variable));
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro236()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	char           *castor();
	short           i = 2;

	if (!(*castor(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	short           ii = *variable + 4;

	if (--counter) {
		if (!(*pollux(&ii) == '6'))
			statusFlag++;
	}
	return (numbers + *variable);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	if (--counter) {
		if (!(*castor(&iii) == '2'))
			statusFlag++;
	}
	return (numbers + *variable);
}
@def_
@def $macro237()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{
	short           i = 1, increment();

	if (!(castor(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12))
			statusFlag++;
	}
	return (function(*variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2))
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro238()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	short           i = 0, result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}
@def_
@def $macro239()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, return value and legal,
 * integer function declaration 
 */
{
	short           i = 0, result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}
@def_
@def $macro240()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	short           i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1' || i != 4)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2' || *variable != 4)
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3' || *variable != 4)
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	(*variable)++;
	return (s);
}
@def_
@def $macro241()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, return value, legal pointer
 * to function returning an integer 
 */
{
	short           i, result = 0, divide4();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3 || *integer != 0)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6 || *integer != 0)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro242()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, no function declaration 
 */
{
	short           i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (i != 3 || j != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           ii, jj, storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	if (ii != 3 || jj != 4)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           iii, jjj, storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	if (iii != 4 || jjj != 5)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           iiii, jjjj, storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	if (iiii != 4 || jjjj != 5)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           iiiii, jjjjj, storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	if (iiiii != 5 || jjjjj != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           iiiiii, jjjjjj, storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	if (iiiiii != 5 || jjjjjj != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           iiiiiii, jjjjjjj, storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	if (iiiiiii != 6 || jjjjjjj != 7)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafThree(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafFour(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafFive(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafSix(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafEight(variable)
	short          *variable;
{
	return (++(*variable));
}
@def_
@def $macro243()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	short           i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32) || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           levelTwoNodeOne();

	(*variable) *= 2;
	return (2 * levelTwoNodeOne(variable));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           levelThreeLeafOne();

	(*variable) *= 2;
	return (2 * levelThreeLeafOne(variable));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (2 * i);
}
@def_
@def $macro244()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	short           statusFlag = NoMistake;
	char            i = 4, j, *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (i != 0 || j != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro245()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: automatic variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning an integer 
 */
{
	short           i = 12, divide4();

	if (dummy1(divide4, &i) != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3 || *integer != 0)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6 || *integer != 0)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro246()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	short           i = 1, result;

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != (*variable))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro247()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, legal, integer
 * function declaration 
 */
{
	short           i = 1, result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;
	short           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro248()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	short           i = 2;

	s = recursiveFunction(&i);
	if (*s != '2' || i != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;
	short           i = *variable;

	if (--counter) {
		s = recursiveFunction(&i);
		if (*s != '2' || i != 3)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro249()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	short           i = 1, result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result, i = *variable;

	if (--counter) {
		result = dummy(function, &i);
		if (result != 2 || i != 0)
			statusFlag++;
	}
	return (function((*variable)--));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro250()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, function in conditional expression,
 * no function declaration 
 */
{
	short           i = 1;

	if (!(recursiveFunction(&i) - i == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	if (--counter)
		if (!(recursiveFunction(&i) - i == 2))
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro251()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	short           recursiveFunction();
	short           i = 1;

	if (recursiveFunction(&i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	if (--counter)
		if (recursiveFunction(&i) - i != 2)
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro252()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *recursiveFunction();
	short           i = 2;

	if (*recursiveFunction(&i) != '2' || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	if (--counter)
		if (!(*recursiveFunction(&i) == '2') || !(i == 1))
			statusFlag++;
	return (numbers + (*variable)--);
}
@def_
@def $macro253()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : recursive call, in conditional expression, pointer
 * to function returning an integer 
 */
{
	short           increment();
	short           i = 1;

	if (dummy(increment, &i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           i = *variable;
	if (--counter)
		if (dummy(function, &i) - i != 2)
			statusFlag++;
	return (function((*variable)--));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro254()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, no function
 * declaration 
 */
{
	short           i = 1, result = 0;

	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0;

	if (--counter) {
		result = pollux(&ii);
		if (result != 5 || ii != 3)
			statusFlag++;
	}
	return (++(*variable));
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	if (--counter) {
		result = castor(&iii);
		if (result != 2 || iii != 2)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro255()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	short           i = 1, result = 0, castor();

	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0, pollux();

	if (--counter) {
		result = pollux(&ii);
		if (result != 5 || ii != 3)
			statusFlag++;
	}
	return (++(*variable));
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	if (--counter) {
		result = castor(&iii);
		if (result != 2 || iii != 2)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro256()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s, *castor();
	short           i = 2;

	s = castor(&i);
	if (*s != '2' || i != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	short           ii = *variable + 4;
	char           *s, *pollux();

	if (--counter) {
		s = pollux(&ii);
		if (*s != '6' || ii != 7)
			statusFlag++;
	}
	return (numbers + (*variable)--);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	char           *s;

	if (--counter) {
		s = castor(&iii);
		if (*s != '2' || iii != 1)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro257()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, pointer to function returning
 * an integer 
 */
{
	short           i = 1, result = 0, increment();

	result = castor(increment, &i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 8, result = 0;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10 || ii != 0)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 8, result = 0;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2 || iii != 0)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (++i);
}
@def_
@def $macro258()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	short           i = 1;

	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return (++(*variable));
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro259()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, function
 * declared to return an integer 
 */
{
	short           i = 1, castor();

	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, pollux();

	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return (++(*variable));
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro260()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *castor();
	short           i = 2;

	if (!(*castor(&i) == '2') || !!(i != 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	short           ii = *variable + 4;

	if (--counter) {
		if (!(*pollux(&ii) == '6') || !!(ii != 5))
			statusFlag++;
	}
	return (numbers + (*variable)--);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	if (--counter) {
		if (!(*castor(&iii) == '2') || !!!(iii == 1))
			statusFlag++;
	}
	return (numbers + (*variable)--);
}
@def_
@def $macro261()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           i = 1, increment();

	if (!(castor(increment, &i) == 2) || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12) || ii != 10)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2) || iii != 0)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short          *variable;
{
	return (--(*variable) + 2);
}
@def_
@def $macro262()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	short           i = 1, result = 0;

	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}
@def_
@def $macro263()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	short           i = 1, result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

short 
levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}
@def_
@def $macro264()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	short           i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s);
}
@def_
@def $macro265()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	short           i, result = 0, divide4();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro266()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, used in conditional expression, no
 * function declaration 
 */
{
	short           i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           ii, jj, storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           iii, jjj, storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           iiii, jjjj, storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           iiiii, jjjjj, storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           iiiiii, jjjjjj, storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           iiiiiii, jjjjjjj, storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}
@def_
@def $macro267()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: automatic variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	short           i = 1, levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           levelTwoNodeOne();
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return (2 * levelTwoNodeOne(&i));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           levelThreeLeafOne();
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return (2 * levelThreeLeafOne(&i));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (2 * i);
}
@def_
@def $macro268()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";
char            globalCharacter = 10;
short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: automatic variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	char            i = 4, j, *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	skipper = &globalCharacter;
	if (*skipper != 10)
		statusFlag++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro269()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : linear tree structure, in conditional expression, pointer
 * to function returning an integer 
 */
{
	short           i = 12, divide4();

	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i / 2);
}
@def_
@def $macro270()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	short           i = 1, result;

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           result = 0, i = *variable;

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro271()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	short           i = 1, result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           result = 0, i = *variable;
	short           recursiveFunction();

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro272()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, function declared to return
 * a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	short           i = 2;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;
	short           i = *variable;

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = recursiveFunction(&i);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + i);
}
@def_
@def $macro273()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	short           i = 1, result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result, i = *variable;

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2)
			statusFlag++;
	}
	return (function(i));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro274()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	short           i = 1;

	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return (i + 1);
}
@def_
@def $macro275()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	short           recursiveFunction();
	short           i = 1;

	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return (++i);
}
@def_
@def $macro276()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *recursiveFunction();
	short           i = 2;

	if (*recursiveFunction(&i) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (!(*recursiveFunction(&i) == '2'))
			statusFlag++;
	return (numbers + i);
}
@def_
@def $macro277()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           increment();
	short           i = 1;

	if (dummy(increment, &i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2)
			statusFlag++;
	return (function(i));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro278()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, no function
 * declaration 
 */
{
	short           i = 2, result = 0;

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return (ii);
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro279()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	short           i = 2, result = 0, castor();

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, result = 0, pollux();

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return (ii);
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3, result = 0;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro280()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s, *castor();
	short           i = 2;

	s = castor(&i);
	if (*s != '6')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	short           ii = *variable + 4;
	char           *s, *pollux();

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = pollux(&ii);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + ii);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	char           *s;

	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = castor(&iii);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + iii);
}
@def_
@def $macro281()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	short           i = 1, result = 0, increment();

	result = castor(increment, &i);
	if (result != 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 8, result = 0;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2)
			statusFlag++;
	}
	return (function(ii));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 8, result = 0;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10)
			statusFlag++;
	}
	return (function(iii));
}

short 
increment(variable)
	short           variable;
{

	return (++variable);
}
@def_
@def $macro282()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, no function declaration 
 */
{
	short           i = 1;

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	short           ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return (++ii);
}

pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return (++iii);
}
@def_
@def $macro283()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	short           i = 1, castor();

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	short           ii = *variable + 3, pollux();

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return (++ii);
}

short 
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return (++iii);
}
@def_
@def $macro284()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	char           *castor();
	short           i = 2;

	if (!(*castor(&i) == '6'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	short           ii = *variable + 4;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*pollux(&ii) == '2'))
			statusFlag++;
	}
	return (numbers + ii);
}

char           *
pollux(variable)
	short          *variable;
{
	short           iii = *variable - 4;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*castor(&iii) == '6'))
			statusFlag++;
	}
	return (numbers + iii);
}
@def_
@def $macro285()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: automatic variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	short           i = 1, increment();

	if (!(castor(increment, &i) == 12))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	short           ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 2))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (function(ii));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	short           iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 12))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (function(iii));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro286()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, return value and legal, no function declaration 
 */
{
	static short    i = 0;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 3;
	result = levelTwoNodeOne(&variable);
	if (result != 3)
		statusFlag++;
	variable = 4;
	result = levelTwoNodeTwo(&variable);
	if (result != 4)
		statusFlag++;
	return (*argument);
}

levelOneNodeTwo(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 5;
	result = levelTwoNodeThree(&variable);
	if (result != 5)
		statusFlag++;
	variable = 6;
	result = levelTwoNodeFour(&variable);
	if (result != 6)
		statusFlag++;
	return (*argument);
}

levelTwoNodeOne(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 7;
	result = levelThreeLeafOne(&variable);
	if (result != 7)
		statusFlag++;
	variable = 8;
	result = levelThreeLeafTwo(&variable);
	if (result != 8)
		statusFlag++;
	return (*argument);
}

levelTwoNodeTwo(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 9;
	result = levelThreeLeafThree(&variable);
	if (result != 9)
		statusFlag++;
	variable = 10;
	result = levelThreeLeafFour(&variable);
	if (result != 10)
		statusFlag++;
	return (*argument);
}

levelTwoNodeThree(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 11;
	result = levelThreeLeafFive(&variable);
	if (result != 11)
		statusFlag++;
	variable = 12;
	result = levelThreeLeafSix(&variable);
	if (result != 12)
		statusFlag++;
	return (*argument);
}

levelTwoNodeFour(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;

	variable = 13;
	result = levelThreeLeafSeven(&variable);
	if (result != 13)
		statusFlag++;
	variable = 14;
	result = levelThreeLeafEight(&variable);
	if (result != 14)
		statusFlag++;
	return (*argument);
}

levelThreeLeafOne(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafTwo(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafThree(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafFour(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafFive(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafSix(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafSeven(argument)
	short          *argument;
{
	return (*argument);
}

levelThreeLeafEight(argument)
	short          *argument;
{
	return (*argument);
}
@def_
@def $macro287()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, return value and legal, integer function
 * declaration 
 */
{
	static short    i = 0;
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	variable = 3;
	result = levelTwoNodeOne(&variable);
	if (result != 3)
		statusFlag++;
	variable = 4;
	result = levelTwoNodeTwo(&variable);
	if (result != 4)
		statusFlag++;
	return (*argument);
}

short 
levelOneNodeTwo(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	variable = 5;
	result = levelTwoNodeThree(&variable);
	if (result != 5)
		statusFlag++;
	variable = 6;
	result = levelTwoNodeFour(&variable);
	if (result != 6)
		statusFlag++;
	return (*argument);
}

short 
levelTwoNodeOne(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	variable = 7;
	result = levelThreeLeafOne(&variable);
	if (result != 7)
		statusFlag++;
	variable = 8;
	result = levelThreeLeafTwo(&variable);
	if (result != 8)
		statusFlag++;
	return (*argument);
}

short 
levelTwoNodeTwo(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	variable = 9;
	result = levelThreeLeafThree(&variable);
	if (result != 9)
		statusFlag++;
	variable = 10;
	result = levelThreeLeafFour(&variable);
	if (result != 10)
		statusFlag++;
	return (*argument);
}

short 
levelTwoNodeThree(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	variable = 11;
	result = levelThreeLeafFive(&variable);
	if (result != 11)
		statusFlag++;
	variable = 12;
	result = levelThreeLeafSix(&variable);
	if (result != 12)
		statusFlag++;
	return (*argument);
}

short 
levelTwoNodeFour(argument)
	short          *argument;
{
	short           result = 0;
	static short    variable;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	variable = 13;
	result = levelThreeLeafSeven(&variable);
	if (result != 13)
		statusFlag++;
	variable = 14;
	result = levelThreeLeafEight(&variable);
	if (result != 14)
		statusFlag++;
	return (*argument);
}

short 
levelThreeLeafOne(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafTwo(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafThree(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafFour(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafFive(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafSix(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafSeven(argument)
	short          *argument;
{
	return (*argument);
}

short 
levelThreeLeafEight(argument)
	short          *argument;
{
	return (*argument);
}
@def_
@def $macro288()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, return value and legal, function declared to
 * return a pointer to character 
 */
{
	char           *s, *levelOne();
	static short    i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	if (*variable != 1)
		statusFlag++;
	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	return (s);
}
@def_
@def $macro289()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, return value, legal pointer to function returning
 * an integer 
 */
{
	static short    i = 12;
	short           result = 0, divide4();

	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	return (*integer / 2);
}
@def_
@def $macro290()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, used in conditional expression, no function
 * declaration 
 */
{
	static short    i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	static short    ii, jj;
	jj = (ii = (*variable) + 1) + 1;
	return (levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj));
}

levelOneNodeTwo(variable)
	short          *variable;
{
	static short    iii, jjj;
	jjj = (iii = (*variable) + 1) + 1;
	return (levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj));
}

levelTwoNodeOne(variable)
	short          *variable;
{
	static short    iiii, jjjj;
	jjjj = (iiii = (*variable) + 1) + 1;
	return (levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj));
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	static short    iiiii, jjjjj;
	jjjjj = (iiiii = (*variable) + 1) + 1;
	return (levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj));
}

levelTwoNodeThree(variable)
	short          *variable;
{
	static short    iiiiii, jjjjjj;
	jjjjjj = (iiiiii = (*variable) + 1) + 1;
	return (levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj));
}

levelTwoNodeFour(variable)
	short          *variable;
{
	static short    iiiiiii, jjjjjjj;
	jjjjjjj = (iiiiiii = (*variable) + 1) + 1;
	return (levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj));
}

levelThreeLeafOne(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	return ((*variable) + 1);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	return ((*variable) + 1);
}
@def_
@def $macro291()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, used in conditional expression, integer function
 * declaration 
 */
{
	static short    i = 1;
	short           levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	static short    ii;
	short           levelTwoNodeOne();

	ii = 2 * (*variable);
	return (2 * levelTwoNodeOne(&ii));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	static short    iii;
	short           levelThreeLeafOne();

	iii = 2 * (*variable);
	return (2 * levelThreeLeafOne(&iii));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	return (2 * (*variable));
}
@def_
@def $macro292()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: static variable address instance  : linear tree structure, used in conditional expression, function declared
 * to return a pointer to character 
 */
{
	static char     i = 4, j;
	char           *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) == compare(skip(&j), "across", 6))
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	short           ii;
	char           *pointer;

	for (ii = 0, pointer = protean; ii < *skipper; ii++)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro293()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address instance  : linear tree structure, in conditional expression, pointer to function
 * returning an integer 
 */
{
	static short    i = 12;
	short           divide4();

	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	return (*integer / 2);
}
@def_
@def $macro294()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, legal, no function declaration 
 */
{
	static short    i = 1;
	short           result;

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	static short    i;
	short           result = 0;

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro295()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, legal, integer function declaration 
 */
{
	static short    i = 1;
	short           result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	static short    i;
	short           result = 0;
	short           recursiveFunction();

	i = *variable;
	if (--counter) {
		result = recursiveFunction(&i);
		if (result != 2)
			statusFlag++;
	}
	return (i + 1);
}
@def_
@def $macro296()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: static variable address instance  : recursive call, return value, function declared to return a pointer to
 * character 
 */
{
	char           *s, *recursiveFunction();
	static short    i = 2;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;

	if (--counter) {
		s = recursiveFunction(variable);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + (*variable));
}
@def_
@def $macro297()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, return value, pointer to function returning an integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result;

	if (--counter) {
		result = dummy(function, variable);
		if (result != 2)
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro298()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, function in conditional expression, no function
 * declaration 
 */
{
	static short    i = 1;

	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	if (--counter)
		if (!(recursiveFunction(variable) - (*variable) == 1))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro299()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, function in conditional expression, integer function
 * declaration 
 */
{
	short           recursiveFunction();
	static short    i = 1;

	if (!(recursiveFunction(&i) - i == 1))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           recursiveFunction();

	if (--counter)
		if (!(recursiveFunction(variable) - *variable == 1))
			statusFlag++;
	return ((*variable) + 1);
}
@def_
@def $macro300()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: static variable address instance  : recursive call, in conditional expression, function declared to return a
 * pointer to character 
 */
{
	char           *recursiveFunction();
	static short    i = 2;

	if (!(*recursiveFunction(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	if (--counter)
		if (!(*recursiveFunction(variable) == '2'))
			statusFlag++;
	return (numbers + *variable);
}
@def_
@def $macro301()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : recursive call, in conditional expression, pointer to function returning
 * an integer 
 */
{
	short           increment();
	static short    i = 1;

	if (!(dummy(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	if (--counter)
		if (!(dummy(function, variable) == 2))
			statusFlag++;
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro302()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, legal, no function declaration 
 */
{
	static short    i = 1;
	short           result = 0;

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return (*variable + 1);
}

pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro303()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, legal, function declared to return an integer 
 */
{
	static short    i = 1;
	short           result = 0, castor();

	result = castor(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0, pollux();

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != 5)
			statusFlag++;
	}
	return (*variable + 1);
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != 2)
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro304()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: static variable address instance  : gemini, return value, function declared to return a pointer to character 
 */
{
	char           *s, *castor();
	static short    i = 2;

	s = castor(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	static short    ii;
	char           *s, *pollux();

	ii = *variable + 4;
	if (--counter) {
		s = pollux(&ii);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + *variable);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		s = castor(&iii);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + *variable);
}
@def_
@def $macro305()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, return value, pointer to function returning an integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = castor(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != 10)
			statusFlag++;
	}
	return (function(*variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != 2)
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro306()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, no function declaration 
 */
{
	static short    i = 1;

	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;

	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return (*variable + 1);
}

pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro307()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, function declared to return an integer 
 */
{
	static short    i = 1;
	short           castor();

	if (!(castor(&i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           pollux();

	ii = *variable + 3;
	if (--counter) {
		if (!(pollux(&ii) == 5))
			statusFlag++;
	}
	return (*variable + 1);
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (!(castor(&iii) == 2))
			statusFlag++;
	}
	return (*variable + 1);
}
@def_
@def $macro308()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, function declared to return a pointer
 * to character 
 */
{
	char           *castor();
	static short    i = 2;

	if (!(*castor(&i) == '2'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	static short    ii;

	ii = *variable + 4;
	if (--counter) {
		if (!(*pollux(&ii) == '6'))
			statusFlag++;
	}
	return (numbers + *variable);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 4;
	if (--counter) {
		if (!(*castor(&iii) == '2'))
			statusFlag++;
	}
	return (numbers + *variable);
}
@def_
@def $macro309()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address instance  : gemini, in conditional expression, pointer to function returning an
 * integer 
 */
{
	static short    i = 1;
	short           increment();

	if (!(castor(increment, &i) == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 12))
			statusFlag++;
	}
	return (function(*variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 2))
			statusFlag++;
	}
	return (function(*variable));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro310()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, return value and legal, no
 * function declaration 
 */
{
	static short    i = 0;
	short           result = 0;

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}
@def_
@def $macro311()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, return value and legal,
 * integer function declaration 
 */
{
	static short    i = 0;
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	i = 1;
	result = levelOneNodeOne(&i);
	if (result != 1 || i != 0)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	(*variable) = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3 || *variable != 0)
		statusFlag++;
	(*variable) = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	(*variable) = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5 || *variable != 0)
		statusFlag++;
	(*variable) = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	(*variable) = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7 || *variable != 0)
		statusFlag++;
	(*variable) = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	(*variable) = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9 || *variable != 0)
		statusFlag++;
	(*variable) = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	(*variable) = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11 || *variable != 0)
		statusFlag++;
	(*variable) = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = (*variable), result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	(*variable) = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13 || *variable != 0)
		statusFlag++;
	(*variable) = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14 || *variable != 0)
		statusFlag++;
	return (storage);
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}

short 
levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (i);
}
@def_
@def $macro312()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, return value and legal,
 * function declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	static short    i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1' || i != 4)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2' || *variable != 4)
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3' || *variable != 4)
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	(*variable)++;
	return (s);
}
@def_
@def $macro313()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	static short    i;
	short           result = 0, divide4();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3 || *integer != 0)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6 || *integer != 0)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro314()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, no function declaration 
 */
{
	static short    i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (i != 3 || j != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	static short    ii, jj, storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	if (ii != 3 || jj != 4)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	static short    iii, jjj, storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	if (iii != 4 || jjj != 5)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	static short    iiii, jjjj, storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	if (iiii != 4 || jjjj != 5)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	static short    iiiii, jjjjj, storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	if (iiiii != 5 || jjjjj != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	static short    iiiiii, jjjjjj, storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	if (iiiiii != 5 || jjjjjj != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	static short    iiiiiii, jjjjjjj, storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	if (iiiiiii != 6 || jjjjjjj != 7)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafThree(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafFour(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafFive(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafSix(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	return (++(*variable));
}

levelThreeLeafEight(variable)
	short          *variable;
{
	return (++(*variable));
}
@def_
@def $macro315()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, integer function declaration 
 */
{
	static short    i = 1;
	short           levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32) || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           levelTwoNodeOne();

	(*variable) *= 2;
	return (2 * levelTwoNodeOne(variable));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           levelThreeLeafOne();

	(*variable) *= 2;
	return (2 * levelThreeLeafOne(variable));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable) = 0;
	return (2 * i);
}
@def_
@def $macro316()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	short           statusFlag = NoMistake;
	static char     i = 4, j;
	char           *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (i != 0 || j != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro317()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;

main()
/*
 * test class: static variable address, changed to effect instance  : linear tree structure, in conditional expression,
 * pointer to function returning an integer 
 */
{
	static short    i = 12;
	short           divide4();

	if (dummy1(divide4, &i) != 3 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3 || *integer != 0)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6 || *integer != 0)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro318()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, legal, no function
 * declaration 
 */
{
	static short    i = 1;
	short           result;

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != (*variable))
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro319()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	static short    i = 1;
	short           result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != i)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;
	short           recursiveFunction();

	if (--counter) {
		result = recursiveFunction(variable);
		if (result != *variable)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro320()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890";

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, function declared to
 * return a pointer to character 
 */
{
	char           *s, *recursiveFunction();
	static short    i = 2;

	s = recursiveFunction(&i);
	if (*s != '0' + i - 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;
	static short    i;

	i = *variable;
	if (--counter) {
		s = recursiveFunction(&i);
		if (*s != '0' + (i - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro321()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, return value, pointer to function
 * returning an integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result;
	short           i = *variable;

	if (--counter) {
		result = dummy(function, &i);
		if (result != 2 || i != 0)
			statusFlag++;
	}
	return (function((*variable)--));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro322()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	static short    i = 1;

	if (!(recursiveFunction(&i) - i == 2))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	if (--counter)
		if (!(recursiveFunction(&i) - i == 2))
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro323()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, function in conditional expression,
 * integer function declaration 
 */
{
	short           recursiveFunction();
	static short    i = 1;

	if (recursiveFunction(&i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	if (--counter)
		if (recursiveFunction(&i) - i != 2)
			statusFlag++;
	return ((*variable)-- + 1);
}
@def_
@def $macro324()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "012345678901234";

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, in conditional expression, function
 * declared to return a pointer to character 
 */
{
	char           *recursiveFunction();
	static short    i = 2;
	char            c;

	c = *recursiveFunction(&i);
	if (c != '0' + i - 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	static short    i;
	char            c;

	i = *variable;
	if (--counter) {
		c = *recursiveFunction(&i);
		if (c != '0' + (i - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro325()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           increment();
	static short    i = 1;

	if (dummy(increment, &i) - i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	static short    i;

	i = *variable;
	if (--counter)
		if (dummy(function, &i) - i != 2)
			statusFlag++;
	return (function((*variable)--));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro326()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, no function declaration 
 */
{
	static short    i = 1;
	short           result = 0;

	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return (++(*variable));
}

pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro327()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	static short    i = 1;
	short           result = 0, castor();

	result = castor(&i);
	if (result != 2 || i != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0, pollux();

	ii = *variable + 3;
	if (--counter) {
		result = pollux(&ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return (++(*variable));
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	if (--counter) {
		result = castor(&iii);
		if (result != iii)
			statusFlag++;
	}
	return (--(*variable) + 2);
}
@def_
@def $macro328()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890123456";

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s, *castor();
	static short    i = 2;

	s = castor(&i);
	if (*s != '0' + i - 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	static short    ii;
	char           *s, *pollux();

	ii = *variable + 4;
	if (--counter) {
		s = pollux(&ii);
		if (*s != '0' + (ii - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		s = castor(&iii);
		if (*s != '0' + (iii - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro329()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = castor(increment, &i);
	if (result != 2 || i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		result = pollux(function, &ii);
		if (result != ii + 2)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		result = castor(function, &iii);
		if (result != iii + 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short          *variable;
{
	short           i = *variable;

	(*variable)--;
	return (++i);
}
@def_
@def $macro330()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, no function
 * declaration 
 */
{
	static short    i = 1;

	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return (++(*variable));
}

pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro331()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return an integer 
 */
{
	static short    i = 1;
	short           castor();

	if (castor(&i) - i != 0)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           pollux();

	ii = *variable + 3;
	if (--counter) {
		if (pollux(&ii) - ii != 0)
			statusFlag++;
	}
	return (++(*variable));
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	if (--counter) {
		if (castor(&iii) - iii != 0)
			statusFlag++;
	}
	return (++(*variable));
}
@def_
@def $macro332()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "01234567890123456789012345";

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, function declared
 * to return a pointer to character 
 */
{
	char           *castor();
	static short    i = 13;
	char            c;

	c = *castor(&i);
	if (c != '0' + (i - 1) % 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	static short    ii;
	char            c;

	ii = *variable + 2;
	if (--counter) {
		c = *pollux(&ii);
		if (c != '0' + (ii - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;
	char            c;

	iii = *variable - 2;
	if (--counter) {
		c = *castor(&iii);
		if (c != '0' + (iii - 1) % 10)
			statusFlag++;
	}
	return (numbers + (*variable)++);
}
@def_
@def $macro333()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	static short    i = 1;
	short           increment();

	if (castor(increment, &i) != i + 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;

	ii = *variable + 10;
	if (--counter) {
		if (pollux(function, &ii) != ii + 2)
			statusFlag++;
	}
	return (function(variable));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;

	iii = *variable - 10;
	if (--counter) {
		if (castor(function, &iii) != iii + 2)
			statusFlag++;
	}
	return (function(variable));
}

short 
increment(variable)
	short          *variable;
{
	return (--(*variable) + 2);
}
@def_
@def $macro334()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, return value and legal, no function
 * declaration 
 */
{
	static short    i = 1;
	short           result = 0;

	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}
@def_
@def $macro335()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, return value and legal, integer
 * function declaration 
 */
{
	static short    i = 1;
	short           result = 0;
	short           levelOneNodeOne(), levelOneNodeTwo();

	result = levelOneNodeOne(&i);
	if (result != 1)
		statusFlag++;
	i = 2;
	result = levelOneNodeTwo(&i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelTwoNodeOne(), levelTwoNodeTwo();

	*variable = 3;
	result = levelTwoNodeOne(variable);
	if (result != 3)
		statusFlag++;
	*variable = 4;
	result = levelTwoNodeTwo(variable);
	if (result != 4)
		statusFlag++;
	return (storage);
}

short 
levelOneNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelTwoNodeThree(), levelTwoNodeFour();

	*variable = 5;
	result = levelTwoNodeThree(variable);
	if (result != 5)
		statusFlag++;
	*variable = 6;
	result = levelTwoNodeFour(variable);
	if (result != 6)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafOne(), levelThreeLeafTwo();

	*variable = 7;
	result = levelThreeLeafOne(variable);
	if (result != 7)
		statusFlag++;
	*variable = 8;
	result = levelThreeLeafTwo(variable);
	if (result != 8)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeTwo(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafThree(), levelThreeLeafFour();

	*variable = 9;
	result = levelThreeLeafThree(variable);
	if (result != 9)
		statusFlag++;
	*variable = 10;
	result = levelThreeLeafFour(variable);
	if (result != 10)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeThree(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafFive(), levelThreeLeafSix();

	*variable = 11;
	result = levelThreeLeafFive(variable);
	if (result != 11)
		statusFlag++;
	*variable = 12;
	result = levelThreeLeafSix(variable);
	if (result != 12)
		statusFlag++;
	return (storage);
}

short 
levelTwoNodeFour(variable)
	short          *variable;
{
	short           storage = *variable, result = 0;
	short           levelThreeLeafSeven(), levelThreeLeafEight();

	*variable = 13;
	result = levelThreeLeafSeven(variable);
	if (result != 13)
		statusFlag++;
	*variable = 14;
	result = levelThreeLeafEight(variable);
	if (result != 14)
		statusFlag++;
	return (storage);
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}

short 
levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (i);
}
@def_
@def $macro336()
$LICENSE()
$HEAD()

static char    *numbers = "0123456789";
short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, return value and legal, function
 * declared to return a pointer to character 
 */
{
	char           *s, *levelOne();
	static short    i;

	i = 1;
	s = levelOne(&i);
	if (*s != '1')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
levelOne(variable)
	short          *variable;
{
	char           *s1, *s2, *levelTwo();
	short           j;

	for (s1 = numbers, j = 0; j < *variable; j++, s1++);
	(*variable)++;
	s2 = levelTwo(variable);
	if (*s2 != '2')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s1);
}

char           *
levelTwo(variable)
	short          *variable;
{
	char           *s1, *s2, *levelThree();
	short           k;

	if (*variable != 2)
		statusFlag++;
	for (s1 = numbers, k = 0; k < *variable; k++, s1++);
	(*variable)++;
	s2 = levelThree(variable);
	if (*s2 != '3')
		statusFlag++;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s1);
}

char           *
levelThree(variable)
	short          *variable;
{
	char           *s;
	short           l;

	if (*variable != 3)
		statusFlag++;
	for (s = numbers, l = 0; l < *variable; l++, s++);
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (s);
}
@def_
@def $macro337()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, return value, legal pointer to
 * function returning an integer 
 */
{
	static short    i;
	short           result = 0, divide4();

	i = 12;
	result = dummy1(divide4, &i);
	if (result != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 3)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           i;

	i = (*func) (integer);
	if (i != 6)
		statusFlag++;
	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	(*integer) = 0;
	return (i / 2);
}
@def_
@def $macro338()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, used in conditional expression, no
 * function declaration 
 */
{
	static short    i = 1, j;

	j = i++;
	if (!(levelOneNodeOne(&j) + levelOneNodeTwo(&i) == 44))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

levelOneNodeOne(variable)
	short          *variable;
{
	static short    ii, jj, storage;
	jj = (ii = ++(*variable)) + 1;
	storage = levelTwoNodeOne(&ii) + levelTwoNodeTwo(&jj);
	return (storage);
}

levelOneNodeTwo(variable)
	short          *variable;
{
	static short    iii, jjj, storage;
	jjj = (iii = ++(*variable)) + 1;
	storage = levelTwoNodeThree(&iii) + levelTwoNodeFour(&jjj);
	return (storage);
}

levelTwoNodeOne(variable)
	short          *variable;
{
	static short    iiii, jjjj, storage;
	jjjj = (iiii = ++(*variable)) + 1;
	storage = levelThreeLeafOne(&iiii) + levelThreeLeafTwo(&jjjj);
	return (storage);
}

levelTwoNodeTwo(variable)
	short          *variable;
{
	static short    iiiii, jjjjj, storage;
	jjjjj = (iiiii = ++(*variable)) + 1;
	storage = levelThreeLeafThree(&iiiii) + levelThreeLeafFour(&jjjjj);
	return (storage);
}

levelTwoNodeThree(variable)
	short          *variable;
{
	static short    iiiiii, jjjjjj, storage;
	jjjjjj = (iiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafFive(&iiiiii) + levelThreeLeafSix(&jjjjjj);
	return (storage);
}

levelTwoNodeFour(variable)
	short          *variable;
{
	static short    iiiiiii, jjjjjjj, storage;
	jjjjjjj = (iiiiiii = ++(*variable)) + 1;
	storage = levelThreeLeafSeven(&iiiiiii) + levelThreeLeafEight(&jjjjjjj);
	return (storage);
}

levelThreeLeafOne(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafTwo(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafThree(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafFour(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafFive(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafSix(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafSeven(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}

levelThreeLeafEight(variable)
	short          *variable;
{
	short           i = *variable;

	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (++i);
}
@def_
@def $macro339()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()				/* alias root */
/*
 *  test class: static variable address, maltreated instance  : linear tree structure, used in conditional expression,
 * integer function declaration 
 */
{
	static short    i = 1;
	short           levelOneNodeOne();

	if (!(levelOneNodeOne(&i) == 32))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
levelOneNodeOne(variable)
	short          *variable;
{
	short           levelTwoNodeOne();
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return (2 * levelTwoNodeOne(&i));
}

short 
levelTwoNodeOne(variable)
	short          *variable;
{
	short           levelThreeLeafOne();
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	i *= 2;
	return (2 * levelThreeLeafOne(&i));
}

short 
levelThreeLeafOne(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (2 * i);
}
@def_
@def $macro340()
$LICENSE()
$HEAD()

char           *protean = "cassandracross";
char            globalCharacter = 10;
short           statusFlag = NoMistake;

main()				/* alias root */
/*
 *  test class: static variable address, changed to effect instance  : linear tree structure, used in conditional
 * expression, function declared to return a pointer to character 
 */
{
	static char     i = 4, j;
	char           *skip();

	j = 2 * i;
	if (compare(skip(&i), "andra", 5) != compare(skip(&j), "across", 6))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
skip(skipper)
	char           *skipper;
{
	char           *pointer;

	for (pointer = protean; *skipper > 0; (*skipper)--)
		pointer++;
	skipper = &globalCharacter;
	if (*skipper != 10)
		statusFlag++;
	return (pointer);
}

compare(s1, s2, n)
	char           *s1, *s2;
	short           n;
{
	while (--n >= 0 && *s1 == *s2++)
		if (*s1++ == '\0')
			return (0);
	return (n < 0 ? 0 : *s1 - *--s2);
}
@def_
@def $macro341()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : linear tree structure, in conditional expression, pointer to
 * function returning an integer 
 */
{
	static short    i = 12;
	short           divide4();

	if (dummy1(divide4, &i) != 3)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy1(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 3)
		statusFlag++;
	return (ii);
}

short 
divide4(integer)
	short          *integer;
{
	short           divide2();

	return (dummy2(divide2, integer) / 2);
}

dummy2(func, integer)
	short           (*func) (), *integer;
{
	short           ii;

	if ((ii = (*func) (integer)) != 6)
		statusFlag++;
	return (ii);
}

short 
divide2(integer)
	short          *integer;
{
	short           i = *integer;

	integer = &globalInteger;
	if (*integer != 10)
		statusFlag++;
	return (i / 2);
}
@def_
@def $macro342()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, legal, no function declaration 
 */
{
	static short    i = 1;
	short           result;

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;
	static short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro343()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, legal, integer function
 * declaration 
 */
{
	static short    i = 1;
	short           result = 0;
	short           recursiveFunction();

	result = recursiveFunction(&i);
	if (result != 1)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	short           result = 0;
	static short    i;
	short           recursiveFunction();

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = recursiveFunction(&i);
		if (result != 1)
			statusFlag++;
	}
	return (i);
}
@def_
@def $macro344()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, function declared to return a
 * pointer to character 
 */
{
	char           *s, *recursiveFunction();
	static short    i = 2;

	s = recursiveFunction(&i);
	if (*s != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	char           *s;
	static short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = recursiveFunction(&i);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + i);
}
@def_
@def $macro345()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, return value, pointer to function returning
 * an integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = dummy(increment, &i);
	if (result != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	short           result;
	static short    i;

	i = *variable;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = dummy(function, &i);
		if (result != 2)
			statusFlag++;
	}
	return (function(i));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro346()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, function in conditional expression, no
 * function declaration 
 */
{
	static short    i = 1;

	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

recursiveFunction(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return (i + 1);
}
@def_
@def $macro347()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, function in conditional expression, integer
 * function declaration 
 */
{
	short           recursiveFunction();
	static short    i = 1;

	if (recursiveFunction(&i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
recursiveFunction(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (recursiveFunction(&i) != 2)
			statusFlag++;
	return (i + 1);
}
@def_
@def $macro348()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;
char           *numbers = "0123456789";

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, in conditional expression, function declared
 * to return a pointer to character 
 */
{
	char           *recursiveFunction();
	static short    i = 2;

	if (*recursiveFunction(&i) != '2')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
recursiveFunction(variable)
	short          *variable;
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (!(*recursiveFunction(&i) == '2'))
			statusFlag++;
	return (numbers + i);
}
@def_
@def $macro349()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : recursive call, in conditional expression, pointer to
 * function returning an integer 
 */
{
	short           increment();
	static short    i = 1;

	if (dummy(increment, &i) != 2)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

dummy(function, variable)
	short           (*function) (), *variable;
{
	static short    i;

	i = *variable;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter)
		if (dummy(function, &i) != 2)
			statusFlag++;
	return (function(i));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_
@def $macro350()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, no function declaration 
 */
{
	static short    i = 2;
	short           result = 0;

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return (ii);
}

pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro351()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, changed to effect instance  : gemini, return value, legal, function declared to
 * return an integer 
 */
{
	static short    i = 2;
	short           result = 0, castor();

	result = castor(&i);
	if (result != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           result = 0, pollux();

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = pollux(&ii);
		if (result != 2)
			statusFlag++;
	}
	return (ii);
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		result = castor(&iii);
		if (result != 5)
			statusFlag++;
	}
	return (iii);
}
@def_
@def $macro352()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, return value, function declared to return a pointer
 * to character 
 */
{
	char           *s, *castor();
	static short    i = 2;

	s = castor(&i);
	if (*s != '6')
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	static short    ii;
	char           *s, *pollux();

	ii = *variable + 4;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = pollux(&ii);
		if (*s != '2')
			statusFlag++;
	}
	return (numbers + ii);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;
	char           *s;

	iii = *variable - 4;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		s = castor(&iii);
		if (*s != '6')
			statusFlag++;
	}
	return (numbers + iii);
}
@def_
@def $macro353()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, return value, pointer to function returning an
 * integer 
 */
{
	static short    i = 1;
	short           result = 0, increment();

	result = castor(increment, &i);
	if (result != 10)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;
	short           result = 0;

	ii = *variable + 8;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = pollux(function, &ii);
		if (result != 2)
			statusFlag++;
	}
	return (function(ii));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;
	short           result = 0;

	iii = *variable - 8;
	if (--counter) {
		variable = &globalInteger;
		if (*variable != 10)
			statusFlag++;
		result = castor(function, &iii);
		if (result != 10)
			statusFlag++;
	}
	return (function(iii));
}

short 
increment(variable)
	short           variable;
{

	return (++variable);
}
@def_
@def $macro354()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, no function declaration 
 */
{
	static short    i = 1;

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(variable)
	short          *variable;
{
	static short    ii;

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return (ii + 1);
}

pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return (iii + 1);
}
@def_
@def $macro355()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return an integer 
 */
{
	static short    i = 1;
	short           castor();

	if (castor(&i) != 5)
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

short 
castor(variable)
	short          *variable;
{
	static short    ii;
	short           pollux();

	ii = *variable + 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (pollux(&ii) != 2)
			statusFlag++;
	}
	return (ii + 1);
}

short 
pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 3;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (castor(&iii) != 5)
			statusFlag++;
	}
	return (iii + 1);
}
@def_
@def $macro356()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
char           *numbers = "0123456789";
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, function declared to
 * return a pointer to character 
 */
{
	char           *castor();
	static short    i = 2;

	if (!(*castor(&i) == '6'))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

char           *
castor(variable)
	short          *variable;
{
	char           *pollux();
	static short    ii;

	ii = *variable + 4;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*pollux(&ii) == '2'))
			statusFlag++;
	}
	return (numbers + ii);
}

char           *
pollux(variable)
	short          *variable;
{
	static short    iii;

	iii = *variable - 4;
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	if (--counter) {
		if (!(*castor(&iii) == '6'))
			statusFlag++;
	}
	return (numbers + iii);
}
@def_
@def $macro357()
$LICENSE()
$HEAD()

short           statusFlag = NoMistake;
short           counter = 10;
short           globalInteger = 10;

main()
/*
 * test class: static variable address, maltreated instance  : gemini, in conditional expression, pointer to function
 * returning an integer 
 */
{
	static short    i = 1;
	short           increment();

	if (!(castor(increment, &i) == 12))
		statusFlag++;
	if (statusFlag == NoMistake)
		printok();
	else
		printno();
	return (0);
}

castor(function, variable)
	short           (*function) (), *variable;
{
	static short    ii;

	ii = *variable + 10;
	if (--counter) {
		if (!(pollux(function, &ii) == 2))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (function(ii));
}

pollux(function, variable)
	short           (*function) (), *variable;
{
	static short    iii;

	iii = *variable - 10;
	if (--counter) {
		if (!(castor(function, &iii) == 12))
			statusFlag++;
	}
	variable = &globalInteger;
	if (*variable != 10)
		statusFlag++;
	return (function(iii));
}

short 
increment(variable)
	short           variable;
{
	return (++variable);
}
@def_

@def $testout()
#ifdef unix
#include<stdio.h>
#define printok() printf("@OK@\n")
#define printno() printf("@NG@\n")
#define ABS(a) ((a > 0)? (a) : (-(a)))
#define MAX(a, b) ((a > b)? (a) : (b))
#define TGEN_FLT_EQ(a, b) ( ((a)==(b)) || ABS(((a) - (b))) / MAX( ABS(a), ABS(b) ) <= __FLT_EPSILON__ )
#endif
@def_

@dir ckr.4-2-04
@file >>def.h $macro0() @file_
@file >>fdef.h $macro1() @file_
@file >>ft1901.c $macro2() @file_
@file >>ft1902.c $macro3() @file_
@file >>ft1904.c $macro4() @file_
@file >>ft1906.c $macro5() @file_
@file >>ft1908.c $macro6() @file_
@file >>ft1910.c $macro7() @file_
@file >>ft1911.c $macro8() @file_
@file >>ft1912.c $macro9() @file_
@file >>ft1914.c $macro10() @file_
@file >>ft1916.c $macro11() @file_
@file >>ft1918.c $macro12() @file_
@file >>ft1920.c $macro13() @file_
@file >>ft1921.c $macro14() @file_
@file >>ft1924.c $macro15() @file_
@file >>ft1926.c $macro16() @file_
@file >>ft1928.c $macro17() @file_
@file >>ft1930.c $macro18() @file_
@file >>ft2001.c $macro19() @file_
@file >>ft2002.c $macro20() @file_
@file >>ft2004.c $macro21() @file_
@file >>ft2006.c $macro22() @file_
@file >>ft2008.c $macro23() @file_
@file >>ft2010.c $macro24() @file_
@file >>ft2011.c $macro25() @file_
@file >>ft2012.c $macro26() @file_
@file >>ft2014.c $macro27() @file_
@file >>ft2016.c $macro28() @file_
@file >>ft2018.c $macro29() @file_
@file >>ft2020.c $macro30() @file_
@file >>ft2021.c $macro31() @file_
@file >>ft2022.c $macro32() @file_
@file >>ft2024.c $macro33() @file_
@file >>ft2026.c $macro34() @file_
@file >>ft2028.c $macro35() @file_
@file >>ft2030.c $macro36() @file_
@file >>ft2101.c $macro37() @file_
@file >>ft2102.c $macro38() @file_
@file >>ft2104.c $macro39() @file_
@file >>ft2106.c $macro40() @file_
@file >>ft2108.c $macro41() @file_
@file >>ft2110.c $macro42() @file_
@file >>ft2111.c $macro43() @file_
@file >>ft2112.c $macro44() @file_
@file >>ft2114.c $macro45() @file_
@file >>ft2116.c $macro46() @file_
@file >>ft2118.c $macro47() @file_
@file >>ft2120.c $macro48() @file_
@file >>ft2121.c $macro49() @file_
@file >>ft2122.c $macro50() @file_
@file >>ft2124.c $macro51() @file_
@file >>ft2126.c $macro52() @file_
@file >>ft2128.c $macro53() @file_
@file >>ft2130.c $macro54() @file_
@file >>ft2201.c $macro55() @file_
@file >>ft2202.c $macro56() @file_
@file >>ft2204.c $macro57() @file_
@file >>ft2206.c $macro58() @file_
@file >>ft2208.c $macro59() @file_
@file >>ft2210.c $macro60() @file_
@file >>ft2211.c $macro61() @file_
@file >>ft2212.c $macro62() @file_
@file >>ft2214.c $macro63() @file_
@file >>ft2216.c $macro64() @file_
@file >>ft2218.c $macro65() @file_
@file >>ft2220.c $macro66() @file_
@file >>ft2221.c $macro67() @file_
@file >>ft2222.c $macro68() @file_
@file >>ft2224.c $macro69() @file_
@file >>ft2226.c $macro70() @file_
@file >>ft2228.c $macro71() @file_
@file >>ft2230.c $macro72() @file_
@file >>ft2301.c $macro73() @file_
@file >>ft2302.c $macro74() @file_
@file >>ft2306.c $macro75() @file_
@file >>ft2308.c $macro76() @file_
@file >>ft2310.c $macro77() @file_
@file >>ft2311.c $macro78() @file_
@file >>ft2312.c $macro79() @file_
@file >>ft2314.c $macro80() @file_
@file >>ft2316.c $macro81() @file_
@file >>ft2318.c $macro82() @file_
@file >>ft2320.c $macro83() @file_
@file >>ft2321.c $macro84() @file_
@file >>ft2322.c $macro85() @file_
@file >>ft2324.c $macro86() @file_
@file >>ft2326.c $macro87() @file_
@file >>ft2328.c $macro88() @file_
@file >>ft2330.c $macro89() @file_
@file >>ft2401.c $macro90() @file_
@file >>ft2402.c $macro91() @file_
@file >>ft2404.c $macro92() @file_
@file >>ft2406.c $macro93() @file_
@file >>ft2408.c $macro94() @file_
@file >>ft2410.c $macro95() @file_
@file >>ft2411.c $macro96() @file_
@file >>ft2412.c $macro97() @file_
@file >>ft2414.c $macro98() @file_
@file >>ft2416.c $macro99() @file_
@file >>ft2418.c $macro100() @file_
@file >>ft2420.c $macro101() @file_
@file >>ft2421.c $macro102() @file_
@file >>ft2422.c $macro103() @file_
@file >>ft2424.c $macro104() @file_
@file >>ft2426.c $macro105() @file_
@file >>ft2428.c $macro106() @file_
@file >>ft2430.c $macro107() @file_
@file >>lt1901.c $macro108() @file_
@file >>lt1902.c $macro109() @file_
@file >>lt1904.c $macro110() @file_
@file >>lt1906.c $macro111() @file_
@file >>lt1908.c $macro112() @file_
@file >>lt1910.c $macro113() @file_
@file >>lt1911.c $macro114() @file_
@file >>lt1912.c $macro115() @file_
@file >>lt1914.c $macro116() @file_
@file >>lt1916.c $macro117() @file_
@file >>lt1918.c $macro118() @file_
@file >>lt1920.c $macro119() @file_
@file >>lt1921.c $macro120() @file_
@file >>lt1922.c $macro121() @file_
@file >>lt1924.c $macro122() @file_
@file >>lt1926.c $macro123() @file_
@file >>lt1928.c $macro124() @file_
@file >>lt1930.c $macro125() @file_
@file >>lt2001.c $macro126() @file_
@file >>lt2002.c $macro127() @file_
@file >>lt2004.c $macro128() @file_
@file >>lt2006.c $macro129() @file_
@file >>lt2008.c $macro130() @file_
@file >>lt2010.c $macro131() @file_
@file >>lt2011.c $macro132() @file_
@file >>lt2012.c $macro133() @file_
@file >>lt2014.c $macro134() @file_
@file >>lt2016.c $macro135() @file_
@file >>lt2018.c $macro136() @file_
@file >>lt2020.c $macro137() @file_
@file >>lt2021.c $macro138() @file_
@file >>lt2022.c $macro139() @file_
@file >>lt2024.c $macro140() @file_
@file >>lt2026.c $macro141() @file_
@file >>lt2028.c $macro142() @file_
@file >>lt2030.c $macro143() @file_
@file >>lt2101.c $macro144() @file_
@file >>lt2102.c $macro145() @file_
@file >>lt2104.c $macro146() @file_
@file >>lt2106.c $macro147() @file_
@file >>lt2108.c $macro148() @file_
@file >>lt2110.c $macro149() @file_
@file >>lt2111.c $macro150() @file_
@file >>lt2112.c $macro151() @file_
@file >>lt2114.c $macro152() @file_
@file >>lt2116.c $macro153() @file_
@file >>lt2118.c $macro154() @file_
@file >>lt2120.c $macro155() @file_
@file >>lt2121.c $macro156() @file_
@file >>lt2122.c $macro157() @file_
@file >>lt2124.c $macro158() @file_
@file >>lt2126.c $macro159() @file_
@file >>lt2128.c $macro160() @file_
@file >>lt2130.c $macro161() @file_
@file >>lt2201.c $macro162() @file_
@file >>lt2202.c $macro163() @file_
@file >>lt2204.c $macro164() @file_
@file >>lt2206.c $macro165() @file_
@file >>lt2208.c $macro166() @file_
@file >>lt2210.c $macro167() @file_
@file >>lt2211.c $macro168() @file_
@file >>lt2212.c $macro169() @file_
@file >>lt2214.c $macro170() @file_
@file >>lt2216.c $macro171() @file_
@file >>lt2218.c $macro172() @file_
@file >>lt2220.c $macro173() @file_
@file >>lt2221.c $macro174() @file_
@file >>lt2224.c $macro175() @file_
@file >>lt2226.c $macro176() @file_
@file >>lt2228.c $macro177() @file_
@file >>lt2230.c $macro178() @file_
@file >>lt2301.c $macro179() @file_
@file >>lt2302.c $macro180() @file_
@file >>lt2306.c $macro181() @file_
@file >>lt2308.c $macro182() @file_
@file >>lt2310.c $macro183() @file_
@file >>lt2311.c $macro184() @file_
@file >>lt2312.c $macro185() @file_
@file >>lt2314.c $macro186() @file_
@file >>lt2316.c $macro187() @file_
@file >>lt2318.c $macro188() @file_
@file >>lt2320.c $macro189() @file_
@file >>lt2321.c $macro190() @file_
@file >>lt2322.c $macro191() @file_
@file >>lt2324.c $macro192() @file_
@file >>lt2326.c $macro193() @file_
@file >>lt2328.c $macro194() @file_
@file >>lt2330.c $macro195() @file_
@file >>lt2401.c $macro196() @file_
@file >>lt2402.c $macro197() @file_
@file >>lt2404.c $macro198() @file_
@file >>lt2406.c $macro199() @file_
@file >>lt2408.c $macro200() @file_
@file >>lt2410.c $macro201() @file_
@file >>lt2411.c $macro202() @file_
@file >>lt2412.c $macro203() @file_
@file >>lt2414.c $macro204() @file_
@file >>lt2416.c $macro205() @file_
@file >>lt2418.c $macro206() @file_
@file >>lt2420.c $macro207() @file_
@file >>lt2421.c $macro208() @file_
@file >>lt2422.c $macro209() @file_
@file >>lt2424.c $macro210() @file_
@file >>lt2426.c $macro211() @file_
@file >>lt2428.c $macro212() @file_
@file >>lt2430.c $macro213() @file_
@file >>t1903.c $macro214() @file_
@file >>t1904.c $macro215() @file_
@file >>t1905.c $macro216() @file_
@file >>t1906.c $macro217() @file_
@file >>t1907.c $macro218() @file_
@file >>t1908.c $macro219() @file_
@file >>t1909.c $macro220() @file_
@file >>t1910.c $macro221() @file_
@file >>t1913.c $macro222() @file_
@file >>t1914.c $macro223() @file_
@file >>t1915.c $macro224() @file_
@file >>t1916.c $macro225() @file_
@file >>t1917.c $macro226() @file_
@file >>t1918.c $macro227() @file_
@file >>t1919.c $macro228() @file_
@file >>t1920.c $macro229() @file_
@file >>t1923.c $macro230() @file_
@file >>t1924.c $macro231() @file_
@file >>t1925.c $macro232() @file_
@file >>t1926.c $macro233() @file_
@file >>t1927.c $macro234() @file_
@file >>t1928.c $macro235() @file_
@file >>t1929.c $macro236() @file_
@file >>t1930.c $macro237() @file_
@file >>t2003.c $macro238() @file_
@file >>t2004.c $macro239() @file_
@file >>t2005.c $macro240() @file_
@file >>t2006.c $macro241() @file_
@file >>t2007.c $macro242() @file_
@file >>t2008.c $macro243() @file_
@file >>t2009.c $macro244() @file_
@file >>t2010.c $macro245() @file_
@file >>t2013.c $macro246() @file_
@file >>t2014.c $macro247() @file_
@file >>t2015.c $macro248() @file_
@file >>t2016.c $macro249() @file_
@file >>t2017.c $macro250() @file_
@file >>t2018.c $macro251() @file_
@file >>t2019.c $macro252() @file_
@file >>t2020.c $macro253() @file_
@file >>t2023.c $macro254() @file_
@file >>t2024.c $macro255() @file_
@file >>t2025.c $macro256() @file_
@file >>t2026.c $macro257() @file_
@file >>t2027.c $macro258() @file_
@file >>t2028.c $macro259() @file_
@file >>t2029.c $macro260() @file_
@file >>t2030.c $macro261() @file_
@file >>t2103.c $macro262() @file_
@file >>t2104.c $macro263() @file_
@file >>t2105.c $macro264() @file_
@file >>t2106.c $macro265() @file_
@file >>t2107.c $macro266() @file_
@file >>t2108.c $macro267() @file_
@file >>t2109.c $macro268() @file_
@file >>t2110.c $macro269() @file_
@file >>t2113.c $macro270() @file_
@file >>t2114.c $macro271() @file_
@file >>t2115.c $macro272() @file_
@file >>t2116.c $macro273() @file_
@file >>t2117.c $macro274() @file_
@file >>t2118.c $macro275() @file_
@file >>t2119.c $macro276() @file_
@file >>t2120.c $macro277() @file_
@file >>t2123.c $macro278() @file_
@file >>t2124.c $macro279() @file_
@file >>t2125.c $macro280() @file_
@file >>t2126.c $macro281() @file_
@file >>t2127.c $macro282() @file_
@file >>t2128.c $macro283() @file_
@file >>t2129.c $macro284() @file_
@file >>t2130.c $macro285() @file_
@file >>t2203.c $macro286() @file_
@file >>t2204.c $macro287() @file_
@file >>t2205.c $macro288() @file_
@file >>t2206.c $macro289() @file_
@file >>t2207.c $macro290() @file_
@file >>t2208.c $macro291() @file_
@file >>t2209.c $macro292() @file_
@file >>t2210.c $macro293() @file_
@file >>t2213.c $macro294() @file_
@file >>t2214.c $macro295() @file_
@file >>t2215.c $macro296() @file_
@file >>t2216.c $macro297() @file_
@file >>t2217.c $macro298() @file_
@file >>t2218.c $macro299() @file_
@file >>t2219.c $macro300() @file_
@file >>t2220.c $macro301() @file_
@file >>t2223.c $macro302() @file_
@file >>t2224.c $macro303() @file_
@file >>t2225.c $macro304() @file_
@file >>t2226.c $macro305() @file_
@file >>t2227.c $macro306() @file_
@file >>t2228.c $macro307() @file_
@file >>t2229.c $macro308() @file_
@file >>t2230.c $macro309() @file_
@file >>t2303.c $macro310() @file_
@file >>t2304.c $macro311() @file_
@file >>t2305.c $macro312() @file_
@file >>t2306.c $macro313() @file_
@file >>t2307.c $macro314() @file_
@file >>t2308.c $macro315() @file_
@file >>t2309.c $macro316() @file_
@file >>t2310.c $macro317() @file_
@file >>t2313.c $macro318() @file_
@file >>t2314.c $macro319() @file_
@file >>t2315.c $macro320() @file_
@file >>t2316.c $macro321() @file_
@file >>t2317.c $macro322() @file_
@file >>t2318.c $macro323() @file_
@file >>t2319.c $macro324() @file_
@file >>t2320.c $macro325() @file_
@file >>t2323.c $macro326() @file_
@file >>t2324.c $macro327() @file_
@file >>t2325.c $macro328() @file_
@file >>t2326.c $macro329() @file_
@file >>t2327.c $macro330() @file_
@file >>t2328.c $macro331() @file_
@file >>t2329.c $macro332() @file_
@file >>t2330.c $macro333() @file_
@file >>t2403.c $macro334() @file_
@file >>t2404.c $macro335() @file_
@file >>t2405.c $macro336() @file_
@file >>t2406.c $macro337() @file_
@file >>t2407.c $macro338() @file_
@file >>t2408.c $macro339() @file_
@file >>t2409.c $macro340() @file_
@file >>t2410.c $macro341() @file_
@file >>t2413.c $macro342() @file_
@file >>t2414.c $macro343() @file_
@file >>t2415.c $macro344() @file_
@file >>t2416.c $macro345() @file_
@file >>t2417.c $macro346() @file_
@file >>t2418.c $macro347() @file_
@file >>t2419.c $macro348() @file_
@file >>t2420.c $macro349() @file_
@file >>t2423.c $macro350() @file_
@file >>t2424.c $macro351() @file_
@file >>t2425.c $macro352() @file_
@file >>t2426.c $macro353() @file_
@file >>t2427.c $macro354() @file_
@file >>t2428.c $macro355() @file_
@file >>t2429.c $macro356() @file_
@file >>t2430.c $macro357() @file_
@file >>testout.h $testout() @file_
@dir_
